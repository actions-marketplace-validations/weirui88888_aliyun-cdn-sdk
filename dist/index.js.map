{"version":3,"file":"index.js","sources":["../webpack://typescript-action/./lib/client.js","../webpack://typescript-action/./lib/main.js","../webpack://typescript-action/./node_modules/@actions/core/lib/command.js","../webpack://typescript-action/./node_modules/@actions/core/lib/core.js","../webpack://typescript-action/./node_modules/@actions/core/lib/file-command.js","../webpack://typescript-action/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://typescript-action/./node_modules/@actions/core/lib/summary.js","../webpack://typescript-action/./node_modules/@actions/core/lib/utils.js","../webpack://typescript-action/./node_modules/@actions/http-client/lib/auth.js","../webpack://typescript-action/./node_modules/@actions/http-client/lib/index.js","../webpack://typescript-action/./node_modules/@actions/http-client/lib/proxy.js","../webpack://typescript-action/./node_modules/@alicloud/cdn20180510/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/access_key_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/bearer_token_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/config.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/default_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/ecs_ram_role_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/oidc_role_arn_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/provider/credentials_uri_provider.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/provider/environment_variable_credentials_provider.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/provider/instance_ram_role_credentials_provider.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/provider/profile_credentials_provider.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/provider/provider_chain.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/ram_role_arn_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/rsa_key_pair_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/session_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/sts_token_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/uri_credential.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/util/helper.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/util/http.js","../webpack://typescript-action/./node_modules/@alicloud/credentials/dist/util/utils.js","../webpack://typescript-action/./node_modules/@alicloud/endpoint-util/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/gateway-spi/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/openapi-client/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/openapi-util/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/tea-console/dist/client.js","../webpack://typescript-action/./node_modules/@alicloud/tea-typescript/dist/tea.js","../webpack://typescript-action/./node_modules/@alicloud/tea-util/dist/client.js","../webpack://typescript-action/./node_modules/debug/src/browser.js","../webpack://typescript-action/./node_modules/debug/src/common.js","../webpack://typescript-action/./node_modules/debug/src/index.js","../webpack://typescript-action/./node_modules/debug/src/node.js","../webpack://typescript-action/./node_modules/has-flag/index.js","../webpack://typescript-action/./node_modules/httpx/lib/index.js","../webpack://typescript-action/./node_modules/ini/ini.js","../webpack://typescript-action/./node_modules/kitx/lib/index.js","../webpack://typescript-action/./node_modules/ms/index.js","../webpack://typescript-action/./node_modules/supports-color/index.js","../webpack://typescript-action/./node_modules/tunnel/index.js","../webpack://typescript-action/./node_modules/tunnel/lib/tunnel.js","../webpack://typescript-action/external \"assert\"","../webpack://typescript-action/external \"crypto\"","../webpack://typescript-action/external \"events\"","../webpack://typescript-action/external \"fs\"","../webpack://typescript-action/external \"http\"","../webpack://typescript-action/external \"https\"","../webpack://typescript-action/external \"net\"","../webpack://typescript-action/external \"os\"","../webpack://typescript-action/external \"path\"","../webpack://typescript-action/external \"querystring\"","../webpack://typescript-action/external \"stream\"","../webpack://typescript-action/external \"tls\"","../webpack://typescript-action/external \"tty\"","../webpack://typescript-action/external \"url\"","../webpack://typescript-action/external \"util\"","../webpack://typescript-action/external \"zlib\"","../webpack://typescript-action/webpack/bootstrap","../webpack://typescript-action/webpack/runtime/compat","../webpack://typescript-action/webpack/startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tea_console_1 = __importDefault(require(\"@alicloud/tea-console\"));\nconst $OpenApi = __importStar(require(\"@alicloud/openapi-client\"));\nconst cdn20180510_1 = __importStar(require(\"@alicloud/cdn20180510\")), $Cdn = cdn20180510_1;\nclass Client {\n    static createCdnClient(accessKeyId, accessKeySecret) {\n        const config = new $OpenApi.Config({\n            accessKeyId,\n            accessKeySecret\n        });\n        config.endpoint = 'cdn.aliyuncs.com';\n        return new cdn20180510_1.default(config);\n    }\n    static DescribeCdnDomainConfigs(accessKeyId, accessKeySecret, domainName, functionNames) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = Client.createCdnClient(accessKeyId, accessKeySecret);\n            console.log('---------------------------client----------------------');\n            console.log(client);\n            console.log('---------------------------client----------------------');\n            const req = new $Cdn.DescribeCdnDomainConfigsRequest({\n                domainName,\n                functionNames\n            });\n            console.log('---------------------------req----------------------');\n            console.log(req);\n            console.log('---------------------------req----------------------');\n            const resp = yield client.describeCdnDomainConfigs(req);\n            console.log('---------------------------resp----------------------');\n            console.log(resp);\n            console.log('---------------------------resp----------------------');\n            tea_console_1.default.log('--------------------获取域名的配置成功--------------------');\n            return resp;\n        });\n    }\n}\nexports.default = Client;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core = __importStar(require(\"@actions/core\"));\nconst client_1 = __importDefault(require(\"./client\"));\nfunction run() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const accessKeyId = core.getInput('accessKeyId');\n            const accessKeySecret = core.getInput('accessKeySecret');\n            const resp = yield client_1.default.DescribeCdnDomainConfigs(accessKeyId, accessKeySecret, 'hexo.newarray.vip', 'filetype_based_ttl_set');\n            core.setOutput('DescribeCdnDomainConfigs', resp.body.domainConfigs);\n        }\n        catch (error) {\n            if (error instanceof Error)\n                core.setFailed(error.message);\n        }\n    });\n}\nrun();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n//# sourceMappingURL=proxy.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This file is auto-generated, don't edit it\n/**\n *\n */\nconst tea_util_1 = __importStar(require(\"@alicloud/tea-util\")), $Util = tea_util_1;\nconst openapi_client_1 = __importStar(require(\"@alicloud/openapi-client\")), $OpenApi = openapi_client_1;\nconst openapi_util_1 = __importDefault(require(\"@alicloud/openapi-util\"));\nconst endpoint_util_1 = __importDefault(require(\"@alicloud/endpoint-util\"));\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass AddCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            checkUrl: 'CheckUrl',\n            domainName: 'DomainName',\n            ownerAccount: 'OwnerAccount',\n            ownerId: 'OwnerId',\n            resourceGroupId: 'ResourceGroupId',\n            scope: 'Scope',\n            securityToken: 'SecurityToken',\n            sources: 'Sources',\n            topLevelDomain: 'TopLevelDomain',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            checkUrl: 'string',\n            domainName: 'string',\n            ownerAccount: 'string',\n            ownerId: 'number',\n            resourceGroupId: 'string',\n            scope: 'string',\n            securityToken: 'string',\n            sources: 'string',\n            topLevelDomain: 'string',\n        };\n    }\n}\nexports.AddCdnDomainRequest = AddCdnDomainRequest;\nclass AddCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.AddCdnDomainResponseBody = AddCdnDomainResponseBody;\nclass AddCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: AddCdnDomainResponseBody,\n        };\n    }\n}\nexports.AddCdnDomainResponse = AddCdnDomainResponse;\nclass AddFCTriggerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            eventMetaName: 'EventMetaName',\n            eventMetaVersion: 'EventMetaVersion',\n            functionARN: 'FunctionARN',\n            notes: 'Notes',\n            ownerId: 'OwnerId',\n            roleARN: 'RoleARN',\n            sourceARN: 'SourceARN',\n            triggerARN: 'TriggerARN',\n        };\n    }\n    static types() {\n        return {\n            eventMetaName: 'string',\n            eventMetaVersion: 'string',\n            functionARN: 'string',\n            notes: 'string',\n            ownerId: 'number',\n            roleARN: 'string',\n            sourceARN: 'string',\n            triggerARN: 'string',\n        };\n    }\n}\nexports.AddFCTriggerRequest = AddFCTriggerRequest;\nclass AddFCTriggerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.AddFCTriggerResponseBody = AddFCTriggerResponseBody;\nclass AddFCTriggerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: AddFCTriggerResponseBody,\n        };\n    }\n}\nexports.AddFCTriggerResponse = AddFCTriggerResponse;\nclass BatchAddCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            checkUrl: 'CheckUrl',\n            domainName: 'DomainName',\n            ownerAccount: 'OwnerAccount',\n            ownerId: 'OwnerId',\n            resourceGroupId: 'ResourceGroupId',\n            scope: 'Scope',\n            securityToken: 'SecurityToken',\n            sources: 'Sources',\n            topLevelDomain: 'TopLevelDomain',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            checkUrl: 'string',\n            domainName: 'string',\n            ownerAccount: 'string',\n            ownerId: 'number',\n            resourceGroupId: 'string',\n            scope: 'string',\n            securityToken: 'string',\n            sources: 'string',\n            topLevelDomain: 'string',\n        };\n    }\n}\nexports.BatchAddCdnDomainRequest = BatchAddCdnDomainRequest;\nclass BatchAddCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchAddCdnDomainResponseBody = BatchAddCdnDomainResponseBody;\nclass BatchAddCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchAddCdnDomainResponseBody,\n        };\n    }\n}\nexports.BatchAddCdnDomainResponse = BatchAddCdnDomainResponse;\nclass BatchDeleteCdnDomainConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'DomainNames',\n            functionNames: 'FunctionNames',\n            ownerAccount: 'OwnerAccount',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainNames: 'string',\n            functionNames: 'string',\n            ownerAccount: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.BatchDeleteCdnDomainConfigRequest = BatchDeleteCdnDomainConfigRequest;\nclass BatchDeleteCdnDomainConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchDeleteCdnDomainConfigResponseBody = BatchDeleteCdnDomainConfigResponseBody;\nclass BatchDeleteCdnDomainConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchDeleteCdnDomainConfigResponseBody,\n        };\n    }\n}\nexports.BatchDeleteCdnDomainConfigResponse = BatchDeleteCdnDomainConfigResponse;\nclass BatchSetCdnDomainConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'DomainNames',\n            functions: 'Functions',\n            ownerAccount: 'OwnerAccount',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainNames: 'string',\n            functions: 'string',\n            ownerAccount: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.BatchSetCdnDomainConfigRequest = BatchSetCdnDomainConfigRequest;\nclass BatchSetCdnDomainConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainConfigList: 'DomainConfigList',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            domainConfigList: BatchSetCdnDomainConfigResponseBodyDomainConfigList,\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchSetCdnDomainConfigResponseBody = BatchSetCdnDomainConfigResponseBody;\nclass BatchSetCdnDomainConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchSetCdnDomainConfigResponseBody,\n        };\n    }\n}\nexports.BatchSetCdnDomainConfigResponse = BatchSetCdnDomainConfigResponse;\nclass BatchSetCdnDomainServerCertificateRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certName: 'CertName',\n            certType: 'CertType',\n            domainName: 'DomainName',\n            forceSet: 'ForceSet',\n            ownerId: 'OwnerId',\n            region: 'Region',\n            SSLPri: 'SSLPri',\n            SSLProtocol: 'SSLProtocol',\n            SSLPub: 'SSLPub',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            certName: 'string',\n            certType: 'string',\n            domainName: 'string',\n            forceSet: 'string',\n            ownerId: 'number',\n            region: 'string',\n            SSLPri: 'string',\n            SSLProtocol: 'string',\n            SSLPub: 'string',\n            securityToken: 'string',\n        };\n    }\n}\nexports.BatchSetCdnDomainServerCertificateRequest = BatchSetCdnDomainServerCertificateRequest;\nclass BatchSetCdnDomainServerCertificateResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchSetCdnDomainServerCertificateResponseBody = BatchSetCdnDomainServerCertificateResponseBody;\nclass BatchSetCdnDomainServerCertificateResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchSetCdnDomainServerCertificateResponseBody,\n        };\n    }\n}\nexports.BatchSetCdnDomainServerCertificateResponse = BatchSetCdnDomainServerCertificateResponse;\nclass BatchStartCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'DomainNames',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainNames: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.BatchStartCdnDomainRequest = BatchStartCdnDomainRequest;\nclass BatchStartCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchStartCdnDomainResponseBody = BatchStartCdnDomainResponseBody;\nclass BatchStartCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchStartCdnDomainResponseBody,\n        };\n    }\n}\nexports.BatchStartCdnDomainResponse = BatchStartCdnDomainResponse;\nclass BatchStopCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'DomainNames',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainNames: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.BatchStopCdnDomainRequest = BatchStopCdnDomainRequest;\nclass BatchStopCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchStopCdnDomainResponseBody = BatchStopCdnDomainResponseBody;\nclass BatchStopCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchStopCdnDomainResponseBody,\n        };\n    }\n}\nexports.BatchStopCdnDomainResponse = BatchStopCdnDomainResponse;\nclass BatchUpdateCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            resourceGroupId: 'ResourceGroupId',\n            securityToken: 'SecurityToken',\n            sources: 'Sources',\n            topLevelDomain: 'TopLevelDomain',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            resourceGroupId: 'string',\n            securityToken: 'string',\n            sources: 'string',\n            topLevelDomain: 'string',\n        };\n    }\n}\nexports.BatchUpdateCdnDomainRequest = BatchUpdateCdnDomainRequest;\nclass BatchUpdateCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.BatchUpdateCdnDomainResponseBody = BatchUpdateCdnDomainResponseBody;\nclass BatchUpdateCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: BatchUpdateCdnDomainResponseBody,\n        };\n    }\n}\nexports.BatchUpdateCdnDomainResponse = BatchUpdateCdnDomainResponse;\nclass CreateCdnCertificateSigningRequestRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            city: 'City',\n            commonName: 'CommonName',\n            country: 'Country',\n            email: 'Email',\n            organization: 'Organization',\n            organizationUnit: 'OrganizationUnit',\n            ownerId: 'OwnerId',\n            SANs: 'SANs',\n            state: 'State',\n        };\n    }\n    static types() {\n        return {\n            city: 'string',\n            commonName: 'string',\n            country: 'string',\n            email: 'string',\n            organization: 'string',\n            organizationUnit: 'string',\n            ownerId: 'number',\n            SANs: 'string',\n            state: 'string',\n        };\n    }\n}\nexports.CreateCdnCertificateSigningRequestRequest = CreateCdnCertificateSigningRequestRequest;\nclass CreateCdnCertificateSigningRequestResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            commonName: 'CommonName',\n            csr: 'Csr',\n            pubMd5: 'PubMd5',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            commonName: 'string',\n            csr: 'string',\n            pubMd5: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.CreateCdnCertificateSigningRequestResponseBody = CreateCdnCertificateSigningRequestResponseBody;\nclass CreateCdnCertificateSigningRequestResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateCdnCertificateSigningRequestResponseBody,\n        };\n    }\n}\nexports.CreateCdnCertificateSigningRequestResponse = CreateCdnCertificateSigningRequestResponse;\nclass CreateCdnDeliverTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            deliver: 'Deliver',\n            domainName: 'DomainName',\n            name: 'Name',\n            ownerId: 'OwnerId',\n            reports: 'Reports',\n            schedule: 'Schedule',\n        };\n    }\n    static types() {\n        return {\n            deliver: 'string',\n            domainName: 'string',\n            name: 'string',\n            ownerId: 'number',\n            reports: 'string',\n            schedule: 'string',\n        };\n    }\n}\nexports.CreateCdnDeliverTaskRequest = CreateCdnDeliverTaskRequest;\nclass CreateCdnDeliverTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            deliverId: 'DeliverId',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            deliverId: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.CreateCdnDeliverTaskResponseBody = CreateCdnDeliverTaskResponseBody;\nclass CreateCdnDeliverTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateCdnDeliverTaskResponseBody,\n        };\n    }\n}\nexports.CreateCdnDeliverTaskResponse = CreateCdnDeliverTaskResponse;\nclass CreateCdnSubTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            reportIds: 'ReportIds',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            reportIds: 'string',\n        };\n    }\n}\nexports.CreateCdnSubTaskRequest = CreateCdnSubTaskRequest;\nclass CreateCdnSubTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.CreateCdnSubTaskResponseBody = CreateCdnSubTaskResponseBody;\nclass CreateCdnSubTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateCdnSubTaskResponseBody,\n        };\n    }\n}\nexports.CreateCdnSubTaskResponse = CreateCdnSubTaskResponse;\nclass CreateIllegalUrlExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            taskName: 'TaskName',\n            timePoint: 'TimePoint',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            taskName: 'string',\n            timePoint: 'string',\n        };\n    }\n}\nexports.CreateIllegalUrlExportTaskRequest = CreateIllegalUrlExportTaskRequest;\nclass CreateIllegalUrlExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            taskId: 'string',\n        };\n    }\n}\nexports.CreateIllegalUrlExportTaskResponseBody = CreateIllegalUrlExportTaskResponseBody;\nclass CreateIllegalUrlExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateIllegalUrlExportTaskResponseBody,\n        };\n    }\n}\nexports.CreateIllegalUrlExportTaskResponse = CreateIllegalUrlExportTaskResponse;\nclass CreateRealTimeLogDeliveryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            logstore: 'Logstore',\n            ownerId: 'OwnerId',\n            project: 'Project',\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            logstore: 'string',\n            ownerId: 'number',\n            project: 'string',\n            region: 'string',\n        };\n    }\n}\nexports.CreateRealTimeLogDeliveryRequest = CreateRealTimeLogDeliveryRequest;\nclass CreateRealTimeLogDeliveryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.CreateRealTimeLogDeliveryResponseBody = CreateRealTimeLogDeliveryResponseBody;\nclass CreateRealTimeLogDeliveryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateRealTimeLogDeliveryResponseBody,\n        };\n    }\n}\nexports.CreateRealTimeLogDeliveryResponse = CreateRealTimeLogDeliveryResponse;\nclass CreateUsageDetailDataExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'DomainNames',\n            endTime: 'EndTime',\n            group: 'Group',\n            language: 'Language',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n            taskName: 'TaskName',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            domainNames: 'string',\n            endTime: 'string',\n            group: 'string',\n            language: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n            taskName: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.CreateUsageDetailDataExportTaskRequest = CreateUsageDetailDataExportTaskRequest;\nclass CreateUsageDetailDataExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            taskId: 'string',\n        };\n    }\n}\nexports.CreateUsageDetailDataExportTaskResponseBody = CreateUsageDetailDataExportTaskResponseBody;\nclass CreateUsageDetailDataExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateUsageDetailDataExportTaskResponseBody,\n        };\n    }\n}\nexports.CreateUsageDetailDataExportTaskResponse = CreateUsageDetailDataExportTaskResponse;\nclass CreateUserUsageDataExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            language: 'Language',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n            taskName: 'TaskName',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            language: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n            taskName: 'string',\n        };\n    }\n}\nexports.CreateUserUsageDataExportTaskRequest = CreateUserUsageDataExportTaskRequest;\nclass CreateUserUsageDataExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            taskId: 'string',\n        };\n    }\n}\nexports.CreateUserUsageDataExportTaskResponseBody = CreateUserUsageDataExportTaskResponseBody;\nclass CreateUserUsageDataExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: CreateUserUsageDataExportTaskResponseBody,\n        };\n    }\n}\nexports.CreateUserUsageDataExportTaskResponse = CreateUserUsageDataExportTaskResponse;\nclass DeleteCdnDeliverTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            deliverId: 'DeliverId',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            deliverId: 'number',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DeleteCdnDeliverTaskRequest = DeleteCdnDeliverTaskRequest;\nclass DeleteCdnDeliverTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteCdnDeliverTaskResponseBody = DeleteCdnDeliverTaskResponseBody;\nclass DeleteCdnDeliverTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteCdnDeliverTaskResponseBody,\n        };\n    }\n}\nexports.DeleteCdnDeliverTaskResponse = DeleteCdnDeliverTaskResponse;\nclass DeleteCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerAccount: 'OwnerAccount',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerAccount: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DeleteCdnDomainRequest = DeleteCdnDomainRequest;\nclass DeleteCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteCdnDomainResponseBody = DeleteCdnDomainResponseBody;\nclass DeleteCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteCdnDomainResponseBody,\n        };\n    }\n}\nexports.DeleteCdnDomainResponse = DeleteCdnDomainResponse;\nclass DeleteCdnSubTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.DeleteCdnSubTaskRequest = DeleteCdnSubTaskRequest;\nclass DeleteCdnSubTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteCdnSubTaskResponseBody = DeleteCdnSubTaskResponseBody;\nclass DeleteCdnSubTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteCdnSubTaskResponseBody,\n        };\n    }\n}\nexports.DeleteCdnSubTaskResponse = DeleteCdnSubTaskResponse;\nclass DeleteFCTriggerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            triggerARN: 'TriggerARN',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            triggerARN: 'string',\n        };\n    }\n}\nexports.DeleteFCTriggerRequest = DeleteFCTriggerRequest;\nclass DeleteFCTriggerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteFCTriggerResponseBody = DeleteFCTriggerResponseBody;\nclass DeleteFCTriggerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteFCTriggerResponseBody,\n        };\n    }\n}\nexports.DeleteFCTriggerResponse = DeleteFCTriggerResponse;\nclass DeleteRealtimeLogDeliveryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            logstore: 'Logstore',\n            ownerId: 'OwnerId',\n            project: 'Project',\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            logstore: 'string',\n            ownerId: 'number',\n            project: 'string',\n            region: 'string',\n        };\n    }\n}\nexports.DeleteRealtimeLogDeliveryRequest = DeleteRealtimeLogDeliveryRequest;\nclass DeleteRealtimeLogDeliveryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteRealtimeLogDeliveryResponseBody = DeleteRealtimeLogDeliveryResponseBody;\nclass DeleteRealtimeLogDeliveryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteRealtimeLogDeliveryResponseBody,\n        };\n    }\n}\nexports.DeleteRealtimeLogDeliveryResponse = DeleteRealtimeLogDeliveryResponse;\nclass DeleteSpecificConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DeleteSpecificConfigRequest = DeleteSpecificConfigRequest;\nclass DeleteSpecificConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteSpecificConfigResponseBody = DeleteSpecificConfigResponseBody;\nclass DeleteSpecificConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteSpecificConfigResponseBody,\n        };\n    }\n}\nexports.DeleteSpecificConfigResponse = DeleteSpecificConfigResponse;\nclass DeleteSpecificStagingConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DeleteSpecificStagingConfigRequest = DeleteSpecificStagingConfigRequest;\nclass DeleteSpecificStagingConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteSpecificStagingConfigResponseBody = DeleteSpecificStagingConfigResponseBody;\nclass DeleteSpecificStagingConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteSpecificStagingConfigResponseBody,\n        };\n    }\n}\nexports.DeleteSpecificStagingConfigResponse = DeleteSpecificStagingConfigResponse;\nclass DeleteUsageDetailDataExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            taskId: 'string',\n        };\n    }\n}\nexports.DeleteUsageDetailDataExportTaskRequest = DeleteUsageDetailDataExportTaskRequest;\nclass DeleteUsageDetailDataExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteUsageDetailDataExportTaskResponseBody = DeleteUsageDetailDataExportTaskResponseBody;\nclass DeleteUsageDetailDataExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteUsageDetailDataExportTaskResponseBody,\n        };\n    }\n}\nexports.DeleteUsageDetailDataExportTaskResponse = DeleteUsageDetailDataExportTaskResponse;\nclass DeleteUserUsageDataExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            taskId: 'string',\n        };\n    }\n}\nexports.DeleteUserUsageDataExportTaskRequest = DeleteUserUsageDataExportTaskRequest;\nclass DeleteUserUsageDataExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DeleteUserUsageDataExportTaskResponseBody = DeleteUserUsageDataExportTaskResponseBody;\nclass DeleteUserUsageDataExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DeleteUserUsageDataExportTaskResponseBody,\n        };\n    }\n}\nexports.DeleteUserUsageDataExportTaskResponse = DeleteUserUsageDataExportTaskResponse;\nclass DescribeActiveVersionOfConfigGroupRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configGroupId: 'ConfigGroupId',\n            env: 'Env',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            configGroupId: 'string',\n            env: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeActiveVersionOfConfigGroupRequest = DescribeActiveVersionOfConfigGroupRequest;\nclass DescribeActiveVersionOfConfigGroupResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            baseVersionId: 'BaseVersionId',\n            configGroupId: 'ConfigGroupId',\n            createTime: 'CreateTime',\n            description: 'Description',\n            operator: 'Operator',\n            requestId: 'RequestId',\n            seqId: 'SeqId',\n            status: 'Status',\n            updateTime: 'UpdateTime',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            baseVersionId: 'string',\n            configGroupId: 'string',\n            createTime: 'string',\n            description: 'string',\n            operator: 'string',\n            requestId: 'string',\n            seqId: 'number',\n            status: 'string',\n            updateTime: 'string',\n            versionId: 'string',\n        };\n    }\n}\nexports.DescribeActiveVersionOfConfigGroupResponseBody = DescribeActiveVersionOfConfigGroupResponseBody;\nclass DescribeActiveVersionOfConfigGroupResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeActiveVersionOfConfigGroupResponseBody,\n        };\n    }\n}\nexports.DescribeActiveVersionOfConfigGroupResponse = DescribeActiveVersionOfConfigGroupResponse;\nclass DescribeBlockedRegionsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            language: 'Language',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            language: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeBlockedRegionsRequest = DescribeBlockedRegionsRequest;\nclass DescribeBlockedRegionsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            infoList: 'InfoList',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            infoList: DescribeBlockedRegionsResponseBodyInfoList,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeBlockedRegionsResponseBody = DescribeBlockedRegionsResponseBody;\nclass DescribeBlockedRegionsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeBlockedRegionsResponseBody,\n        };\n    }\n}\nexports.DescribeBlockedRegionsResponse = DescribeBlockedRegionsResponse;\nclass DescribeCdnCertificateDetailRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certName: 'CertName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            certName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnCertificateDetailRequest = DescribeCdnCertificateDetailRequest;\nclass DescribeCdnCertificateDetailResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cert: 'Cert',\n            certId: 'CertId',\n            certName: 'CertName',\n            key: 'Key',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            cert: 'string',\n            certId: 'number',\n            certName: 'string',\n            key: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnCertificateDetailResponseBody = DescribeCdnCertificateDetailResponseBody;\nclass DescribeCdnCertificateDetailResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnCertificateDetailResponseBody,\n        };\n    }\n}\nexports.DescribeCdnCertificateDetailResponse = DescribeCdnCertificateDetailResponse;\nclass DescribeCdnCertificateListRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnCertificateListRequest = DescribeCdnCertificateListRequest;\nclass DescribeCdnCertificateListResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certificateListModel: 'CertificateListModel',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            certificateListModel: DescribeCdnCertificateListResponseBodyCertificateListModel,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnCertificateListResponseBody = DescribeCdnCertificateListResponseBody;\nclass DescribeCdnCertificateListResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnCertificateListResponseBody,\n        };\n    }\n}\nexports.DescribeCdnCertificateListResponse = DescribeCdnCertificateListResponse;\nclass DescribeCdnDeletedDomainsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n        };\n    }\n}\nexports.DescribeCdnDeletedDomainsRequest = DescribeCdnDeletedDomainsRequest;\nclass DescribeCdnDeletedDomainsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domains: 'Domains',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            domains: DescribeCdnDeletedDomainsResponseBodyDomains,\n            pageNumber: 'number',\n            pageSize: 'number',\n            requestId: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeCdnDeletedDomainsResponseBody = DescribeCdnDeletedDomainsResponseBody;\nclass DescribeCdnDeletedDomainsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDeletedDomainsResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDeletedDomainsResponse = DescribeCdnDeletedDomainsResponse;\nclass DescribeCdnDeliverListRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            deliverId: 'DeliverId',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            deliverId: 'number',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeCdnDeliverListRequest = DescribeCdnDeliverListRequest;\nclass DescribeCdnDeliverListResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnDeliverListResponseBody = DescribeCdnDeliverListResponseBody;\nclass DescribeCdnDeliverListResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDeliverListResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDeliverListResponse = DescribeCdnDeliverListResponse;\nclass DescribeCdnDomainByCertificateRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            SSLPub: 'SSLPub',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            SSLPub: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainByCertificateRequest = DescribeCdnDomainByCertificateRequest;\nclass DescribeCdnDomainByCertificateResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfos: 'CertInfos',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            certInfos: DescribeCdnDomainByCertificateResponseBodyCertInfos,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainByCertificateResponseBody = DescribeCdnDomainByCertificateResponseBody;\nclass DescribeCdnDomainByCertificateResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDomainByCertificateResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDomainByCertificateResponse = DescribeCdnDomainByCertificateResponse;\nclass DescribeCdnDomainConfigsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            domainName: 'DomainName',\n            functionNames: 'FunctionNames',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            domainName: 'string',\n            functionNames: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsRequest = DescribeCdnDomainConfigsRequest;\nclass DescribeCdnDomainConfigsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainConfigs: 'DomainConfigs',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            domainConfigs: DescribeCdnDomainConfigsResponseBodyDomainConfigs,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsResponseBody = DescribeCdnDomainConfigsResponseBody;\nclass DescribeCdnDomainConfigsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDomainConfigsResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsResponse = DescribeCdnDomainConfigsResponse;\nclass DescribeCdnDomainDetailRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainDetailRequest = DescribeCdnDomainDetailRequest;\nclass DescribeCdnDomainDetailResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            getDomainDetailModel: 'GetDomainDetailModel',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            getDomainDetailModel: DescribeCdnDomainDetailResponseBodyGetDomainDetailModel,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainDetailResponseBody = DescribeCdnDomainDetailResponseBody;\nclass DescribeCdnDomainDetailResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDomainDetailResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDomainDetailResponse = DescribeCdnDomainDetailResponse;\nclass DescribeCdnDomainLogsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainLogsRequest = DescribeCdnDomainLogsRequest;\nclass DescribeCdnDomainLogsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainLogDetails: 'DomainLogDetails',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            domainLogDetails: DescribeCdnDomainLogsResponseBodyDomainLogDetails,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponseBody = DescribeCdnDomainLogsResponseBody;\nclass DescribeCdnDomainLogsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDomainLogsResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponse = DescribeCdnDomainLogsResponse;\nclass DescribeCdnDomainStagingConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            functionNames: 'FunctionNames',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            functionNames: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeCdnDomainStagingConfigRequest = DescribeCdnDomainStagingConfigRequest;\nclass DescribeCdnDomainStagingConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainConfigs: 'DomainConfigs',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            domainConfigs: { 'type': 'array', 'itemType': DescribeCdnDomainStagingConfigResponseBodyDomainConfigs },\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainStagingConfigResponseBody = DescribeCdnDomainStagingConfigResponseBody;\nclass DescribeCdnDomainStagingConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnDomainStagingConfigResponseBody,\n        };\n    }\n}\nexports.DescribeCdnDomainStagingConfigResponse = DescribeCdnDomainStagingConfigResponse;\nclass DescribeCdnHttpsDomainListRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            keyword: 'Keyword',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            keyword: 'string',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n        };\n    }\n}\nexports.DescribeCdnHttpsDomainListRequest = DescribeCdnHttpsDomainListRequest;\nclass DescribeCdnHttpsDomainListResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfos: 'CertInfos',\n            requestId: 'RequestId',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            certInfos: DescribeCdnHttpsDomainListResponseBodyCertInfos,\n            requestId: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeCdnHttpsDomainListResponseBody = DescribeCdnHttpsDomainListResponseBody;\nclass DescribeCdnHttpsDomainListResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnHttpsDomainListResponseBody,\n        };\n    }\n}\nexports.DescribeCdnHttpsDomainListResponse = DescribeCdnHttpsDomainListResponse;\nclass DescribeCdnOrderCommodityCodeRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            commodityCode: 'CommodityCode',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            commodityCode: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnOrderCommodityCodeRequest = DescribeCdnOrderCommodityCodeRequest;\nclass DescribeCdnOrderCommodityCodeResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            orderCommodityCode: 'OrderCommodityCode',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            orderCommodityCode: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnOrderCommodityCodeResponseBody = DescribeCdnOrderCommodityCodeResponseBody;\nclass DescribeCdnOrderCommodityCodeResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnOrderCommodityCodeResponseBody,\n        };\n    }\n}\nexports.DescribeCdnOrderCommodityCodeResponse = DescribeCdnOrderCommodityCodeResponse;\nclass DescribeCdnRegionAndIspRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspRequest = DescribeCdnRegionAndIspRequest;\nclass DescribeCdnRegionAndIspResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            isps: 'Isps',\n            regions: 'Regions',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            isps: DescribeCdnRegionAndIspResponseBodyIsps,\n            regions: DescribeCdnRegionAndIspResponseBodyRegions,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspResponseBody = DescribeCdnRegionAndIspResponseBody;\nclass DescribeCdnRegionAndIspResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnRegionAndIspResponseBody,\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspResponse = DescribeCdnRegionAndIspResponse;\nclass DescribeCdnReportRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            httpCode: 'HttpCode',\n            isOverseas: 'IsOverseas',\n            ownerId: 'OwnerId',\n            reportId: 'ReportId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            httpCode: 'string',\n            isOverseas: 'string',\n            ownerId: 'number',\n            reportId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnReportRequest = DescribeCdnReportRequest;\nclass DescribeCdnReportResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnReportResponseBody = DescribeCdnReportResponseBody;\nclass DescribeCdnReportResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnReportResponseBody,\n        };\n    }\n}\nexports.DescribeCdnReportResponse = DescribeCdnReportResponse;\nclass DescribeCdnReportListRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            reportId: 'ReportId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            reportId: 'number',\n        };\n    }\n}\nexports.DescribeCdnReportListRequest = DescribeCdnReportListRequest;\nclass DescribeCdnReportListResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnReportListResponseBody = DescribeCdnReportListResponseBody;\nclass DescribeCdnReportListResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnReportListResponseBody,\n        };\n    }\n}\nexports.DescribeCdnReportListResponse = DescribeCdnReportListResponse;\nclass DescribeCdnSMCertificateDetailRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certIdentifier: 'CertIdentifier',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            certIdentifier: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnSMCertificateDetailRequest = DescribeCdnSMCertificateDetailRequest;\nclass DescribeCdnSMCertificateDetailResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certExpireTime: 'CertExpireTime',\n            certIdentifier: 'CertIdentifier',\n            certName: 'CertName',\n            certOrg: 'CertOrg',\n            commonName: 'CommonName',\n            encryptCertificate: 'EncryptCertificate',\n            requestId: 'RequestId',\n            sans: 'Sans',\n            signCertificate: 'SignCertificate',\n        };\n    }\n    static types() {\n        return {\n            certExpireTime: 'string',\n            certIdentifier: 'string',\n            certName: 'string',\n            certOrg: 'string',\n            commonName: 'string',\n            encryptCertificate: 'string',\n            requestId: 'string',\n            sans: 'string',\n            signCertificate: 'string',\n        };\n    }\n}\nexports.DescribeCdnSMCertificateDetailResponseBody = DescribeCdnSMCertificateDetailResponseBody;\nclass DescribeCdnSMCertificateDetailResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnSMCertificateDetailResponseBody,\n        };\n    }\n}\nexports.DescribeCdnSMCertificateDetailResponse = DescribeCdnSMCertificateDetailResponse;\nclass DescribeCdnSMCertificateListRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnSMCertificateListRequest = DescribeCdnSMCertificateListRequest;\nclass DescribeCdnSMCertificateListResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certificateListModel: 'CertificateListModel',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            certificateListModel: DescribeCdnSMCertificateListResponseBodyCertificateListModel,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnSMCertificateListResponseBody = DescribeCdnSMCertificateListResponseBody;\nclass DescribeCdnSMCertificateListResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnSMCertificateListResponseBody,\n        };\n    }\n}\nexports.DescribeCdnSMCertificateListResponse = DescribeCdnSMCertificateListResponse;\nclass DescribeCdnServiceRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnServiceRequest = DescribeCdnServiceRequest;\nclass DescribeCdnServiceResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            changingAffectTime: 'ChangingAffectTime',\n            changingChargeType: 'ChangingChargeType',\n            instanceId: 'InstanceId',\n            internetChargeType: 'InternetChargeType',\n            openingTime: 'OpeningTime',\n            operationLocks: 'OperationLocks',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            changingAffectTime: 'string',\n            changingChargeType: 'string',\n            instanceId: 'string',\n            internetChargeType: 'string',\n            openingTime: 'string',\n            operationLocks: DescribeCdnServiceResponseBodyOperationLocks,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnServiceResponseBody = DescribeCdnServiceResponseBody;\nclass DescribeCdnServiceResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnServiceResponseBody,\n        };\n    }\n}\nexports.DescribeCdnServiceResponse = DescribeCdnServiceResponse;\nclass DescribeCdnSubListRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeCdnSubListRequest = DescribeCdnSubListRequest;\nclass DescribeCdnSubListResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnSubListResponseBody = DescribeCdnSubListResponseBody;\nclass DescribeCdnSubListResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnSubListResponseBody,\n        };\n    }\n}\nexports.DescribeCdnSubListResponse = DescribeCdnSubListResponse;\nclass DescribeCdnUserBillHistoryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryRequest = DescribeCdnUserBillHistoryRequest;\nclass DescribeCdnUserBillHistoryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billHistoryData: 'BillHistoryData',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            billHistoryData: DescribeCdnUserBillHistoryResponseBodyBillHistoryData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryResponseBody = DescribeCdnUserBillHistoryResponseBody;\nclass DescribeCdnUserBillHistoryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserBillHistoryResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryResponse = DescribeCdnUserBillHistoryResponse;\nclass DescribeCdnUserBillPredictionRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            dimension: 'Dimension',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            dimension: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillPredictionRequest = DescribeCdnUserBillPredictionRequest;\nclass DescribeCdnUserBillPredictionResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billPredictionData: 'BillPredictionData',\n            billType: 'BillType',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            billPredictionData: DescribeCdnUserBillPredictionResponseBodyBillPredictionData,\n            billType: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillPredictionResponseBody = DescribeCdnUserBillPredictionResponseBody;\nclass DescribeCdnUserBillPredictionResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserBillPredictionResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserBillPredictionResponse = DescribeCdnUserBillPredictionResponse;\nclass DescribeCdnUserBillTypeRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillTypeRequest = DescribeCdnUserBillTypeRequest;\nclass DescribeCdnUserBillTypeResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billTypeData: 'BillTypeData',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            billTypeData: DescribeCdnUserBillTypeResponseBodyBillTypeData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillTypeResponseBody = DescribeCdnUserBillTypeResponseBody;\nclass DescribeCdnUserBillTypeResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserBillTypeResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserBillTypeResponse = DescribeCdnUserBillTypeResponse;\nclass DescribeCdnUserConfigsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            functionName: 'FunctionName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            functionName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeCdnUserConfigsRequest = DescribeCdnUserConfigsRequest;\nclass DescribeCdnUserConfigsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configs: 'Configs',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            configs: { 'type': 'array', 'itemType': DescribeCdnUserConfigsResponseBodyConfigs },\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserConfigsResponseBody = DescribeCdnUserConfigsResponseBody;\nclass DescribeCdnUserConfigsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserConfigsResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserConfigsResponse = DescribeCdnUserConfigsResponse;\nclass DescribeCdnUserDomainsByFuncRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            funcId: 'FuncId',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            resourceGroupId: 'ResourceGroupId',\n        };\n    }\n    static types() {\n        return {\n            funcId: 'number',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n            resourceGroupId: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncRequest = DescribeCdnUserDomainsByFuncRequest;\nclass DescribeCdnUserDomainsByFuncResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domains: 'Domains',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            domains: DescribeCdnUserDomainsByFuncResponseBodyDomains,\n            pageNumber: 'number',\n            pageSize: 'number',\n            requestId: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncResponseBody = DescribeCdnUserDomainsByFuncResponseBody;\nclass DescribeCdnUserDomainsByFuncResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserDomainsByFuncResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncResponse = DescribeCdnUserDomainsByFuncResponse;\nclass DescribeCdnUserQuotaRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserQuotaRequest = DescribeCdnUserQuotaRequest;\nclass DescribeCdnUserQuotaResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            blockQuota: 'BlockQuota',\n            blockRemain: 'BlockRemain',\n            domainQuota: 'DomainQuota',\n            preloadQuota: 'PreloadQuota',\n            preloadRemain: 'PreloadRemain',\n            refreshDirQuota: 'RefreshDirQuota',\n            refreshDirRemain: 'RefreshDirRemain',\n            refreshUrlQuota: 'RefreshUrlQuota',\n            refreshUrlRemain: 'RefreshUrlRemain',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            blockQuota: 'number',\n            blockRemain: 'number',\n            domainQuota: 'number',\n            preloadQuota: 'number',\n            preloadRemain: 'number',\n            refreshDirQuota: 'number',\n            refreshDirRemain: 'number',\n            refreshUrlQuota: 'number',\n            refreshUrlRemain: 'number',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserQuotaResponseBody = DescribeCdnUserQuotaResponseBody;\nclass DescribeCdnUserQuotaResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserQuotaResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserQuotaResponse = DescribeCdnUserQuotaResponse;\nclass DescribeCdnUserResourcePackageRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            securityToken: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserResourcePackageRequest = DescribeCdnUserResourcePackageRequest;\nclass DescribeCdnUserResourcePackageResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            resourcePackageInfos: 'ResourcePackageInfos',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            resourcePackageInfos: DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos,\n        };\n    }\n}\nexports.DescribeCdnUserResourcePackageResponseBody = DescribeCdnUserResourcePackageResponseBody;\nclass DescribeCdnUserResourcePackageResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnUserResourcePackageResponseBody,\n        };\n    }\n}\nexports.DescribeCdnUserResourcePackageResponse = DescribeCdnUserResourcePackageResponse;\nclass DescribeCdnWafDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            regionId: 'RegionId',\n            resourceGroupId: 'ResourceGroupId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            regionId: 'string',\n            resourceGroupId: 'string',\n        };\n    }\n}\nexports.DescribeCdnWafDomainRequest = DescribeCdnWafDomainRequest;\nclass DescribeCdnWafDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            outPutDomains: 'OutPutDomains',\n            requestId: 'RequestId',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            outPutDomains: { 'type': 'array', 'itemType': DescribeCdnWafDomainResponseBodyOutPutDomains },\n            requestId: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeCdnWafDomainResponseBody = DescribeCdnWafDomainResponseBody;\nclass DescribeCdnWafDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCdnWafDomainResponseBody,\n        };\n    }\n}\nexports.DescribeCdnWafDomainResponse = DescribeCdnWafDomainResponse;\nclass DescribeCertificateInfoByIDRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certId: 'CertId',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            certId: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeCertificateInfoByIDRequest = DescribeCertificateInfoByIDRequest;\nclass DescribeCertificateInfoByIDResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfos: 'CertInfos',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            certInfos: DescribeCertificateInfoByIDResponseBodyCertInfos,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeCertificateInfoByIDResponseBody = DescribeCertificateInfoByIDResponseBody;\nclass DescribeCertificateInfoByIDResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCertificateInfoByIDResponseBody,\n        };\n    }\n}\nexports.DescribeCertificateInfoByIDResponse = DescribeCertificateInfoByIDResponse;\nclass DescribeConfigGroupDetailRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configGroupId: 'ConfigGroupId',\n            configGroupName: 'ConfigGroupName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            configGroupId: 'string',\n            configGroupName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeConfigGroupDetailRequest = DescribeConfigGroupDetailRequest;\nclass DescribeConfigGroupDetailResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bizName: 'BizName',\n            configGroupId: 'ConfigGroupId',\n            configGroupName: 'ConfigGroupName',\n            createTime: 'CreateTime',\n            description: 'Description',\n            requestId: 'RequestId',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            bizName: 'string',\n            configGroupId: 'string',\n            configGroupName: 'string',\n            createTime: 'string',\n            description: 'string',\n            requestId: 'string',\n            updateTime: 'string',\n        };\n    }\n}\nexports.DescribeConfigGroupDetailResponseBody = DescribeConfigGroupDetailResponseBody;\nclass DescribeConfigGroupDetailResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeConfigGroupDetailResponseBody,\n        };\n    }\n}\nexports.DescribeConfigGroupDetailResponse = DescribeConfigGroupDetailResponse;\nclass DescribeConfigOfVersionRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            functionId: 'FunctionId',\n            functionName: 'FunctionName',\n            groupId: 'GroupId',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            functionId: 'number',\n            functionName: 'string',\n            groupId: 'number',\n            ownerId: 'number',\n            securityToken: 'string',\n            versionId: 'string',\n        };\n    }\n}\nexports.DescribeConfigOfVersionRequest = DescribeConfigOfVersionRequest;\nclass DescribeConfigOfVersionResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            versionConfigs: 'VersionConfigs',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            versionConfigs: DescribeConfigOfVersionResponseBodyVersionConfigs,\n        };\n    }\n}\nexports.DescribeConfigOfVersionResponseBody = DescribeConfigOfVersionResponseBody;\nclass DescribeConfigOfVersionResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeConfigOfVersionResponseBody,\n        };\n    }\n}\nexports.DescribeConfigOfVersionResponse = DescribeConfigOfVersionResponse;\nclass DescribeCustomLogConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeCustomLogConfigRequest = DescribeCustomLogConfigRequest;\nclass DescribeCustomLogConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            remark: 'Remark',\n            requestId: 'RequestId',\n            sample: 'Sample',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            remark: 'string',\n            requestId: 'string',\n            sample: 'string',\n            tag: 'string',\n        };\n    }\n}\nexports.DescribeCustomLogConfigResponseBody = DescribeCustomLogConfigResponseBody;\nclass DescribeCustomLogConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeCustomLogConfigResponseBody,\n        };\n    }\n}\nexports.DescribeCustomLogConfigResponse = DescribeCustomLogConfigResponse;\nclass DescribeDomainAverageResponseTimeRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            domainType: 'DomainType',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n            timeMerge: 'TimeMerge',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            domainType: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n            timeMerge: 'string',\n        };\n    }\n}\nexports.DescribeDomainAverageResponseTimeRequest = DescribeDomainAverageResponseTimeRequest;\nclass DescribeDomainAverageResponseTimeResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            avgRTPerInterval: 'AvgRTPerInterval',\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            avgRTPerInterval: DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval,\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainAverageResponseTimeResponseBody = DescribeDomainAverageResponseTimeResponseBody;\nclass DescribeDomainAverageResponseTimeResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainAverageResponseTimeResponseBody,\n        };\n    }\n}\nexports.DescribeDomainAverageResponseTimeResponse = DescribeDomainAverageResponseTimeResponse;\nclass DescribeDomainBpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataRequest = DescribeDomainBpsDataRequest;\nclass DescribeDomainBpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bpsDataPerInterval: 'BpsDataPerInterval',\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            bpsDataPerInterval: DescribeDomainBpsDataResponseBodyBpsDataPerInterval,\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataResponseBody = DescribeDomainBpsDataResponseBody;\nclass DescribeDomainBpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainBpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainBpsDataResponse = DescribeDomainBpsDataResponse;\nclass DescribeDomainBpsDataByLayerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            layer: 'Layer',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            layer: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataByLayerRequest = DescribeDomainBpsDataByLayerRequest;\nclass DescribeDomainBpsDataByLayerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bpsDataInterval: 'BpsDataInterval',\n            dataInterval: 'DataInterval',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            bpsDataInterval: DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval,\n            dataInterval: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataByLayerResponseBody = DescribeDomainBpsDataByLayerResponseBody;\nclass DescribeDomainBpsDataByLayerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainBpsDataByLayerResponseBody,\n        };\n    }\n}\nexports.DescribeDomainBpsDataByLayerResponse = DescribeDomainBpsDataByLayerResponse;\nclass DescribeDomainBpsDataByTimeStampRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ispNames: 'IspNames',\n            locationNames: 'LocationNames',\n            ownerId: 'OwnerId',\n            timePoint: 'TimePoint',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ispNames: 'string',\n            locationNames: 'string',\n            ownerId: 'number',\n            timePoint: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataByTimeStampRequest = DescribeDomainBpsDataByTimeStampRequest;\nclass DescribeDomainBpsDataByTimeStampResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bpsDataList: 'BpsDataList',\n            domainName: 'DomainName',\n            requestId: 'RequestId',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            bpsDataList: DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList,\n            domainName: 'string',\n            requestId: 'string',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataByTimeStampResponseBody = DescribeDomainBpsDataByTimeStampResponseBody;\nclass DescribeDomainBpsDataByTimeStampResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainBpsDataByTimeStampResponseBody,\n        };\n    }\n}\nexports.DescribeDomainBpsDataByTimeStampResponse = DescribeDomainBpsDataByTimeStampResponse;\nclass DescribeDomainCcActivityLogRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            ruleName: 'RuleName',\n            startTime: 'StartTime',\n            triggerObject: 'TriggerObject',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n            ruleName: 'string',\n            startTime: 'string',\n            triggerObject: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainCcActivityLogRequest = DescribeDomainCcActivityLogRequest;\nclass DescribeDomainCcActivityLogResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            activityLog: 'ActivityLog',\n            pageIndex: 'PageIndex',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            total: 'Total',\n        };\n    }\n    static types() {\n        return {\n            activityLog: { 'type': 'array', 'itemType': DescribeDomainCcActivityLogResponseBodyActivityLog },\n            pageIndex: 'number',\n            pageSize: 'number',\n            requestId: 'string',\n            total: 'number',\n        };\n    }\n}\nexports.DescribeDomainCcActivityLogResponseBody = DescribeDomainCcActivityLogResponseBody;\nclass DescribeDomainCcActivityLogResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainCcActivityLogResponseBody,\n        };\n    }\n}\nexports.DescribeDomainCcActivityLogResponse = DescribeDomainCcActivityLogResponse;\nclass DescribeDomainCertificateInfoRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeDomainCertificateInfoRequest = DescribeDomainCertificateInfoRequest;\nclass DescribeDomainCertificateInfoResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfos: 'CertInfos',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            certInfos: DescribeDomainCertificateInfoResponseBodyCertInfos,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainCertificateInfoResponseBody = DescribeDomainCertificateInfoResponseBody;\nclass DescribeDomainCertificateInfoResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainCertificateInfoResponseBody,\n        };\n    }\n}\nexports.DescribeDomainCertificateInfoResponse = DescribeDomainCertificateInfoResponse;\nclass DescribeDomainCustomLogConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeDomainCustomLogConfigRequest = DescribeDomainCustomLogConfigRequest;\nclass DescribeDomainCustomLogConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            remark: 'Remark',\n            requestId: 'RequestId',\n            sample: 'Sample',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            remark: 'string',\n            requestId: 'string',\n            sample: 'string',\n            tag: 'string',\n        };\n    }\n}\nexports.DescribeDomainCustomLogConfigResponseBody = DescribeDomainCustomLogConfigResponseBody;\nclass DescribeDomainCustomLogConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainCustomLogConfigResponseBody,\n        };\n    }\n}\nexports.DescribeDomainCustomLogConfigResponse = DescribeDomainCustomLogConfigResponse;\nclass DescribeDomainDetailDataByLayerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            field: 'Field',\n            ispNameEn: 'IspNameEn',\n            layer: 'Layer',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            field: 'string',\n            ispNameEn: 'string',\n            layer: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainDetailDataByLayerRequest = DescribeDomainDetailDataByLayerRequest;\nclass DescribeDomainDetailDataByLayerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeDomainDetailDataByLayerResponseBodyData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainDetailDataByLayerResponseBody = DescribeDomainDetailDataByLayerResponseBody;\nclass DescribeDomainDetailDataByLayerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainDetailDataByLayerResponseBody,\n        };\n    }\n}\nexports.DescribeDomainDetailDataByLayerResponse = DescribeDomainDetailDataByLayerResponse;\nclass DescribeDomainFileSizeProportionDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataRequest = DescribeDomainFileSizeProportionDataRequest;\nclass DescribeDomainFileSizeProportionDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            fileSizeProportionDataInterval: 'FileSizeProportionDataInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            fileSizeProportionDataInterval: DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataResponseBody = DescribeDomainFileSizeProportionDataResponseBody;\nclass DescribeDomainFileSizeProportionDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainFileSizeProportionDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataResponse = DescribeDomainFileSizeProportionDataResponse;\nclass DescribeDomainHitRateDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainHitRateDataRequest = DescribeDomainHitRateDataRequest;\nclass DescribeDomainHitRateDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            hitRateInterval: 'HitRateInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            hitRateInterval: DescribeDomainHitRateDataResponseBodyHitRateInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainHitRateDataResponseBody = DescribeDomainHitRateDataResponseBody;\nclass DescribeDomainHitRateDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainHitRateDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainHitRateDataResponse = DescribeDomainHitRateDataResponse;\nclass DescribeDomainHttpCodeDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataRequest = DescribeDomainHttpCodeDataRequest;\nclass DescribeDomainHttpCodeDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            httpCodeData: 'HttpCodeData',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            httpCodeData: DescribeDomainHttpCodeDataResponseBodyHttpCodeData,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataResponseBody = DescribeDomainHttpCodeDataResponseBody;\nclass DescribeDomainHttpCodeDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainHttpCodeDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataResponse = DescribeDomainHttpCodeDataResponse;\nclass DescribeDomainHttpCodeDataByLayerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            layer: 'Layer',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            layer: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataByLayerRequest = DescribeDomainHttpCodeDataByLayerRequest;\nclass DescribeDomainHttpCodeDataByLayerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            httpCodeDataInterval: 'HttpCodeDataInterval',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            httpCodeDataInterval: DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataByLayerResponseBody = DescribeDomainHttpCodeDataByLayerResponseBody;\nclass DescribeDomainHttpCodeDataByLayerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainHttpCodeDataByLayerResponseBody,\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataByLayerResponse = DescribeDomainHttpCodeDataByLayerResponse;\nclass DescribeDomainISPDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainISPDataRequest = DescribeDomainISPDataRequest;\nclass DescribeDomainISPDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            value: DescribeDomainISPDataResponseBodyValue,\n        };\n    }\n}\nexports.DescribeDomainISPDataResponseBody = DescribeDomainISPDataResponseBody;\nclass DescribeDomainISPDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainISPDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainISPDataResponse = DescribeDomainISPDataResponse;\nclass DescribeDomainMax95BpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cycle: 'Cycle',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n            timePoint: 'TimePoint',\n        };\n    }\n    static types() {\n        return {\n            cycle: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n            timePoint: 'string',\n        };\n    }\n}\nexports.DescribeDomainMax95BpsDataRequest = DescribeDomainMax95BpsDataRequest;\nclass DescribeDomainMax95BpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            domesticMax95Bps: 'DomesticMax95Bps',\n            endTime: 'EndTime',\n            max95Bps: 'Max95Bps',\n            overseasMax95Bps: 'OverseasMax95Bps',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            domesticMax95Bps: 'string',\n            endTime: 'string',\n            max95Bps: 'string',\n            overseasMax95Bps: 'string',\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainMax95BpsDataResponseBody = DescribeDomainMax95BpsDataResponseBody;\nclass DescribeDomainMax95BpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainMax95BpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainMax95BpsDataResponse = DescribeDomainMax95BpsDataResponse;\nclass DescribeDomainMultiUsageDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataRequest = DescribeDomainMultiUsageDataRequest;\nclass DescribeDomainMultiUsageDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            requestPerInterval: 'RequestPerInterval',\n            startTime: 'StartTime',\n            trafficPerInterval: 'TrafficPerInterval',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            requestId: 'string',\n            requestPerInterval: DescribeDomainMultiUsageDataResponseBodyRequestPerInterval,\n            startTime: 'string',\n            trafficPerInterval: DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval,\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataResponseBody = DescribeDomainMultiUsageDataResponseBody;\nclass DescribeDomainMultiUsageDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainMultiUsageDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataResponse = DescribeDomainMultiUsageDataResponse;\nclass DescribeDomainNamesOfVersionRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            pageIndex: 'PageIndex',\n            pageSize: 'PageSize',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            pageIndex: 'number',\n            pageSize: 'string',\n            versionId: 'string',\n        };\n    }\n}\nexports.DescribeDomainNamesOfVersionRequest = DescribeDomainNamesOfVersionRequest;\nclass DescribeDomainNamesOfVersionResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            contents: 'Contents',\n            requestId: 'RequestId',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            contents: { 'type': 'array', 'itemType': DescribeDomainNamesOfVersionResponseBodyContents },\n            requestId: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeDomainNamesOfVersionResponseBody = DescribeDomainNamesOfVersionResponseBody;\nclass DescribeDomainNamesOfVersionResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainNamesOfVersionResponseBody,\n        };\n    }\n}\nexports.DescribeDomainNamesOfVersionResponse = DescribeDomainNamesOfVersionResponse;\nclass DescribeDomainPathDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            path: 'Path',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n            path: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainPathDataRequest = DescribeDomainPathDataRequest;\nclass DescribeDomainPathDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            pathDataPerInterval: 'PathDataPerInterval',\n            startTime: 'StartTime',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            pageNumber: 'number',\n            pageSize: 'number',\n            pathDataPerInterval: DescribeDomainPathDataResponseBodyPathDataPerInterval,\n            startTime: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeDomainPathDataResponseBody = DescribeDomainPathDataResponseBody;\nclass DescribeDomainPathDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainPathDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainPathDataResponse = DescribeDomainPathDataResponse;\nclass DescribeDomainPvDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainPvDataRequest = DescribeDomainPvDataRequest;\nclass DescribeDomainPvDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            pvDataInterval: 'PvDataInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            pvDataInterval: DescribeDomainPvDataResponseBodyPvDataInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainPvDataResponseBody = DescribeDomainPvDataResponseBody;\nclass DescribeDomainPvDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainPvDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainPvDataResponse = DescribeDomainPvDataResponse;\nclass DescribeDomainQpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainQpsDataRequest = DescribeDomainQpsDataRequest;\nclass DescribeDomainQpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            qpsDataInterval: 'QpsDataInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            qpsDataInterval: DescribeDomainQpsDataResponseBodyQpsDataInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainQpsDataResponseBody = DescribeDomainQpsDataResponseBody;\nclass DescribeDomainQpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainQpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainQpsDataResponse = DescribeDomainQpsDataResponse;\nclass DescribeDomainQpsDataByLayerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            layer: 'Layer',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            layer: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainQpsDataByLayerRequest = DescribeDomainQpsDataByLayerRequest;\nclass DescribeDomainQpsDataByLayerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            layer: 'Layer',\n            qpsDataInterval: 'QpsDataInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            layer: 'string',\n            qpsDataInterval: DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainQpsDataByLayerResponseBody = DescribeDomainQpsDataByLayerResponseBody;\nclass DescribeDomainQpsDataByLayerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainQpsDataByLayerResponseBody,\n        };\n    }\n}\nexports.DescribeDomainQpsDataByLayerResponse = DescribeDomainQpsDataByLayerResponse;\nclass DescribeDomainRealTimeBpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeBpsDataRequest = DescribeDomainRealTimeBpsDataRequest;\nclass DescribeDomainRealTimeBpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeDomainRealTimeBpsDataResponseBodyData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeBpsDataResponseBody = DescribeDomainRealTimeBpsDataResponseBody;\nclass DescribeDomainRealTimeBpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeBpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeBpsDataResponse = DescribeDomainRealTimeBpsDataResponse;\nclass DescribeDomainRealTimeByteHitRateDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeByteHitRateDataRequest = DescribeDomainRealTimeByteHitRateDataRequest;\nclass DescribeDomainRealTimeByteHitRateDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeDomainRealTimeByteHitRateDataResponseBodyData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeByteHitRateDataResponseBody = DescribeDomainRealTimeByteHitRateDataResponseBody;\nclass DescribeDomainRealTimeByteHitRateDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeByteHitRateDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeByteHitRateDataResponse = DescribeDomainRealTimeByteHitRateDataResponse;\nclass DescribeDomainRealTimeDetailDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            field: 'Field',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            merge: 'Merge',\n            mergeLocIsp: 'MergeLocIsp',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            field: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            merge: 'string',\n            mergeLocIsp: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeDetailDataRequest = DescribeDomainRealTimeDetailDataRequest;\nclass DescribeDomainRealTimeDetailDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            data: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeDetailDataResponseBody = DescribeDomainRealTimeDetailDataResponseBody;\nclass DescribeDomainRealTimeDetailDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeDetailDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeDetailDataResponse = DescribeDomainRealTimeDetailDataResponse;\nclass DescribeDomainRealTimeHttpCodeDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataRequest = DescribeDomainRealTimeHttpCodeDataRequest;\nclass DescribeDomainRealTimeHttpCodeDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            realTimeHttpCodeData: 'RealTimeHttpCodeData',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            realTimeHttpCodeData: DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataResponseBody = DescribeDomainRealTimeHttpCodeDataResponseBody;\nclass DescribeDomainRealTimeHttpCodeDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeHttpCodeDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataResponse = DescribeDomainRealTimeHttpCodeDataResponse;\nclass DescribeDomainRealTimeQpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeQpsDataRequest = DescribeDomainRealTimeQpsDataRequest;\nclass DescribeDomainRealTimeQpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeDomainRealTimeQpsDataResponseBodyData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeQpsDataResponseBody = DescribeDomainRealTimeQpsDataResponseBody;\nclass DescribeDomainRealTimeQpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeQpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeQpsDataResponse = DescribeDomainRealTimeQpsDataResponse;\nclass DescribeDomainRealTimeReqHitRateDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeReqHitRateDataRequest = DescribeDomainRealTimeReqHitRateDataRequest;\nclass DescribeDomainRealTimeReqHitRateDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeDomainRealTimeReqHitRateDataResponseBodyData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeReqHitRateDataResponseBody = DescribeDomainRealTimeReqHitRateDataResponseBody;\nclass DescribeDomainRealTimeReqHitRateDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeReqHitRateDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeReqHitRateDataResponse = DescribeDomainRealTimeReqHitRateDataResponse;\nclass DescribeDomainRealTimeSrcBpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcBpsDataRequest = DescribeDomainRealTimeSrcBpsDataRequest;\nclass DescribeDomainRealTimeSrcBpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            realTimeSrcBpsDataPerInterval: 'RealTimeSrcBpsDataPerInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            realTimeSrcBpsDataPerInterval: DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcBpsDataResponseBody = DescribeDomainRealTimeSrcBpsDataResponseBody;\nclass DescribeDomainRealTimeSrcBpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeSrcBpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcBpsDataResponse = DescribeDomainRealTimeSrcBpsDataResponse;\nclass DescribeDomainRealTimeSrcHttpCodeDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataRequest = DescribeDomainRealTimeSrcHttpCodeDataRequest;\nclass DescribeDomainRealTimeSrcHttpCodeDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            realTimeSrcHttpCodeData: 'RealTimeSrcHttpCodeData',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            realTimeSrcHttpCodeData: DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataResponseBody = DescribeDomainRealTimeSrcHttpCodeDataResponseBody;\nclass DescribeDomainRealTimeSrcHttpCodeDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeSrcHttpCodeDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataResponse = DescribeDomainRealTimeSrcHttpCodeDataResponse;\nclass DescribeDomainRealTimeSrcTrafficDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcTrafficDataRequest = DescribeDomainRealTimeSrcTrafficDataRequest;\nclass DescribeDomainRealTimeSrcTrafficDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            realTimeSrcTrafficDataPerInterval: 'RealTimeSrcTrafficDataPerInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            realTimeSrcTrafficDataPerInterval: DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcTrafficDataResponseBody = DescribeDomainRealTimeSrcTrafficDataResponseBody;\nclass DescribeDomainRealTimeSrcTrafficDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeSrcTrafficDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcTrafficDataResponse = DescribeDomainRealTimeSrcTrafficDataResponse;\nclass DescribeDomainRealTimeTrafficDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeTrafficDataRequest = DescribeDomainRealTimeTrafficDataRequest;\nclass DescribeDomainRealTimeTrafficDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            realTimeTrafficDataPerInterval: 'RealTimeTrafficDataPerInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            realTimeTrafficDataPerInterval: DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeTrafficDataResponseBody = DescribeDomainRealTimeTrafficDataResponseBody;\nclass DescribeDomainRealTimeTrafficDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealTimeTrafficDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealTimeTrafficDataResponse = DescribeDomainRealTimeTrafficDataResponse;\nclass DescribeDomainRealtimeLogDeliveryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeDomainRealtimeLogDeliveryRequest = DescribeDomainRealtimeLogDeliveryRequest;\nclass DescribeDomainRealtimeLogDeliveryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            logstore: 'Logstore',\n            project: 'Project',\n            region: 'Region',\n            requestId: 'RequestId',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            logstore: 'string',\n            project: 'string',\n            region: 'string',\n            requestId: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealtimeLogDeliveryResponseBody = DescribeDomainRealtimeLogDeliveryResponseBody;\nclass DescribeDomainRealtimeLogDeliveryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRealtimeLogDeliveryResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRealtimeLogDeliveryResponse = DescribeDomainRealtimeLogDeliveryResponse;\nclass DescribeDomainRegionDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainRegionDataRequest = DescribeDomainRegionDataRequest;\nclass DescribeDomainRegionDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            value: DescribeDomainRegionDataResponseBodyValue,\n        };\n    }\n}\nexports.DescribeDomainRegionDataResponseBody = DescribeDomainRegionDataResponseBody;\nclass DescribeDomainRegionDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainRegionDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainRegionDataResponse = DescribeDomainRegionDataResponse;\nclass DescribeDomainReqHitRateDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainReqHitRateDataRequest = DescribeDomainReqHitRateDataRequest;\nclass DescribeDomainReqHitRateDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            reqHitRateInterval: 'ReqHitRateInterval',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            reqHitRateInterval: DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainReqHitRateDataResponseBody = DescribeDomainReqHitRateDataResponseBody;\nclass DescribeDomainReqHitRateDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainReqHitRateDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainReqHitRateDataResponse = DescribeDomainReqHitRateDataResponse;\nclass DescribeDomainSrcBpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcBpsDataRequest = DescribeDomainSrcBpsDataRequest;\nclass DescribeDomainSrcBpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            srcBpsDataPerInterval: 'SrcBpsDataPerInterval',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            srcBpsDataPerInterval: DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval,\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcBpsDataResponseBody = DescribeDomainSrcBpsDataResponseBody;\nclass DescribeDomainSrcBpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainSrcBpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainSrcBpsDataResponse = DescribeDomainSrcBpsDataResponse;\nclass DescribeDomainSrcHttpCodeDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataRequest = DescribeDomainSrcHttpCodeDataRequest;\nclass DescribeDomainSrcHttpCodeDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            httpCodeData: 'HttpCodeData',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            httpCodeData: DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData,\n            requestId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataResponseBody = DescribeDomainSrcHttpCodeDataResponseBody;\nclass DescribeDomainSrcHttpCodeDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainSrcHttpCodeDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataResponse = DescribeDomainSrcHttpCodeDataResponse;\nclass DescribeDomainSrcQpsDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcQpsDataRequest = DescribeDomainSrcQpsDataRequest;\nclass DescribeDomainSrcQpsDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            srcQpsDataPerInterval: 'SrcQpsDataPerInterval',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            srcQpsDataPerInterval: DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval,\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcQpsDataResponseBody = DescribeDomainSrcQpsDataResponseBody;\nclass DescribeDomainSrcQpsDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainSrcQpsDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainSrcQpsDataResponse = DescribeDomainSrcQpsDataResponse;\nclass DescribeDomainSrcTopUrlVisitRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            sortBy: 'SortBy',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            sortBy: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitRequest = DescribeDomainSrcTopUrlVisitRequest;\nclass DescribeDomainSrcTopUrlVisitResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            allUrlList: 'AllUrlList',\n            domainName: 'DomainName',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            url200List: 'Url200List',\n            url300List: 'Url300List',\n            url400List: 'Url400List',\n            url500List: 'Url500List',\n        };\n    }\n    static types() {\n        return {\n            allUrlList: DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList,\n            domainName: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            url200List: DescribeDomainSrcTopUrlVisitResponseBodyUrl200List,\n            url300List: DescribeDomainSrcTopUrlVisitResponseBodyUrl300List,\n            url400List: DescribeDomainSrcTopUrlVisitResponseBodyUrl400List,\n            url500List: DescribeDomainSrcTopUrlVisitResponseBodyUrl500List,\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBody = DescribeDomainSrcTopUrlVisitResponseBody;\nclass DescribeDomainSrcTopUrlVisitResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainSrcTopUrlVisitResponseBody,\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponse = DescribeDomainSrcTopUrlVisitResponse;\nclass DescribeDomainSrcTrafficDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcTrafficDataRequest = DescribeDomainSrcTrafficDataRequest;\nclass DescribeDomainSrcTrafficDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            srcTrafficDataPerInterval: 'SrcTrafficDataPerInterval',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            srcTrafficDataPerInterval: DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval,\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcTrafficDataResponseBody = DescribeDomainSrcTrafficDataResponseBody;\nclass DescribeDomainSrcTrafficDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainSrcTrafficDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainSrcTrafficDataResponse = DescribeDomainSrcTrafficDataResponse;\nclass DescribeDomainTopClientIpVisitRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            limit: 'Limit',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            sortBy: 'SortBy',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            limit: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            sortBy: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainTopClientIpVisitRequest = DescribeDomainTopClientIpVisitRequest;\nclass DescribeDomainTopClientIpVisitResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            clientIpList: 'ClientIpList',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            clientIpList: { 'type': 'array', 'itemType': DescribeDomainTopClientIpVisitResponseBodyClientIpList },\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeDomainTopClientIpVisitResponseBody = DescribeDomainTopClientIpVisitResponseBody;\nclass DescribeDomainTopClientIpVisitResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainTopClientIpVisitResponseBody,\n        };\n    }\n}\nexports.DescribeDomainTopClientIpVisitResponse = DescribeDomainTopClientIpVisitResponse;\nclass DescribeDomainTopReferVisitRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            percent: 'Percent',\n            sortBy: 'SortBy',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            percent: 'string',\n            sortBy: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainTopReferVisitRequest = DescribeDomainTopReferVisitRequest;\nclass DescribeDomainTopReferVisitResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            topReferList: 'TopReferList',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            topReferList: DescribeDomainTopReferVisitResponseBodyTopReferList,\n        };\n    }\n}\nexports.DescribeDomainTopReferVisitResponseBody = DescribeDomainTopReferVisitResponseBody;\nclass DescribeDomainTopReferVisitResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainTopReferVisitResponseBody,\n        };\n    }\n}\nexports.DescribeDomainTopReferVisitResponse = DescribeDomainTopReferVisitResponse;\nclass DescribeDomainTopUrlVisitRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            sortBy: 'SortBy',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            sortBy: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitRequest = DescribeDomainTopUrlVisitRequest;\nclass DescribeDomainTopUrlVisitResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            allUrlList: 'AllUrlList',\n            domainName: 'DomainName',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            url200List: 'Url200List',\n            url300List: 'Url300List',\n            url400List: 'Url400List',\n            url500List: 'Url500List',\n        };\n    }\n    static types() {\n        return {\n            allUrlList: DescribeDomainTopUrlVisitResponseBodyAllUrlList,\n            domainName: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            url200List: DescribeDomainTopUrlVisitResponseBodyUrl200List,\n            url300List: DescribeDomainTopUrlVisitResponseBodyUrl300List,\n            url400List: DescribeDomainTopUrlVisitResponseBodyUrl400List,\n            url500List: DescribeDomainTopUrlVisitResponseBodyUrl500List,\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBody = DescribeDomainTopUrlVisitResponseBody;\nclass DescribeDomainTopUrlVisitResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainTopUrlVisitResponseBody,\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponse = DescribeDomainTopUrlVisitResponse;\nclass DescribeDomainTrafficDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            interval: 'Interval',\n            ispNameEn: 'IspNameEn',\n            locationNameEn: 'LocationNameEn',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            interval: 'string',\n            ispNameEn: 'string',\n            locationNameEn: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainTrafficDataRequest = DescribeDomainTrafficDataRequest;\nclass DescribeDomainTrafficDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            trafficDataPerInterval: 'TrafficDataPerInterval',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            trafficDataPerInterval: DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval,\n        };\n    }\n}\nexports.DescribeDomainTrafficDataResponseBody = DescribeDomainTrafficDataResponseBody;\nclass DescribeDomainTrafficDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainTrafficDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainTrafficDataResponse = DescribeDomainTrafficDataResponse;\nclass DescribeDomainUsageDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            dataProtocol: 'DataProtocol',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            field: 'Field',\n            interval: 'Interval',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            dataProtocol: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            field: 'string',\n            interval: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.DescribeDomainUsageDataRequest = DescribeDomainUsageDataRequest;\nclass DescribeDomainUsageDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            type: 'Type',\n            usageDataPerInterval: 'UsageDataPerInterval',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            type: 'string',\n            usageDataPerInterval: DescribeDomainUsageDataResponseBodyUsageDataPerInterval,\n        };\n    }\n}\nexports.DescribeDomainUsageDataResponseBody = DescribeDomainUsageDataResponseBody;\nclass DescribeDomainUsageDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainUsageDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainUsageDataResponse = DescribeDomainUsageDataResponse;\nclass DescribeDomainUvDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainUvDataRequest = DescribeDomainUvDataRequest;\nclass DescribeDomainUvDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            uvDataInterval: 'UvDataInterval',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            uvDataInterval: DescribeDomainUvDataResponseBodyUvDataInterval,\n        };\n    }\n}\nexports.DescribeDomainUvDataResponseBody = DescribeDomainUvDataResponseBody;\nclass DescribeDomainUvDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainUvDataResponseBody,\n        };\n    }\n}\nexports.DescribeDomainUvDataResponse = DescribeDomainUvDataResponse;\nclass DescribeDomainsBySourceRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n            sources: 'Sources',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            securityToken: 'string',\n            sources: 'string',\n        };\n    }\n}\nexports.DescribeDomainsBySourceRequest = DescribeDomainsBySourceRequest;\nclass DescribeDomainsBySourceResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainsList: 'DomainsList',\n            requestId: 'RequestId',\n            sources: 'Sources',\n        };\n    }\n    static types() {\n        return {\n            domainsList: DescribeDomainsBySourceResponseBodyDomainsList,\n            requestId: 'string',\n            sources: 'string',\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponseBody = DescribeDomainsBySourceResponseBody;\nclass DescribeDomainsBySourceResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainsBySourceResponseBody,\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponse = DescribeDomainsBySourceResponse;\nclass DescribeDomainsUsageByDayRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainsUsageByDayRequest = DescribeDomainsUsageByDayRequest;\nclass DescribeDomainsUsageByDayResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataInterval: 'DataInterval',\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            usageByDays: 'UsageByDays',\n            usageTotal: 'UsageTotal',\n        };\n    }\n    static types() {\n        return {\n            dataInterval: 'string',\n            domainName: 'string',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            usageByDays: DescribeDomainsUsageByDayResponseBodyUsageByDays,\n            usageTotal: DescribeDomainsUsageByDayResponseBodyUsageTotal,\n        };\n    }\n}\nexports.DescribeDomainsUsageByDayResponseBody = DescribeDomainsUsageByDayResponseBody;\nclass DescribeDomainsUsageByDayResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeDomainsUsageByDayResponseBody,\n        };\n    }\n}\nexports.DescribeDomainsUsageByDayResponse = DescribeDomainsUsageByDayResponse;\nclass DescribeEsExceptionDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            ruleId: 'RuleId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            ownerId: 'number',\n            ruleId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeEsExceptionDataRequest = DescribeEsExceptionDataRequest;\nclass DescribeEsExceptionDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            contents: 'Contents',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            contents: { 'type': 'array', 'itemType': DescribeEsExceptionDataResponseBodyContents },\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeEsExceptionDataResponseBody = DescribeEsExceptionDataResponseBody;\nclass DescribeEsExceptionDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeEsExceptionDataResponseBody,\n        };\n    }\n}\nexports.DescribeEsExceptionDataResponse = DescribeEsExceptionDataResponse;\nclass DescribeEsExecuteDataRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            ruleId: 'RuleId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            ownerId: 'number',\n            ruleId: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeEsExecuteDataRequest = DescribeEsExecuteDataRequest;\nclass DescribeEsExecuteDataResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            contents: 'Contents',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            contents: { 'type': 'array', 'itemType': DescribeEsExecuteDataResponseBodyContents },\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeEsExecuteDataResponseBody = DescribeEsExecuteDataResponseBody;\nclass DescribeEsExecuteDataResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeEsExecuteDataResponseBody,\n        };\n    }\n}\nexports.DescribeEsExecuteDataResponse = DescribeEsExecuteDataResponse;\nclass DescribeFCTriggerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            triggerARN: 'TriggerARN',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            triggerARN: 'string',\n        };\n    }\n}\nexports.DescribeFCTriggerRequest = DescribeFCTriggerRequest;\nclass DescribeFCTriggerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            FCTrigger: 'FCTrigger',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            FCTrigger: DescribeFCTriggerResponseBodyFCTrigger,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeFCTriggerResponseBody = DescribeFCTriggerResponseBody;\nclass DescribeFCTriggerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeFCTriggerResponseBody,\n        };\n    }\n}\nexports.DescribeFCTriggerResponse = DescribeFCTriggerResponse;\nclass DescribeIllegalUrlExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            taskId: 'string',\n        };\n    }\n}\nexports.DescribeIllegalUrlExportTaskRequest = DescribeIllegalUrlExportTaskRequest;\nclass DescribeIllegalUrlExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            downloadUrl: 'DownloadUrl',\n            requestId: 'RequestId',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            downloadUrl: 'string',\n            requestId: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeIllegalUrlExportTaskResponseBody = DescribeIllegalUrlExportTaskResponseBody;\nclass DescribeIllegalUrlExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeIllegalUrlExportTaskResponseBody,\n        };\n    }\n}\nexports.DescribeIllegalUrlExportTaskResponse = DescribeIllegalUrlExportTaskResponse;\nclass DescribeIpInfoRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            IP: 'IP',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            IP: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeIpInfoRequest = DescribeIpInfoRequest;\nclass DescribeIpInfoResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnIp: 'CdnIp',\n            ISP: 'ISP',\n            ispEname: 'IspEname',\n            region: 'Region',\n            regionEname: 'RegionEname',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            cdnIp: 'string',\n            ISP: 'string',\n            ispEname: 'string',\n            region: 'string',\n            regionEname: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeIpInfoResponseBody = DescribeIpInfoResponseBody;\nclass DescribeIpInfoResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeIpInfoResponseBody,\n        };\n    }\n}\nexports.DescribeIpInfoResponse = DescribeIpInfoResponse;\nclass DescribeIpStatusRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ips: 'Ips',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ips: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeIpStatusRequest = DescribeIpStatusRequest;\nclass DescribeIpStatusResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ipStatus: 'IpStatus',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            ipStatus: { 'type': 'array', 'itemType': DescribeIpStatusResponseBodyIpStatus },\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeIpStatusResponseBody = DescribeIpStatusResponseBody;\nclass DescribeIpStatusResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeIpStatusResponseBody,\n        };\n    }\n}\nexports.DescribeIpStatusResponse = DescribeIpStatusResponse;\nclass DescribeL2VipsByDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeL2VipsByDomainRequest = DescribeL2VipsByDomainRequest;\nclass DescribeL2VipsByDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            requestId: 'RequestId',\n            vips: 'Vips',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            requestId: 'string',\n            vips: DescribeL2VipsByDomainResponseBodyVips,\n        };\n    }\n}\nexports.DescribeL2VipsByDomainResponseBody = DescribeL2VipsByDomainResponseBody;\nclass DescribeL2VipsByDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeL2VipsByDomainResponseBody,\n        };\n    }\n}\nexports.DescribeL2VipsByDomainResponse = DescribeL2VipsByDomainResponse;\nclass DescribeRangeDataByLocateAndIspServiceRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'DomainNames',\n            endTime: 'EndTime',\n            ispNames: 'IspNames',\n            locationNames: 'LocationNames',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainNames: 'string',\n            endTime: 'string',\n            ispNames: 'string',\n            locationNames: 'string',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeRangeDataByLocateAndIspServiceRequest = DescribeRangeDataByLocateAndIspServiceRequest;\nclass DescribeRangeDataByLocateAndIspServiceResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            jsonResult: 'JsonResult',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            jsonResult: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeRangeDataByLocateAndIspServiceResponseBody = DescribeRangeDataByLocateAndIspServiceResponseBody;\nclass DescribeRangeDataByLocateAndIspServiceResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeRangeDataByLocateAndIspServiceResponseBody,\n        };\n    }\n}\nexports.DescribeRangeDataByLocateAndIspServiceResponse = DescribeRangeDataByLocateAndIspServiceResponse;\nclass DescribeRealtimeDeliveryAccRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            interval: 'Interval',\n            logStore: 'LogStore',\n            ownerId: 'OwnerId',\n            project: 'Project',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            interval: 'string',\n            logStore: 'string',\n            ownerId: 'number',\n            project: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeRealtimeDeliveryAccRequest = DescribeRealtimeDeliveryAccRequest;\nclass DescribeRealtimeDeliveryAccResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            reatTimeDeliveryAccData: 'ReatTimeDeliveryAccData',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            reatTimeDeliveryAccData: DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeRealtimeDeliveryAccResponseBody = DescribeRealtimeDeliveryAccResponseBody;\nclass DescribeRealtimeDeliveryAccResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeRealtimeDeliveryAccResponseBody,\n        };\n    }\n}\nexports.DescribeRealtimeDeliveryAccResponse = DescribeRealtimeDeliveryAccResponse;\nclass DescribeRefreshQuotaRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeRefreshQuotaRequest = DescribeRefreshQuotaRequest;\nclass DescribeRefreshQuotaResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            blockQuota: 'BlockQuota',\n            blockRemain: 'BlockRemain',\n            dirQuota: 'DirQuota',\n            dirRemain: 'DirRemain',\n            preloadEdgeQuota: 'PreloadEdgeQuota',\n            preloadEdgeRemain: 'PreloadEdgeRemain',\n            preloadQuota: 'PreloadQuota',\n            preloadRemain: 'PreloadRemain',\n            regexQuota: 'RegexQuota',\n            regexRemain: 'RegexRemain',\n            requestId: 'RequestId',\n            urlQuota: 'UrlQuota',\n            urlRemain: 'UrlRemain',\n        };\n    }\n    static types() {\n        return {\n            blockQuota: 'string',\n            blockRemain: 'string',\n            dirQuota: 'string',\n            dirRemain: 'string',\n            preloadEdgeQuota: 'string',\n            preloadEdgeRemain: 'string',\n            preloadQuota: 'string',\n            preloadRemain: 'string',\n            regexQuota: 'string',\n            regexRemain: 'string',\n            requestId: 'string',\n            urlQuota: 'string',\n            urlRemain: 'string',\n        };\n    }\n}\nexports.DescribeRefreshQuotaResponseBody = DescribeRefreshQuotaResponseBody;\nclass DescribeRefreshQuotaResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeRefreshQuotaResponseBody,\n        };\n    }\n}\nexports.DescribeRefreshQuotaResponse = DescribeRefreshQuotaResponse;\nclass DescribeRefreshTaskByIdRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            taskId: 'string',\n        };\n    }\n}\nexports.DescribeRefreshTaskByIdRequest = DescribeRefreshTaskByIdRequest;\nclass DescribeRefreshTaskByIdResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            tasks: 'Tasks',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            tasks: { 'type': 'array', 'itemType': DescribeRefreshTaskByIdResponseBodyTasks },\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeRefreshTaskByIdResponseBody = DescribeRefreshTaskByIdResponseBody;\nclass DescribeRefreshTaskByIdResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeRefreshTaskByIdResponseBody,\n        };\n    }\n}\nexports.DescribeRefreshTaskByIdResponse = DescribeRefreshTaskByIdResponse;\nclass DescribeRefreshTasksRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            objectPath: 'ObjectPath',\n            objectType: 'ObjectType',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            resourceGroupId: 'ResourceGroupId',\n            securityToken: 'SecurityToken',\n            startTime: 'StartTime',\n            status: 'Status',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            objectPath: 'string',\n            objectType: 'string',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n            resourceGroupId: 'string',\n            securityToken: 'string',\n            startTime: 'string',\n            status: 'string',\n            taskId: 'string',\n        };\n    }\n}\nexports.DescribeRefreshTasksRequest = DescribeRefreshTasksRequest;\nclass DescribeRefreshTasksResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            tasks: 'Tasks',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            pageNumber: 'number',\n            pageSize: 'number',\n            requestId: 'string',\n            tasks: DescribeRefreshTasksResponseBodyTasks,\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeRefreshTasksResponseBody = DescribeRefreshTasksResponseBody;\nclass DescribeRefreshTasksResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeRefreshTasksResponseBody,\n        };\n    }\n}\nexports.DescribeRefreshTasksResponse = DescribeRefreshTasksResponse;\nclass DescribeStagingIpRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeStagingIpRequest = DescribeStagingIpRequest;\nclass DescribeStagingIpResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            IPV4s: 'IPV4s',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            IPV4s: DescribeStagingIpResponseBodyIPV4s,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeStagingIpResponseBody = DescribeStagingIpResponseBody;\nclass DescribeStagingIpResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeStagingIpResponseBody,\n        };\n    }\n}\nexports.DescribeStagingIpResponse = DescribeStagingIpResponse;\nclass DescribeTagResourcesRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            resourceId: 'ResourceId',\n            resourceType: 'ResourceType',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            resourceId: { 'type': 'array', 'itemType': 'string' },\n            resourceType: 'string',\n            tag: { 'type': 'array', 'itemType': DescribeTagResourcesRequestTag },\n        };\n    }\n}\nexports.DescribeTagResourcesRequest = DescribeTagResourcesRequest;\nclass DescribeTagResourcesResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            tagResources: 'TagResources',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            tagResources: { 'type': 'array', 'itemType': DescribeTagResourcesResponseBodyTagResources },\n        };\n    }\n}\nexports.DescribeTagResourcesResponseBody = DescribeTagResourcesResponseBody;\nclass DescribeTagResourcesResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeTagResourcesResponseBody,\n        };\n    }\n}\nexports.DescribeTagResourcesResponse = DescribeTagResourcesResponse;\nclass DescribeTopDomainsByFlowRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            limit: 'Limit',\n            ownerId: 'OwnerId',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            limit: 'number',\n            ownerId: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeTopDomainsByFlowRequest = DescribeTopDomainsByFlowRequest;\nclass DescribeTopDomainsByFlowResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainCount: 'DomainCount',\n            domainOnlineCount: 'DomainOnlineCount',\n            endTime: 'EndTime',\n            requestId: 'RequestId',\n            startTime: 'StartTime',\n            topDomains: 'TopDomains',\n        };\n    }\n    static types() {\n        return {\n            domainCount: 'number',\n            domainOnlineCount: 'number',\n            endTime: 'string',\n            requestId: 'string',\n            startTime: 'string',\n            topDomains: DescribeTopDomainsByFlowResponseBodyTopDomains,\n        };\n    }\n}\nexports.DescribeTopDomainsByFlowResponseBody = DescribeTopDomainsByFlowResponseBody;\nclass DescribeTopDomainsByFlowResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeTopDomainsByFlowResponseBody,\n        };\n    }\n}\nexports.DescribeTopDomainsByFlowResponse = DescribeTopDomainsByFlowResponse;\nclass DescribeUserCertificateExpireCountRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeUserCertificateExpireCountRequest = DescribeUserCertificateExpireCountRequest;\nclass DescribeUserCertificateExpireCountResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            expireWithin30DaysCount: 'ExpireWithin30DaysCount',\n            expiredCount: 'ExpiredCount',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            expireWithin30DaysCount: 'number',\n            expiredCount: 'number',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeUserCertificateExpireCountResponseBody = DescribeUserCertificateExpireCountResponseBody;\nclass DescribeUserCertificateExpireCountResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserCertificateExpireCountResponseBody,\n        };\n    }\n}\nexports.DescribeUserCertificateExpireCountResponse = DescribeUserCertificateExpireCountResponse;\nclass DescribeUserConfigsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            config: 'Config',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            config: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.DescribeUserConfigsRequest = DescribeUserConfigsRequest;\nclass DescribeUserConfigsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configs: 'Configs',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            configs: DescribeUserConfigsResponseBodyConfigs,\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeUserConfigsResponseBody = DescribeUserConfigsResponseBody;\nclass DescribeUserConfigsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserConfigsResponseBody,\n        };\n    }\n}\nexports.DescribeUserConfigsResponse = DescribeUserConfigsResponse;\nclass DescribeUserDomainsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            changeEndTime: 'ChangeEndTime',\n            changeStartTime: 'ChangeStartTime',\n            checkDomainShow: 'CheckDomainShow',\n            coverage: 'Coverage',\n            domainName: 'DomainName',\n            domainSearchType: 'DomainSearchType',\n            domainStatus: 'DomainStatus',\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            resourceGroupId: 'ResourceGroupId',\n            securityToken: 'SecurityToken',\n            source: 'Source',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            changeEndTime: 'string',\n            changeStartTime: 'string',\n            checkDomainShow: 'boolean',\n            coverage: 'string',\n            domainName: 'string',\n            domainSearchType: 'string',\n            domainStatus: 'string',\n            ownerId: 'number',\n            pageNumber: 'number',\n            pageSize: 'number',\n            resourceGroupId: 'string',\n            securityToken: 'string',\n            source: 'string',\n            tag: { 'type': 'array', 'itemType': DescribeUserDomainsRequestTag },\n        };\n    }\n}\nexports.DescribeUserDomainsRequest = DescribeUserDomainsRequest;\nclass DescribeUserDomainsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domains: 'Domains',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            requestId: 'RequestId',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            domains: DescribeUserDomainsResponseBodyDomains,\n            pageNumber: 'number',\n            pageSize: 'number',\n            requestId: 'string',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeUserDomainsResponseBody = DescribeUserDomainsResponseBody;\nclass DescribeUserDomainsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserDomainsResponseBody,\n        };\n    }\n}\nexports.DescribeUserDomainsResponse = DescribeUserDomainsResponse;\nclass DescribeUserTagsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeUserTagsRequest = DescribeUserTagsRequest;\nclass DescribeUserTagsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            tags: 'Tags',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            tags: { 'type': 'array', 'itemType': DescribeUserTagsResponseBodyTags },\n        };\n    }\n}\nexports.DescribeUserTagsResponseBody = DescribeUserTagsResponseBody;\nclass DescribeUserTagsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserTagsResponseBody,\n        };\n    }\n}\nexports.DescribeUserTagsResponse = DescribeUserTagsResponse;\nclass DescribeUserUsageDataExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            pageNumber: 'string',\n            pageSize: 'string',\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskRequest = DescribeUserUsageDataExportTaskRequest;\nclass DescribeUserUsageDataExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            usageDataPerPage: 'UsageDataPerPage',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            usageDataPerPage: DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage,\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskResponseBody = DescribeUserUsageDataExportTaskResponseBody;\nclass DescribeUserUsageDataExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserUsageDataExportTaskResponseBody,\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskResponse = DescribeUserUsageDataExportTaskResponse;\nclass DescribeUserUsageDetailDataExportTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            pageNumber: 'string',\n            pageSize: 'string',\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskRequest = DescribeUserUsageDetailDataExportTaskRequest;\nclass DescribeUserUsageDetailDataExportTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n            usageDataPerPage: 'UsageDataPerPage',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n            usageDataPerPage: DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage,\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskResponseBody = DescribeUserUsageDetailDataExportTaskResponseBody;\nclass DescribeUserUsageDetailDataExportTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserUsageDetailDataExportTaskResponseBody,\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskResponse = DescribeUserUsageDetailDataExportTaskResponse;\nclass DescribeUserVipsByDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            available: 'Available',\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            available: 'string',\n            domainName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeUserVipsByDomainRequest = DescribeUserVipsByDomainRequest;\nclass DescribeUserVipsByDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            requestId: 'RequestId',\n            vips: 'Vips',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            requestId: 'string',\n            vips: DescribeUserVipsByDomainResponseBodyVips,\n        };\n    }\n}\nexports.DescribeUserVipsByDomainResponseBody = DescribeUserVipsByDomainResponseBody;\nclass DescribeUserVipsByDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeUserVipsByDomainResponseBody,\n        };\n    }\n}\nexports.DescribeUserVipsByDomainResponse = DescribeUserVipsByDomainResponse;\nclass DescribeVerifyContentRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DescribeVerifyContentRequest = DescribeVerifyContentRequest;\nclass DescribeVerifyContentResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.DescribeVerifyContentResponseBody = DescribeVerifyContentResponseBody;\nclass DescribeVerifyContentResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DescribeVerifyContentResponseBody,\n        };\n    }\n}\nexports.DescribeVerifyContentResponse = DescribeVerifyContentResponse;\nclass DisableRealtimeLogDeliveryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.DisableRealtimeLogDeliveryRequest = DisableRealtimeLogDeliveryRequest;\nclass DisableRealtimeLogDeliveryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.DisableRealtimeLogDeliveryResponseBody = DisableRealtimeLogDeliveryResponseBody;\nclass DisableRealtimeLogDeliveryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: DisableRealtimeLogDeliveryResponseBody,\n        };\n    }\n}\nexports.DisableRealtimeLogDeliveryResponse = DisableRealtimeLogDeliveryResponse;\nclass EnableRealtimeLogDeliveryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.EnableRealtimeLogDeliveryRequest = EnableRealtimeLogDeliveryRequest;\nclass EnableRealtimeLogDeliveryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.EnableRealtimeLogDeliveryResponseBody = EnableRealtimeLogDeliveryResponseBody;\nclass EnableRealtimeLogDeliveryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: EnableRealtimeLogDeliveryResponseBody,\n        };\n    }\n}\nexports.EnableRealtimeLogDeliveryResponse = EnableRealtimeLogDeliveryResponse;\nclass ListDomainsByLogConfigIdRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.ListDomainsByLogConfigIdRequest = ListDomainsByLogConfigIdRequest;\nclass ListDomainsByLogConfigIdResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domains: 'Domains',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            domains: ListDomainsByLogConfigIdResponseBodyDomains,\n            requestId: 'string',\n        };\n    }\n}\nexports.ListDomainsByLogConfigIdResponseBody = ListDomainsByLogConfigIdResponseBody;\nclass ListDomainsByLogConfigIdResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListDomainsByLogConfigIdResponseBody,\n        };\n    }\n}\nexports.ListDomainsByLogConfigIdResponse = ListDomainsByLogConfigIdResponse;\nclass ListFCTriggerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            eventMetaName: 'EventMetaName',\n            eventMetaVersion: 'EventMetaVersion',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            eventMetaName: 'string',\n            eventMetaVersion: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.ListFCTriggerRequest = ListFCTriggerRequest;\nclass ListFCTriggerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            FCTriggers: 'FCTriggers',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            FCTriggers: { 'type': 'array', 'itemType': ListFCTriggerResponseBodyFCTriggers },\n            requestId: 'string',\n        };\n    }\n}\nexports.ListFCTriggerResponseBody = ListFCTriggerResponseBody;\nclass ListFCTriggerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListFCTriggerResponseBody,\n        };\n    }\n}\nexports.ListFCTriggerResponse = ListFCTriggerResponse;\nclass ListRealtimeLogDeliveryDomainsRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            logstore: 'Logstore',\n            ownerId: 'OwnerId',\n            project: 'Project',\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            logstore: 'string',\n            ownerId: 'number',\n            project: 'string',\n            region: 'string',\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryDomainsRequest = ListRealtimeLogDeliveryDomainsRequest;\nclass ListRealtimeLogDeliveryDomainsResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: ListRealtimeLogDeliveryDomainsResponseBodyContent,\n            requestId: 'string',\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryDomainsResponseBody = ListRealtimeLogDeliveryDomainsResponseBody;\nclass ListRealtimeLogDeliveryDomainsResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListRealtimeLogDeliveryDomainsResponseBody,\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryDomainsResponse = ListRealtimeLogDeliveryDomainsResponse;\nclass ListRealtimeLogDeliveryInfosRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryInfosRequest = ListRealtimeLogDeliveryInfosRequest;\nclass ListRealtimeLogDeliveryInfosResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: ListRealtimeLogDeliveryInfosResponseBodyContent,\n            requestId: 'string',\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryInfosResponseBody = ListRealtimeLogDeliveryInfosResponseBody;\nclass ListRealtimeLogDeliveryInfosResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListRealtimeLogDeliveryInfosResponseBody,\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryInfosResponse = ListRealtimeLogDeliveryInfosResponse;\nclass ListUserCustomLogConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n        };\n    }\n}\nexports.ListUserCustomLogConfigRequest = ListUserCustomLogConfigRequest;\nclass ListUserCustomLogConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configIds: 'ConfigIds',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            configIds: ListUserCustomLogConfigResponseBodyConfigIds,\n            requestId: 'string',\n        };\n    }\n}\nexports.ListUserCustomLogConfigResponseBody = ListUserCustomLogConfigResponseBody;\nclass ListUserCustomLogConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ListUserCustomLogConfigResponseBody,\n        };\n    }\n}\nexports.ListUserCustomLogConfigResponse = ListUserCustomLogConfigResponse;\nclass ModifyCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            resourceGroupId: 'ResourceGroupId',\n            securityToken: 'SecurityToken',\n            sources: 'Sources',\n            topLevelDomain: 'TopLevelDomain',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            resourceGroupId: 'string',\n            securityToken: 'string',\n            sources: 'string',\n            topLevelDomain: 'string',\n        };\n    }\n}\nexports.ModifyCdnDomainRequest = ModifyCdnDomainRequest;\nclass ModifyCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.ModifyCdnDomainResponseBody = ModifyCdnDomainResponseBody;\nclass ModifyCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ModifyCdnDomainResponseBody,\n        };\n    }\n}\nexports.ModifyCdnDomainResponse = ModifyCdnDomainResponse;\nclass ModifyCdnDomainSchdmByPropertyRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            property: 'Property',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            property: 'string',\n        };\n    }\n}\nexports.ModifyCdnDomainSchdmByPropertyRequest = ModifyCdnDomainSchdmByPropertyRequest;\nclass ModifyCdnDomainSchdmByPropertyResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.ModifyCdnDomainSchdmByPropertyResponseBody = ModifyCdnDomainSchdmByPropertyResponseBody;\nclass ModifyCdnDomainSchdmByPropertyResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ModifyCdnDomainSchdmByPropertyResponseBody,\n        };\n    }\n}\nexports.ModifyCdnDomainSchdmByPropertyResponse = ModifyCdnDomainSchdmByPropertyResponse;\nclass ModifyRealtimeLogDeliveryRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            logstore: 'Logstore',\n            ownerId: 'OwnerId',\n            project: 'Project',\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            logstore: 'string',\n            ownerId: 'number',\n            project: 'string',\n            region: 'string',\n        };\n    }\n}\nexports.ModifyRealtimeLogDeliveryRequest = ModifyRealtimeLogDeliveryRequest;\nclass ModifyRealtimeLogDeliveryResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.ModifyRealtimeLogDeliveryResponseBody = ModifyRealtimeLogDeliveryResponseBody;\nclass ModifyRealtimeLogDeliveryResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ModifyRealtimeLogDeliveryResponseBody,\n        };\n    }\n}\nexports.ModifyRealtimeLogDeliveryResponse = ModifyRealtimeLogDeliveryResponse;\nclass ModifyUserCustomLogConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            ownerId: 'OwnerId',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            ownerId: 'number',\n            tag: 'string',\n        };\n    }\n}\nexports.ModifyUserCustomLogConfigRequest = ModifyUserCustomLogConfigRequest;\nclass ModifyUserCustomLogConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.ModifyUserCustomLogConfigResponseBody = ModifyUserCustomLogConfigResponseBody;\nclass ModifyUserCustomLogConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: ModifyUserCustomLogConfigResponseBody,\n        };\n    }\n}\nexports.ModifyUserCustomLogConfigResponse = ModifyUserCustomLogConfigResponse;\nclass OpenCdnServiceRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            internetChargeType: 'InternetChargeType',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            internetChargeType: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.OpenCdnServiceRequest = OpenCdnServiceRequest;\nclass OpenCdnServiceResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.OpenCdnServiceResponseBody = OpenCdnServiceResponseBody;\nclass OpenCdnServiceResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: OpenCdnServiceResponseBody,\n        };\n    }\n}\nexports.OpenCdnServiceResponse = OpenCdnServiceResponse;\nclass PublishStagingConfigToProductionRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.PublishStagingConfigToProductionRequest = PublishStagingConfigToProductionRequest;\nclass PublishStagingConfigToProductionResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.PublishStagingConfigToProductionResponseBody = PublishStagingConfigToProductionResponseBody;\nclass PublishStagingConfigToProductionResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: PublishStagingConfigToProductionResponseBody,\n        };\n    }\n}\nexports.PublishStagingConfigToProductionResponse = PublishStagingConfigToProductionResponse;\nclass PushObjectCacheRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            l2Preload: 'L2Preload',\n            objectPath: 'ObjectPath',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            l2Preload: 'boolean',\n            objectPath: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.PushObjectCacheRequest = PushObjectCacheRequest;\nclass PushObjectCacheResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            pushTaskId: 'PushTaskId',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            pushTaskId: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.PushObjectCacheResponseBody = PushObjectCacheResponseBody;\nclass PushObjectCacheResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: PushObjectCacheResponseBody,\n        };\n    }\n}\nexports.PushObjectCacheResponse = PushObjectCacheResponse;\nclass RefreshObjectCachesRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            objectPath: 'ObjectPath',\n            objectType: 'ObjectType',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            objectPath: 'string',\n            objectType: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.RefreshObjectCachesRequest = RefreshObjectCachesRequest;\nclass RefreshObjectCachesResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            refreshTaskId: 'RefreshTaskId',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            refreshTaskId: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.RefreshObjectCachesResponseBody = RefreshObjectCachesResponseBody;\nclass RefreshObjectCachesResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RefreshObjectCachesResponseBody,\n        };\n    }\n}\nexports.RefreshObjectCachesResponse = RefreshObjectCachesResponse;\nclass RollbackStagingConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.RollbackStagingConfigRequest = RollbackStagingConfigRequest;\nclass RollbackStagingConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.RollbackStagingConfigResponseBody = RollbackStagingConfigResponseBody;\nclass RollbackStagingConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: RollbackStagingConfigResponseBody,\n        };\n    }\n}\nexports.RollbackStagingConfigResponse = RollbackStagingConfigResponse;\nclass SetCdnDomainCSRCertificateRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            serverCertificate: 'ServerCertificate',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            serverCertificate: 'string',\n        };\n    }\n}\nexports.SetCdnDomainCSRCertificateRequest = SetCdnDomainCSRCertificateRequest;\nclass SetCdnDomainCSRCertificateResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetCdnDomainCSRCertificateResponseBody = SetCdnDomainCSRCertificateResponseBody;\nclass SetCdnDomainCSRCertificateResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetCdnDomainCSRCertificateResponseBody,\n        };\n    }\n}\nexports.SetCdnDomainCSRCertificateResponse = SetCdnDomainCSRCertificateResponse;\nclass SetCdnDomainSMCertificateRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certIdentifier: 'CertIdentifier',\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            SSLProtocol: 'SSLProtocol',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            certIdentifier: 'string',\n            domainName: 'string',\n            ownerId: 'number',\n            SSLProtocol: 'string',\n            securityToken: 'string',\n        };\n    }\n}\nexports.SetCdnDomainSMCertificateRequest = SetCdnDomainSMCertificateRequest;\nclass SetCdnDomainSMCertificateResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetCdnDomainSMCertificateResponseBody = SetCdnDomainSMCertificateResponseBody;\nclass SetCdnDomainSMCertificateResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetCdnDomainSMCertificateResponseBody,\n        };\n    }\n}\nexports.SetCdnDomainSMCertificateResponse = SetCdnDomainSMCertificateResponse;\nclass SetCdnDomainStagingConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            functions: 'Functions',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            functions: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.SetCdnDomainStagingConfigRequest = SetCdnDomainStagingConfigRequest;\nclass SetCdnDomainStagingConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetCdnDomainStagingConfigResponseBody = SetCdnDomainStagingConfigResponseBody;\nclass SetCdnDomainStagingConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetCdnDomainStagingConfigResponseBody,\n        };\n    }\n}\nexports.SetCdnDomainStagingConfigResponse = SetCdnDomainStagingConfigResponse;\nclass SetConfigOfVersionRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            functionArgs: 'FunctionArgs',\n            functionId: 'FunctionId',\n            functionMatches: 'FunctionMatches',\n            functionName: 'FunctionName',\n            ownerAccount: 'OwnerAccount',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n            versionId: 'VersionId',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            functionArgs: 'string',\n            functionId: 'number',\n            functionMatches: 'string',\n            functionName: 'string',\n            ownerAccount: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n            versionId: 'string',\n        };\n    }\n}\nexports.SetConfigOfVersionRequest = SetConfigOfVersionRequest;\nclass SetConfigOfVersionResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetConfigOfVersionResponseBody = SetConfigOfVersionResponseBody;\nclass SetConfigOfVersionResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetConfigOfVersionResponseBody,\n        };\n    }\n}\nexports.SetConfigOfVersionResponse = SetConfigOfVersionResponse;\nclass SetDomainGreenManagerConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            enable: 'Enable',\n            ownerId: 'OwnerId',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            enable: 'string',\n            ownerId: 'number',\n        };\n    }\n}\nexports.SetDomainGreenManagerConfigRequest = SetDomainGreenManagerConfigRequest;\nclass SetDomainGreenManagerConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetDomainGreenManagerConfigResponseBody = SetDomainGreenManagerConfigResponseBody;\nclass SetDomainGreenManagerConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetDomainGreenManagerConfigResponseBody,\n        };\n    }\n}\nexports.SetDomainGreenManagerConfigResponse = SetDomainGreenManagerConfigResponse;\nclass SetDomainServerCertificateRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certName: 'CertName',\n            certType: 'CertType',\n            domainName: 'DomainName',\n            forceSet: 'ForceSet',\n            ownerId: 'OwnerId',\n            privateKey: 'PrivateKey',\n            securityToken: 'SecurityToken',\n            serverCertificate: 'ServerCertificate',\n            serverCertificateStatus: 'ServerCertificateStatus',\n        };\n    }\n    static types() {\n        return {\n            certName: 'string',\n            certType: 'string',\n            domainName: 'string',\n            forceSet: 'string',\n            ownerId: 'number',\n            privateKey: 'string',\n            securityToken: 'string',\n            serverCertificate: 'string',\n            serverCertificateStatus: 'string',\n        };\n    }\n}\nexports.SetDomainServerCertificateRequest = SetDomainServerCertificateRequest;\nclass SetDomainServerCertificateResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetDomainServerCertificateResponseBody = SetDomainServerCertificateResponseBody;\nclass SetDomainServerCertificateResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetDomainServerCertificateResponseBody,\n        };\n    }\n}\nexports.SetDomainServerCertificateResponse = SetDomainServerCertificateResponse;\nclass SetErrorPageConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            customPageUrl: 'CustomPageUrl',\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            pageType: 'PageType',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            customPageUrl: 'string',\n            domainName: 'string',\n            ownerId: 'number',\n            pageType: 'string',\n            securityToken: 'string',\n        };\n    }\n}\nexports.SetErrorPageConfigRequest = SetErrorPageConfigRequest;\nclass SetErrorPageConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetErrorPageConfigResponseBody = SetErrorPageConfigResponseBody;\nclass SetErrorPageConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetErrorPageConfigResponseBody,\n        };\n    }\n}\nexports.SetErrorPageConfigResponse = SetErrorPageConfigResponse;\nclass SetHttpErrorPageConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            domainName: 'DomainName',\n            errorCode: 'ErrorCode',\n            ownerId: 'OwnerId',\n            pageUrl: 'PageUrl',\n        };\n    }\n    static types() {\n        return {\n            configId: 'number',\n            domainName: 'string',\n            errorCode: 'string',\n            ownerId: 'number',\n            pageUrl: 'string',\n        };\n    }\n}\nexports.SetHttpErrorPageConfigRequest = SetHttpErrorPageConfigRequest;\nclass SetHttpErrorPageConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetHttpErrorPageConfigResponseBody = SetHttpErrorPageConfigResponseBody;\nclass SetHttpErrorPageConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetHttpErrorPageConfigResponseBody,\n        };\n    }\n}\nexports.SetHttpErrorPageConfigResponse = SetHttpErrorPageConfigResponse;\nclass SetReqHeaderConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            domainName: 'DomainName',\n            key: 'Key',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            configId: 'number',\n            domainName: 'string',\n            key: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.SetReqHeaderConfigRequest = SetReqHeaderConfigRequest;\nclass SetReqHeaderConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetReqHeaderConfigResponseBody = SetReqHeaderConfigResponseBody;\nclass SetReqHeaderConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetReqHeaderConfigResponseBody,\n        };\n    }\n}\nexports.SetReqHeaderConfigResponse = SetReqHeaderConfigResponse;\nclass SetUserGreenManagerConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            quota: 'Quota',\n            ratio: 'Ratio',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            quota: 'string',\n            ratio: 'string',\n            securityToken: 'string',\n        };\n    }\n}\nexports.SetUserGreenManagerConfigRequest = SetUserGreenManagerConfigRequest;\nclass SetUserGreenManagerConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetUserGreenManagerConfigResponseBody = SetUserGreenManagerConfigResponseBody;\nclass SetUserGreenManagerConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetUserGreenManagerConfigResponseBody,\n        };\n    }\n}\nexports.SetUserGreenManagerConfigResponse = SetUserGreenManagerConfigResponse;\nclass SetWaitingRoomConfigRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            allowPct: 'AllowPct',\n            domainName: 'DomainName',\n            gapTime: 'GapTime',\n            maxTimeWait: 'MaxTimeWait',\n            ownerId: 'OwnerId',\n            waitUri: 'WaitUri',\n            waitUrl: 'WaitUrl',\n        };\n    }\n    static types() {\n        return {\n            allowPct: 'number',\n            domainName: 'string',\n            gapTime: 'number',\n            maxTimeWait: 'number',\n            ownerId: 'number',\n            waitUri: 'string',\n            waitUrl: 'string',\n        };\n    }\n}\nexports.SetWaitingRoomConfigRequest = SetWaitingRoomConfigRequest;\nclass SetWaitingRoomConfigResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.SetWaitingRoomConfigResponseBody = SetWaitingRoomConfigResponseBody;\nclass SetWaitingRoomConfigResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: SetWaitingRoomConfigResponseBody,\n        };\n    }\n}\nexports.SetWaitingRoomConfigResponse = SetWaitingRoomConfigResponse;\nclass StartCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.StartCdnDomainRequest = StartCdnDomainRequest;\nclass StartCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.StartCdnDomainResponseBody = StartCdnDomainResponseBody;\nclass StartCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: StartCdnDomainResponseBody,\n        };\n    }\n}\nexports.StartCdnDomainResponse = StartCdnDomainResponse;\nclass StopCdnDomainRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            securityToken: 'SecurityToken',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            securityToken: 'string',\n        };\n    }\n}\nexports.StopCdnDomainRequest = StopCdnDomainRequest;\nclass StopCdnDomainResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.StopCdnDomainResponseBody = StopCdnDomainResponseBody;\nclass StopCdnDomainResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: StopCdnDomainResponseBody,\n        };\n    }\n}\nexports.StopCdnDomainResponse = StopCdnDomainResponse;\nclass TagResourcesRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ownerId: 'OwnerId',\n            resourceId: 'ResourceId',\n            resourceType: 'ResourceType',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            ownerId: 'number',\n            resourceId: { 'type': 'array', 'itemType': 'string' },\n            resourceType: 'string',\n            tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },\n        };\n    }\n}\nexports.TagResourcesRequest = TagResourcesRequest;\nclass TagResourcesResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.TagResourcesResponseBody = TagResourcesResponseBody;\nclass TagResourcesResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: TagResourcesResponseBody,\n        };\n    }\n}\nexports.TagResourcesResponse = TagResourcesResponse;\nclass UntagResourcesRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            all: 'All',\n            ownerId: 'OwnerId',\n            resourceId: 'ResourceId',\n            resourceType: 'ResourceType',\n            tagKey: 'TagKey',\n        };\n    }\n    static types() {\n        return {\n            all: 'boolean',\n            ownerId: 'number',\n            resourceId: { 'type': 'array', 'itemType': 'string' },\n            resourceType: 'string',\n            tagKey: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.UntagResourcesRequest = UntagResourcesRequest;\nclass UntagResourcesResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.UntagResourcesResponseBody = UntagResourcesResponseBody;\nclass UntagResourcesResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UntagResourcesResponseBody,\n        };\n    }\n}\nexports.UntagResourcesResponse = UntagResourcesResponse;\nclass UpdateCdnDeliverTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            deliver: 'Deliver',\n            deliverId: 'DeliverId',\n            domainName: 'DomainName',\n            name: 'Name',\n            ownerId: 'OwnerId',\n            reports: 'Reports',\n            schedule: 'Schedule',\n        };\n    }\n    static types() {\n        return {\n            deliver: 'string',\n            deliverId: 'number',\n            domainName: 'string',\n            name: 'string',\n            ownerId: 'number',\n            reports: 'string',\n            schedule: 'string',\n        };\n    }\n}\nexports.UpdateCdnDeliverTaskRequest = UpdateCdnDeliverTaskRequest;\nclass UpdateCdnDeliverTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.UpdateCdnDeliverTaskResponseBody = UpdateCdnDeliverTaskResponseBody;\nclass UpdateCdnDeliverTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateCdnDeliverTaskResponseBody,\n        };\n    }\n}\nexports.UpdateCdnDeliverTaskResponse = UpdateCdnDeliverTaskResponse;\nclass UpdateCdnSubTaskRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            endTime: 'EndTime',\n            ownerId: 'OwnerId',\n            reportIds: 'ReportIds',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            endTime: 'string',\n            ownerId: 'number',\n            reportIds: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.UpdateCdnSubTaskRequest = UpdateCdnSubTaskRequest;\nclass UpdateCdnSubTaskResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.UpdateCdnSubTaskResponseBody = UpdateCdnSubTaskResponseBody;\nclass UpdateCdnSubTaskResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateCdnSubTaskResponseBody,\n        };\n    }\n}\nexports.UpdateCdnSubTaskResponse = UpdateCdnSubTaskResponse;\nclass UpdateFCTriggerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            functionARN: 'FunctionARN',\n            notes: 'Notes',\n            ownerId: 'OwnerId',\n            roleARN: 'RoleARN',\n            sourceARN: 'SourceARN',\n            triggerARN: 'TriggerARN',\n        };\n    }\n    static types() {\n        return {\n            functionARN: 'string',\n            notes: 'string',\n            ownerId: 'number',\n            roleARN: 'string',\n            sourceARN: 'string',\n            triggerARN: 'string',\n        };\n    }\n}\nexports.UpdateFCTriggerRequest = UpdateFCTriggerRequest;\nclass UpdateFCTriggerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            requestId: 'string',\n        };\n    }\n}\nexports.UpdateFCTriggerResponseBody = UpdateFCTriggerResponseBody;\nclass UpdateFCTriggerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: UpdateFCTriggerResponseBody,\n        };\n    }\n}\nexports.UpdateFCTriggerResponse = UpdateFCTriggerResponse;\nclass VerifyDomainOwnerRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            ownerId: 'OwnerId',\n            verifyType: 'VerifyType',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            ownerId: 'number',\n            verifyType: 'string',\n        };\n    }\n}\nexports.VerifyDomainOwnerRequest = VerifyDomainOwnerRequest;\nclass VerifyDomainOwnerResponseBody extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            requestId: 'RequestId',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            requestId: 'string',\n        };\n    }\n}\nexports.VerifyDomainOwnerResponseBody = VerifyDomainOwnerResponseBody;\nclass VerifyDomainOwnerResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            statusCode: 'statusCode',\n            body: 'body',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            statusCode: 'number',\n            body: VerifyDomainOwnerResponseBody,\n        };\n    }\n}\nexports.VerifyDomainOwnerResponse = VerifyDomainOwnerResponse;\nclass BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            domainName: 'DomainName',\n            functionName: 'FunctionName',\n        };\n    }\n    static types() {\n        return {\n            configId: 'number',\n            domainName: 'string',\n            functionName: 'string',\n        };\n    }\n}\nexports.BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel = BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel;\nclass BatchSetCdnDomainConfigResponseBodyDomainConfigList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainConfigModel: 'DomainConfigModel',\n        };\n    }\n    static types() {\n        return {\n            domainConfigModel: { 'type': 'array', 'itemType': BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel },\n        };\n    }\n}\nexports.BatchSetCdnDomainConfigResponseBodyDomainConfigList = BatchSetCdnDomainConfigResponseBodyDomainConfigList;\nclass DescribeBlockedRegionsResponseBodyInfoListInfoItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            continent: 'Continent',\n            countriesAndRegions: 'CountriesAndRegions',\n            countriesAndRegionsName: 'CountriesAndRegionsName',\n        };\n    }\n    static types() {\n        return {\n            continent: 'string',\n            countriesAndRegions: 'string',\n            countriesAndRegionsName: 'string',\n        };\n    }\n}\nexports.DescribeBlockedRegionsResponseBodyInfoListInfoItem = DescribeBlockedRegionsResponseBodyInfoListInfoItem;\nclass DescribeBlockedRegionsResponseBodyInfoList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            infoItem: 'InfoItem',\n        };\n    }\n    static types() {\n        return {\n            infoItem: { 'type': 'array', 'itemType': DescribeBlockedRegionsResponseBodyInfoListInfoItem },\n        };\n    }\n}\nexports.DescribeBlockedRegionsResponseBodyInfoList = DescribeBlockedRegionsResponseBodyInfoList;\nclass DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certId: 'CertId',\n            certName: 'CertName',\n            common: 'Common',\n            fingerprint: 'Fingerprint',\n            issuer: 'Issuer',\n            lastTime: 'LastTime',\n        };\n    }\n    static types() {\n        return {\n            certId: 'number',\n            certName: 'string',\n            common: 'string',\n            fingerprint: 'string',\n            issuer: 'string',\n            lastTime: 'number',\n        };\n    }\n}\nexports.DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert = DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert;\nclass DescribeCdnCertificateListResponseBodyCertificateListModelCertList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cert: 'Cert',\n        };\n    }\n    static types() {\n        return {\n            cert: { 'type': 'array', 'itemType': DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert },\n        };\n    }\n}\nexports.DescribeCdnCertificateListResponseBodyCertificateListModelCertList = DescribeCdnCertificateListResponseBodyCertificateListModelCertList;\nclass DescribeCdnCertificateListResponseBodyCertificateListModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certList: 'CertList',\n            count: 'Count',\n        };\n    }\n    static types() {\n        return {\n            certList: DescribeCdnCertificateListResponseBodyCertificateListModelCertList,\n            count: 'number',\n        };\n    }\n}\nexports.DescribeCdnCertificateListResponseBodyCertificateListModel = DescribeCdnCertificateListResponseBodyCertificateListModel;\nclass DescribeCdnDeletedDomainsResponseBodyDomainsPageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            gmtModified: 'GmtModified',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            gmtModified: 'string',\n        };\n    }\n}\nexports.DescribeCdnDeletedDomainsResponseBodyDomainsPageData = DescribeCdnDeletedDomainsResponseBodyDomainsPageData;\nclass DescribeCdnDeletedDomainsResponseBodyDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            pageData: 'PageData',\n        };\n    }\n    static types() {\n        return {\n            pageData: { 'type': 'array', 'itemType': DescribeCdnDeletedDomainsResponseBodyDomainsPageData },\n        };\n    }\n}\nexports.DescribeCdnDeletedDomainsResponseBodyDomains = DescribeCdnDeletedDomainsResponseBodyDomains;\nclass DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certCaIsLegacy: 'CertCaIsLegacy',\n            certExpireTime: 'CertExpireTime',\n            certExpired: 'CertExpired',\n            certStartTime: 'CertStartTime',\n            certSubjectCommonName: 'CertSubjectCommonName',\n            certType: 'CertType',\n            domainList: 'DomainList',\n            domainNames: 'DomainNames',\n            issuer: 'Issuer',\n        };\n    }\n    static types() {\n        return {\n            certCaIsLegacy: 'string',\n            certExpireTime: 'string',\n            certExpired: 'string',\n            certStartTime: 'string',\n            certSubjectCommonName: 'string',\n            certType: 'string',\n            domainList: 'string',\n            domainNames: 'string',\n            issuer: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo = DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo;\nclass DescribeCdnDomainByCertificateResponseBodyCertInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfo: 'CertInfo',\n        };\n    }\n    static types() {\n        return {\n            certInfo: { 'type': 'array', 'itemType': DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo },\n        };\n    }\n}\nexports.DescribeCdnDomainByCertificateResponseBodyCertInfos = DescribeCdnDomainByCertificateResponseBodyCertInfos;\nclass DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            argName: 'ArgName',\n            argValue: 'ArgValue',\n        };\n    }\n    static types() {\n        return {\n            argName: 'string',\n            argValue: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg = DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg;\nclass DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            functionArg: 'FunctionArg',\n        };\n    }\n    static types() {\n        return {\n            functionArg: { 'type': 'array', 'itemType': DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg },\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs = DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs;\nclass DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            functionArgs: 'FunctionArgs',\n            functionName: 'FunctionName',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            functionArgs: DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs,\n            functionName: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig = DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig;\nclass DescribeCdnDomainConfigsResponseBodyDomainConfigs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainConfig: 'DomainConfig',\n        };\n    }\n    static types() {\n        return {\n            domainConfig: { 'type': 'array', 'itemType': DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig },\n        };\n    }\n}\nexports.DescribeCdnDomainConfigsResponseBodyDomainConfigs = DescribeCdnDomainConfigsResponseBodyDomainConfigs;\nclass DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            enabled: 'Enabled',\n            port: 'Port',\n            priority: 'Priority',\n            type: 'Type',\n            weight: 'Weight',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            enabled: 'string',\n            port: 'number',\n            priority: 'string',\n            type: 'string',\n            weight: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel = DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel;\nclass DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            sourceModel: 'SourceModel',\n        };\n    }\n    static types() {\n        return {\n            sourceModel: { 'type': 'array', 'itemType': DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel },\n        };\n    }\n}\nexports.DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels = DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels;\nclass DescribeCdnDomainDetailResponseBodyGetDomainDetailModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            cname: 'Cname',\n            description: 'Description',\n            domainName: 'DomainName',\n            domainStatus: 'DomainStatus',\n            gmtCreated: 'GmtCreated',\n            gmtModified: 'GmtModified',\n            httpsCname: 'HttpsCname',\n            resourceGroupId: 'ResourceGroupId',\n            scope: 'Scope',\n            serverCertificateStatus: 'ServerCertificateStatus',\n            sourceModels: 'SourceModels',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            cname: 'string',\n            description: 'string',\n            domainName: 'string',\n            domainStatus: 'string',\n            gmtCreated: 'string',\n            gmtModified: 'string',\n            httpsCname: 'string',\n            resourceGroupId: 'string',\n            scope: 'string',\n            serverCertificateStatus: 'string',\n            sourceModels: DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels,\n        };\n    }\n}\nexports.DescribeCdnDomainDetailResponseBodyGetDomainDetailModel = DescribeCdnDomainDetailResponseBodyGetDomainDetailModel;\nclass DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            logName: 'LogName',\n            logPath: 'LogPath',\n            logSize: 'LogSize',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            logName: 'string',\n            logPath: 'string',\n            logSize: 'number',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail = DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail;\nclass DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            logInfoDetail: 'LogInfoDetail',\n        };\n    }\n    static types() {\n        return {\n            logInfoDetail: { 'type': 'array', 'itemType': DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail },\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos = DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos;\nclass DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            pageIndex: 'PageIndex',\n            pageSize: 'PageSize',\n            total: 'Total',\n        };\n    }\n    static types() {\n        return {\n            pageIndex: 'number',\n            pageSize: 'number',\n            total: 'number',\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos = DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos;\nclass DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            logCount: 'LogCount',\n            logInfos: 'LogInfos',\n            pageInfos: 'PageInfos',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            logCount: 'number',\n            logInfos: DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos,\n            pageInfos: DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos,\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail = DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail;\nclass DescribeCdnDomainLogsResponseBodyDomainLogDetails extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainLogDetail: 'DomainLogDetail',\n        };\n    }\n    static types() {\n        return {\n            domainLogDetail: { 'type': 'array', 'itemType': DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail },\n        };\n    }\n}\nexports.DescribeCdnDomainLogsResponseBodyDomainLogDetails = DescribeCdnDomainLogsResponseBodyDomainLogDetails;\nclass DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            argName: 'ArgName',\n            argValue: 'ArgValue',\n        };\n    }\n    static types() {\n        return {\n            argName: 'string',\n            argValue: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs = DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs;\nclass DescribeCdnDomainStagingConfigResponseBodyDomainConfigs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            functionArgs: 'FunctionArgs',\n            functionName: 'FunctionName',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            functionArgs: { 'type': 'array', 'itemType': DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs },\n            functionName: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeCdnDomainStagingConfigResponseBodyDomainConfigs = DescribeCdnDomainStagingConfigResponseBodyDomainConfigs;\nclass DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certCommonName: 'CertCommonName',\n            certExpireTime: 'CertExpireTime',\n            certName: 'CertName',\n            certStartTime: 'CertStartTime',\n            certStatus: 'CertStatus',\n            certType: 'CertType',\n            certUpdateTime: 'CertUpdateTime',\n            domainName: 'DomainName',\n        };\n    }\n    static types() {\n        return {\n            certCommonName: 'string',\n            certExpireTime: 'string',\n            certName: 'string',\n            certStartTime: 'string',\n            certStatus: 'string',\n            certType: 'string',\n            certUpdateTime: 'string',\n            domainName: 'string',\n        };\n    }\n}\nexports.DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo = DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo;\nclass DescribeCdnHttpsDomainListResponseBodyCertInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfo: 'CertInfo',\n        };\n    }\n    static types() {\n        return {\n            certInfo: { 'type': 'array', 'itemType': DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo },\n        };\n    }\n}\nexports.DescribeCdnHttpsDomainListResponseBodyCertInfos = DescribeCdnHttpsDomainListResponseBodyCertInfos;\nclass DescribeCdnRegionAndIspResponseBodyIspsIsp extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            nameEn: 'NameEn',\n            nameZh: 'NameZh',\n        };\n    }\n    static types() {\n        return {\n            nameEn: 'string',\n            nameZh: 'string',\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspResponseBodyIspsIsp = DescribeCdnRegionAndIspResponseBodyIspsIsp;\nclass DescribeCdnRegionAndIspResponseBodyIsps extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            isp: 'Isp',\n        };\n    }\n    static types() {\n        return {\n            isp: { 'type': 'array', 'itemType': DescribeCdnRegionAndIspResponseBodyIspsIsp },\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspResponseBodyIsps = DescribeCdnRegionAndIspResponseBodyIsps;\nclass DescribeCdnRegionAndIspResponseBodyRegionsRegion extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            nameEn: 'NameEn',\n            nameZh: 'NameZh',\n        };\n    }\n    static types() {\n        return {\n            nameEn: 'string',\n            nameZh: 'string',\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspResponseBodyRegionsRegion = DescribeCdnRegionAndIspResponseBodyRegionsRegion;\nclass DescribeCdnRegionAndIspResponseBodyRegions extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            region: { 'type': 'array', 'itemType': DescribeCdnRegionAndIspResponseBodyRegionsRegion },\n        };\n    }\n}\nexports.DescribeCdnRegionAndIspResponseBodyRegions = DescribeCdnRegionAndIspResponseBodyRegions;\nclass DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certIdentifier: 'CertIdentifier',\n            certName: 'CertName',\n            common: 'Common',\n            issuer: 'Issuer',\n        };\n    }\n    static types() {\n        return {\n            certIdentifier: 'string',\n            certName: 'string',\n            common: 'string',\n            issuer: 'string',\n        };\n    }\n}\nexports.DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert = DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert;\nclass DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cert: 'Cert',\n        };\n    }\n    static types() {\n        return {\n            cert: { 'type': 'array', 'itemType': DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert },\n        };\n    }\n}\nexports.DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList = DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList;\nclass DescribeCdnSMCertificateListResponseBodyCertificateListModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certList: 'CertList',\n            count: 'Count',\n        };\n    }\n    static types() {\n        return {\n            certList: DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList,\n            count: 'number',\n        };\n    }\n}\nexports.DescribeCdnSMCertificateListResponseBodyCertificateListModel = DescribeCdnSMCertificateListResponseBodyCertificateListModel;\nclass DescribeCdnServiceResponseBodyOperationLocksLockReason extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            lockReason: 'LockReason',\n        };\n    }\n    static types() {\n        return {\n            lockReason: 'string',\n        };\n    }\n}\nexports.DescribeCdnServiceResponseBodyOperationLocksLockReason = DescribeCdnServiceResponseBodyOperationLocksLockReason;\nclass DescribeCdnServiceResponseBodyOperationLocks extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            lockReason: 'LockReason',\n        };\n    }\n    static types() {\n        return {\n            lockReason: { 'type': 'array', 'itemType': DescribeCdnServiceResponseBodyOperationLocksLockReason },\n        };\n    }\n}\nexports.DescribeCdnServiceResponseBodyOperationLocks = DescribeCdnServiceResponseBodyOperationLocks;\nclass DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bandwidth: 'Bandwidth',\n            cdnRegion: 'CdnRegion',\n            chargeType: 'ChargeType',\n            count: 'Count',\n            flow: 'Flow',\n        };\n    }\n    static types() {\n        return {\n            bandwidth: 'number',\n            cdnRegion: 'string',\n            chargeType: 'string',\n            count: 'number',\n            flow: 'number',\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem = DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem;\nclass DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billingDataItem: 'BillingDataItem',\n        };\n    }\n    static types() {\n        return {\n            billingDataItem: { 'type': 'array', 'itemType': DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem },\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData = DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData;\nclass DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billTime: 'BillTime',\n            billType: 'BillType',\n            billingData: 'BillingData',\n            dimension: 'Dimension',\n        };\n    }\n    static types() {\n        return {\n            billTime: 'string',\n            billType: 'string',\n            billingData: DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData,\n            dimension: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem = DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem;\nclass DescribeCdnUserBillHistoryResponseBodyBillHistoryData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billHistoryDataItem: 'BillHistoryDataItem',\n        };\n    }\n    static types() {\n        return {\n            billHistoryDataItem: { 'type': 'array', 'itemType': DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem },\n        };\n    }\n}\nexports.DescribeCdnUserBillHistoryResponseBodyBillHistoryData = DescribeCdnUserBillHistoryResponseBodyBillHistoryData;\nclass DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            timeStp: 'TimeStp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            timeStp: 'string',\n            value: 'number',\n        };\n    }\n}\nexports.DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem = DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem;\nclass DescribeCdnUserBillPredictionResponseBodyBillPredictionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billPredictionDataItem: 'BillPredictionDataItem',\n        };\n    }\n    static types() {\n        return {\n            billPredictionDataItem: { 'type': 'array', 'itemType': DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem },\n        };\n    }\n}\nexports.DescribeCdnUserBillPredictionResponseBodyBillPredictionData = DescribeCdnUserBillPredictionResponseBodyBillPredictionData;\nclass DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billType: 'BillType',\n            billingCycle: 'BillingCycle',\n            dimension: 'Dimension',\n            endTime: 'EndTime',\n            product: 'Product',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            billType: 'string',\n            billingCycle: 'string',\n            dimension: 'string',\n            endTime: 'string',\n            product: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem = DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem;\nclass DescribeCdnUserBillTypeResponseBodyBillTypeData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            billTypeDataItem: 'BillTypeDataItem',\n        };\n    }\n    static types() {\n        return {\n            billTypeDataItem: { 'type': 'array', 'itemType': DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem },\n        };\n    }\n}\nexports.DescribeCdnUserBillTypeResponseBodyBillTypeData = DescribeCdnUserBillTypeResponseBodyBillTypeData;\nclass DescribeCdnUserConfigsResponseBodyConfigs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            argName: 'ArgName',\n            argValue: 'ArgValue',\n            functionName: 'FunctionName',\n        };\n    }\n    static types() {\n        return {\n            argName: 'string',\n            argValue: 'string',\n            functionName: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserConfigsResponseBodyConfigs = DescribeCdnUserConfigsResponseBodyConfigs;\nclass DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            port: 'Port',\n            priority: 'Priority',\n            type: 'Type',\n            weight: 'Weight',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            port: 'number',\n            priority: 'string',\n            type: 'string',\n            weight: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource = DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource;\nclass DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            source: 'Source',\n        };\n    }\n    static types() {\n        return {\n            source: { 'type': 'array', 'itemType': DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource },\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources = DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources;\nclass DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            cname: 'Cname',\n            description: 'Description',\n            domainName: 'DomainName',\n            domainStatus: 'DomainStatus',\n            gmtCreated: 'GmtCreated',\n            gmtModified: 'GmtModified',\n            resourceGroupId: 'ResourceGroupId',\n            sources: 'Sources',\n            sslProtocol: 'SslProtocol',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            cname: 'string',\n            description: 'string',\n            domainName: 'string',\n            domainStatus: 'string',\n            gmtCreated: 'string',\n            gmtModified: 'string',\n            resourceGroupId: 'string',\n            sources: DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources,\n            sslProtocol: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData = DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData;\nclass DescribeCdnUserDomainsByFuncResponseBodyDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            pageData: 'PageData',\n        };\n    }\n    static types() {\n        return {\n            pageData: { 'type': 'array', 'itemType': DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData },\n        };\n    }\n}\nexports.DescribeCdnUserDomainsByFuncResponseBodyDomains = DescribeCdnUserDomainsByFuncResponseBodyDomains;\nclass DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            commodityCode: 'CommodityCode',\n            currCapacity: 'CurrCapacity',\n            displayName: 'DisplayName',\n            endTime: 'EndTime',\n            initCapacity: 'InitCapacity',\n            instanceId: 'InstanceId',\n            startTime: 'StartTime',\n            status: 'Status',\n            templateName: 'TemplateName',\n        };\n    }\n    static types() {\n        return {\n            commodityCode: 'string',\n            currCapacity: 'string',\n            displayName: 'string',\n            endTime: 'string',\n            initCapacity: 'string',\n            instanceId: 'string',\n            startTime: 'string',\n            status: 'string',\n            templateName: 'string',\n        };\n    }\n}\nexports.DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo = DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo;\nclass DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            resourcePackageInfo: 'ResourcePackageInfo',\n        };\n    }\n    static types() {\n        return {\n            resourcePackageInfo: { 'type': 'array', 'itemType': DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo },\n        };\n    }\n}\nexports.DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos = DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos;\nclass DescribeCdnWafDomainResponseBodyOutPutDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            aclStatus: 'AclStatus',\n            ccStatus: 'CcStatus',\n            domain: 'Domain',\n            status: 'Status',\n            wafStatus: 'WafStatus',\n        };\n    }\n    static types() {\n        return {\n            aclStatus: 'string',\n            ccStatus: 'string',\n            domain: 'string',\n            status: 'string',\n            wafStatus: 'string',\n        };\n    }\n}\nexports.DescribeCdnWafDomainResponseBodyOutPutDomains = DescribeCdnWafDomainResponseBodyOutPutDomains;\nclass DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certExpireTime: 'CertExpireTime',\n            certId: 'CertId',\n            certName: 'CertName',\n            certType: 'CertType',\n            createTime: 'CreateTime',\n            domainList: 'DomainList',\n            httpsCrt: 'HttpsCrt',\n        };\n    }\n    static types() {\n        return {\n            certExpireTime: 'string',\n            certId: 'string',\n            certName: 'string',\n            certType: 'string',\n            createTime: 'string',\n            domainList: 'string',\n            httpsCrt: 'string',\n        };\n    }\n}\nexports.DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo = DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo;\nclass DescribeCertificateInfoByIDResponseBodyCertInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfo: 'CertInfo',\n        };\n    }\n    static types() {\n        return {\n            certInfo: { 'type': 'array', 'itemType': DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo },\n        };\n    }\n}\nexports.DescribeCertificateInfoByIDResponseBodyCertInfos = DescribeCertificateInfoByIDResponseBodyCertInfos;\nclass DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            argName: 'ArgName',\n            argValue: 'ArgValue',\n        };\n    }\n    static types() {\n        return {\n            argName: 'string',\n            argValue: 'string',\n        };\n    }\n}\nexports.DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg = DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg;\nclass DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            functionArg: 'FunctionArg',\n        };\n    }\n    static types() {\n        return {\n            functionArg: { 'type': 'array', 'itemType': DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg },\n        };\n    }\n}\nexports.DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs = DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs;\nclass DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfig extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n            functionArgs: 'FunctionArgs',\n            functionName: 'FunctionName',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            configId: 'string',\n            functionArgs: DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs,\n            functionName: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfig = DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfig;\nclass DescribeConfigOfVersionResponseBodyVersionConfigs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            versionConfig: 'VersionConfig',\n        };\n    }\n    static types() {\n        return {\n            versionConfig: { 'type': 'array', 'itemType': DescribeConfigOfVersionResponseBodyVersionConfigsVersionConfig },\n        };\n    }\n}\nexports.DescribeConfigOfVersionResponseBodyVersionConfigs = DescribeConfigOfVersionResponseBodyVersionConfigs;\nclass DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule = DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule;\nclass DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval = DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval;\nclass DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domesticValue: 'DomesticValue',\n            httpsDomesticValue: 'HttpsDomesticValue',\n            httpsOverseasValue: 'HttpsOverseasValue',\n            httpsValue: 'HttpsValue',\n            overseasValue: 'OverseasValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            domesticValue: 'string',\n            httpsDomesticValue: 'string',\n            httpsOverseasValue: 'string',\n            httpsValue: 'string',\n            overseasValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule = DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule;\nclass DescribeDomainBpsDataResponseBodyBpsDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainBpsDataResponseBodyBpsDataPerInterval = DescribeDomainBpsDataResponseBodyBpsDataPerInterval;\nclass DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            trafficValue: 'TrafficValue',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            trafficValue: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule = DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule;\nclass DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval = DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval;\nclass DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bps: 'Bps',\n            ispName: 'IspName',\n            locationName: 'LocationName',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            bps: 'number',\n            ispName: 'string',\n            locationName: 'string',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel = DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel;\nclass DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bpsDataModel: 'BpsDataModel',\n        };\n    }\n    static types() {\n        return {\n            bpsDataModel: { 'type': 'array', 'itemType': DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel },\n        };\n    }\n}\nexports.DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList = DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList;\nclass DescribeDomainCcActivityLogResponseBodyActivityLog extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            action: 'Action',\n            domainName: 'DomainName',\n            ruleName: 'RuleName',\n            timeStamp: 'TimeStamp',\n            triggerObject: 'TriggerObject',\n            ttl: 'Ttl',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            action: 'string',\n            domainName: 'string',\n            ruleName: 'string',\n            timeStamp: 'string',\n            triggerObject: 'string',\n            ttl: 'number',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainCcActivityLogResponseBodyActivityLog = DescribeDomainCcActivityLogResponseBodyActivityLog;\nclass DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certDomainName: 'CertDomainName',\n            certExpireTime: 'CertExpireTime',\n            certLife: 'CertLife',\n            certName: 'CertName',\n            certOrg: 'CertOrg',\n            certStartTime: 'CertStartTime',\n            certType: 'CertType',\n            certUpdateTime: 'CertUpdateTime',\n            domainCnameStatus: 'DomainCnameStatus',\n            domainName: 'DomainName',\n            serverCertificate: 'ServerCertificate',\n            serverCertificateStatus: 'ServerCertificateStatus',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            certDomainName: 'string',\n            certExpireTime: 'string',\n            certLife: 'string',\n            certName: 'string',\n            certOrg: 'string',\n            certStartTime: 'string',\n            certType: 'string',\n            certUpdateTime: 'string',\n            domainCnameStatus: 'string',\n            domainName: 'string',\n            serverCertificate: 'string',\n            serverCertificateStatus: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo = DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo;\nclass DescribeDomainCertificateInfoResponseBodyCertInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            certInfo: 'CertInfo',\n        };\n    }\n    static types() {\n        return {\n            certInfo: { 'type': 'array', 'itemType': DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo },\n        };\n    }\n}\nexports.DescribeDomainCertificateInfoResponseBodyCertInfos = DescribeDomainCertificateInfoResponseBodyCertInfos;\nclass DescribeDomainDetailDataByLayerResponseBodyDataDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            acc: 'Acc',\n            bps: 'Bps',\n            domainName: 'DomainName',\n            httpCode: 'HttpCode',\n            ipv6Acc: 'Ipv6Acc',\n            ipv6Bps: 'Ipv6Bps',\n            ipv6Qps: 'Ipv6Qps',\n            ipv6Traf: 'Ipv6Traf',\n            qps: 'Qps',\n            timeStamp: 'TimeStamp',\n            traf: 'Traf',\n        };\n    }\n    static types() {\n        return {\n            acc: 'number',\n            bps: 'number',\n            domainName: 'string',\n            httpCode: 'string',\n            ipv6Acc: 'number',\n            ipv6Bps: 'number',\n            ipv6Qps: 'number',\n            ipv6Traf: 'number',\n            qps: 'number',\n            timeStamp: 'string',\n            traf: 'number',\n        };\n    }\n}\nexports.DescribeDomainDetailDataByLayerResponseBodyDataDataModule = DescribeDomainDetailDataByLayerResponseBodyDataDataModule;\nclass DescribeDomainDetailDataByLayerResponseBodyData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainDetailDataByLayerResponseBodyDataDataModule },\n        };\n    }\n}\nexports.DescribeDomainDetailDataByLayerResponseBodyData = DescribeDomainDetailDataByLayerResponseBodyData;\nclass DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValueFileSizeProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            fileSize: 'FileSize',\n            proportion: 'Proportion',\n        };\n    }\n    static types() {\n        return {\n            fileSize: 'string',\n            proportion: 'string',\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValueFileSizeProportionData = DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValueFileSizeProportionData;\nclass DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            fileSizeProportionData: 'FileSizeProportionData',\n        };\n    }\n    static types() {\n        return {\n            fileSizeProportionData: { 'type': 'array', 'itemType': DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValueFileSizeProportionData },\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValue = DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValue;\nclass DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageDataValue,\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageData = DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageData;\nclass DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataIntervalUsageData },\n        };\n    }\n}\nexports.DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataInterval = DescribeDomainFileSizeProportionDataResponseBodyFileSizeProportionDataInterval;\nclass DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            httpsValue: 'HttpsValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            httpsValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule = DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule;\nclass DescribeDomainHitRateDataResponseBodyHitRateInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainHitRateDataResponseBodyHitRateInterval = DescribeDomainHitRateDataResponseBodyHitRateInterval;\nclass DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            code: 'Code',\n            count: 'Count',\n            proportion: 'Proportion',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            count: 'string',\n            proportion: 'string',\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData = DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData;\nclass DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            codeProportionData: 'CodeProportionData',\n        };\n    }\n    static types() {\n        return {\n            codeProportionData: { 'type': 'array', 'itemType': DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData },\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue = DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue;\nclass DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue,\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData = DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData;\nclass DescribeDomainHttpCodeDataResponseBodyHttpCodeData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData },\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataResponseBodyHttpCodeData = DescribeDomainHttpCodeDataResponseBodyHttpCodeData;\nclass DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            totalValue: 'TotalValue',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            totalValue: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule = DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule;\nclass DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval = DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval;\nclass DescribeDomainISPDataResponseBodyValueISPProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            avgObjectSize: 'AvgObjectSize',\n            avgResponseRate: 'AvgResponseRate',\n            avgResponseTime: 'AvgResponseTime',\n            bps: 'Bps',\n            bytesProportion: 'BytesProportion',\n            ISP: 'ISP',\n            ispEname: 'IspEname',\n            proportion: 'Proportion',\n            qps: 'Qps',\n            reqErrRate: 'ReqErrRate',\n            totalBytes: 'TotalBytes',\n            totalQuery: 'TotalQuery',\n        };\n    }\n    static types() {\n        return {\n            avgObjectSize: 'string',\n            avgResponseRate: 'string',\n            avgResponseTime: 'string',\n            bps: 'string',\n            bytesProportion: 'string',\n            ISP: 'string',\n            ispEname: 'string',\n            proportion: 'string',\n            qps: 'string',\n            reqErrRate: 'string',\n            totalBytes: 'string',\n            totalQuery: 'string',\n        };\n    }\n}\nexports.DescribeDomainISPDataResponseBodyValueISPProportionData = DescribeDomainISPDataResponseBodyValueISPProportionData;\nclass DescribeDomainISPDataResponseBodyValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ISPProportionData: 'ISPProportionData',\n        };\n    }\n    static types() {\n        return {\n            ISPProportionData: { 'type': 'array', 'itemType': DescribeDomainISPDataResponseBodyValueISPProportionData },\n        };\n    }\n}\nexports.DescribeDomainISPDataResponseBodyValue = DescribeDomainISPDataResponseBodyValue;\nclass DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n            request: 'Request',\n            timeStamp: 'TimeStamp',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            domain: 'string',\n            request: 'number',\n            timeStamp: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule = DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule;\nclass DescribeDomainMultiUsageDataResponseBodyRequestPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            requestDataModule: 'RequestDataModule',\n        };\n    }\n    static types() {\n        return {\n            requestDataModule: { 'type': 'array', 'itemType': DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule },\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataResponseBodyRequestPerInterval = DescribeDomainMultiUsageDataResponseBodyRequestPerInterval;\nclass DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            area: 'Area',\n            bps: 'Bps',\n            domain: 'Domain',\n            timeStamp: 'TimeStamp',\n            type: 'Type',\n        };\n    }\n    static types() {\n        return {\n            area: 'string',\n            bps: 'number',\n            domain: 'string',\n            timeStamp: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule = DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule;\nclass DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            trafficDataModule: 'TrafficDataModule',\n        };\n    }\n    static types() {\n        return {\n            trafficDataModule: { 'type': 'array', 'itemType': DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule },\n        };\n    }\n}\nexports.DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval = DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval;\nclass DescribeDomainNamesOfVersionResponseBodyContents extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainId: 'DomainId',\n            domainName: 'DomainName',\n        };\n    }\n    static types() {\n        return {\n            domainId: 'string',\n            domainName: 'string',\n        };\n    }\n}\nexports.DescribeDomainNamesOfVersionResponseBodyContents = DescribeDomainNamesOfVersionResponseBodyContents;\nclass DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            acc: 'Acc',\n            path: 'Path',\n            time: 'Time',\n            traffic: 'Traffic',\n        };\n    }\n    static types() {\n        return {\n            acc: 'number',\n            path: 'string',\n            time: 'string',\n            traffic: 'number',\n        };\n    }\n}\nexports.DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData = DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData;\nclass DescribeDomainPathDataResponseBodyPathDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData },\n        };\n    }\n}\nexports.DescribeDomainPathDataResponseBodyPathDataPerInterval = DescribeDomainPathDataResponseBodyPathDataPerInterval;\nclass DescribeDomainPvDataResponseBodyPvDataIntervalUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainPvDataResponseBodyPvDataIntervalUsageData = DescribeDomainPvDataResponseBodyPvDataIntervalUsageData;\nclass DescribeDomainPvDataResponseBodyPvDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainPvDataResponseBodyPvDataIntervalUsageData },\n        };\n    }\n}\nexports.DescribeDomainPvDataResponseBodyPvDataInterval = DescribeDomainPvDataResponseBodyPvDataInterval;\nclass DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            accDomesticValue: 'AccDomesticValue',\n            accOverseasValue: 'AccOverseasValue',\n            accValue: 'AccValue',\n            domesticValue: 'DomesticValue',\n            httpsAccDomesticValue: 'HttpsAccDomesticValue',\n            httpsAccOverseasValue: 'HttpsAccOverseasValue',\n            httpsAccValue: 'HttpsAccValue',\n            httpsDomesticValue: 'HttpsDomesticValue',\n            httpsOverseasValue: 'HttpsOverseasValue',\n            httpsValue: 'HttpsValue',\n            overseasValue: 'OverseasValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            accDomesticValue: 'string',\n            accOverseasValue: 'string',\n            accValue: 'string',\n            domesticValue: 'string',\n            httpsAccDomesticValue: 'string',\n            httpsAccOverseasValue: 'string',\n            httpsAccValue: 'string',\n            httpsDomesticValue: 'string',\n            httpsOverseasValue: 'string',\n            httpsValue: 'string',\n            overseasValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule = DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule;\nclass DescribeDomainQpsDataResponseBodyQpsDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainQpsDataResponseBodyQpsDataInterval = DescribeDomainQpsDataResponseBodyQpsDataInterval;\nclass DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            accDomesticValue: 'AccDomesticValue',\n            accOverseasValue: 'AccOverseasValue',\n            accValue: 'AccValue',\n            domesticValue: 'DomesticValue',\n            overseasValue: 'OverseasValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            accDomesticValue: 'string',\n            accOverseasValue: 'string',\n            accValue: 'string',\n            domesticValue: 'string',\n            overseasValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule = DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule;\nclass DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval = DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval;\nclass DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bps: 'Bps',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            bps: 'number',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel = DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel;\nclass DescribeDomainRealTimeBpsDataResponseBodyData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bpsModel: 'BpsModel',\n        };\n    }\n    static types() {\n        return {\n            bpsModel: { 'type': 'array', 'itemType': DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel },\n        };\n    }\n}\nexports.DescribeDomainRealTimeBpsDataResponseBodyData = DescribeDomainRealTimeBpsDataResponseBodyData;\nclass DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            byteHitRate: 'ByteHitRate',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            byteHitRate: 'number',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel = DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel;\nclass DescribeDomainRealTimeByteHitRateDataResponseBodyData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            byteHitRateDataModel: 'ByteHitRateDataModel',\n        };\n    }\n    static types() {\n        return {\n            byteHitRateDataModel: { 'type': 'array', 'itemType': DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel },\n        };\n    }\n}\nexports.DescribeDomainRealTimeByteHitRateDataResponseBodyData = DescribeDomainRealTimeByteHitRateDataResponseBodyData;\nclass DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            code: 'Code',\n            count: 'Count',\n            proportion: 'Proportion',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            count: 'string',\n            proportion: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData = DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData;\nclass DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            realTimeCodeProportionData: 'RealTimeCodeProportionData',\n        };\n    }\n    static types() {\n        return {\n            realTimeCodeProportionData: { 'type': 'array', 'itemType': DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData },\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue = DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue;\nclass DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue,\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData = DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData;\nclass DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData },\n        };\n    }\n}\nexports.DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData = DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData;\nclass DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            qps: 'Qps',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            qps: 'number',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel = DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel;\nclass DescribeDomainRealTimeQpsDataResponseBodyData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            qpsModel: 'QpsModel',\n        };\n    }\n    static types() {\n        return {\n            qpsModel: { 'type': 'array', 'itemType': DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel },\n        };\n    }\n}\nexports.DescribeDomainRealTimeQpsDataResponseBodyData = DescribeDomainRealTimeQpsDataResponseBodyData;\nclass DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            reqHitRate: 'ReqHitRate',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            reqHitRate: 'number',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel = DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel;\nclass DescribeDomainRealTimeReqHitRateDataResponseBodyData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            reqHitRateDataModel: 'ReqHitRateDataModel',\n        };\n    }\n    static types() {\n        return {\n            reqHitRateDataModel: { 'type': 'array', 'itemType': DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel },\n        };\n    }\n}\nexports.DescribeDomainRealTimeReqHitRateDataResponseBodyData = DescribeDomainRealTimeReqHitRateDataResponseBodyData;\nclass DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule = DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule;\nclass DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval = DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval;\nclass DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            code: 'Code',\n            count: 'Count',\n            proportion: 'Proportion',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            count: 'string',\n            proportion: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData = DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData;\nclass DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            realTimeSrcCodeProportionData: 'RealTimeSrcCodeProportionData',\n        };\n    }\n    static types() {\n        return {\n            realTimeSrcCodeProportionData: { 'type': 'array', 'itemType': DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData },\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue = DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue;\nclass DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue,\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData = DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData;\nclass DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData },\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData = DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData;\nclass DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule = DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule;\nclass DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval = DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval;\nclass DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule = DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule;\nclass DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval = DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval;\nclass DescribeDomainRegionDataResponseBodyValueRegionProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            avgObjectSize: 'AvgObjectSize',\n            avgResponseRate: 'AvgResponseRate',\n            avgResponseTime: 'AvgResponseTime',\n            bps: 'Bps',\n            bytesProportion: 'BytesProportion',\n            proportion: 'Proportion',\n            qps: 'Qps',\n            region: 'Region',\n            regionEname: 'RegionEname',\n            reqErrRate: 'ReqErrRate',\n            totalBytes: 'TotalBytes',\n            totalQuery: 'TotalQuery',\n        };\n    }\n    static types() {\n        return {\n            avgObjectSize: 'string',\n            avgResponseRate: 'string',\n            avgResponseTime: 'string',\n            bps: 'string',\n            bytesProportion: 'string',\n            proportion: 'string',\n            qps: 'string',\n            region: 'string',\n            regionEname: 'string',\n            reqErrRate: 'string',\n            totalBytes: 'string',\n            totalQuery: 'string',\n        };\n    }\n}\nexports.DescribeDomainRegionDataResponseBodyValueRegionProportionData = DescribeDomainRegionDataResponseBodyValueRegionProportionData;\nclass DescribeDomainRegionDataResponseBodyValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            regionProportionData: 'RegionProportionData',\n        };\n    }\n    static types() {\n        return {\n            regionProportionData: { 'type': 'array', 'itemType': DescribeDomainRegionDataResponseBodyValueRegionProportionData },\n        };\n    }\n}\nexports.DescribeDomainRegionDataResponseBodyValue = DescribeDomainRegionDataResponseBodyValue;\nclass DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            httpsValue: 'HttpsValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            httpsValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule = DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule;\nclass DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval = DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval;\nclass DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            httpsValue: 'HttpsValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            httpsValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule = DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule;\nclass DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval = DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval;\nclass DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            code: 'Code',\n            count: 'Count',\n            proportion: 'Proportion',\n        };\n    }\n    static types() {\n        return {\n            code: 'string',\n            count: 'string',\n            proportion: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData = DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData;\nclass DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            codeProportionData: 'CodeProportionData',\n        };\n    }\n    static types() {\n        return {\n            codeProportionData: { 'type': 'array', 'itemType': DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData },\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue = DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue;\nclass DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue,\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData = DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData;\nclass DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData },\n        };\n    }\n}\nexports.DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData = DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData;\nclass DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule = DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule;\nclass DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval = DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval;\nclass DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList = DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList;\nclass DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList },\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList = DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList = DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl200List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl200List = DescribeDomainSrcTopUrlVisitResponseBodyUrl200List;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList = DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl300List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl300List = DescribeDomainSrcTopUrlVisitResponseBodyUrl300List;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList = DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl400List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl400List = DescribeDomainSrcTopUrlVisitResponseBodyUrl400List;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList = DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList;\nclass DescribeDomainSrcTopUrlVisitResponseBodyUrl500List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainSrcTopUrlVisitResponseBodyUrl500List = DescribeDomainSrcTopUrlVisitResponseBodyUrl500List;\nclass DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            httpsValue: 'HttpsValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            httpsValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule = DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule;\nclass DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval = DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval;\nclass DescribeDomainTopClientIpVisitResponseBodyClientIpList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            acc: 'Acc',\n            clientIp: 'ClientIp',\n            rank: 'Rank',\n            traffic: 'Traffic',\n        };\n    }\n    static types() {\n        return {\n            acc: 'number',\n            clientIp: 'string',\n            rank: 'number',\n            traffic: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopClientIpVisitResponseBodyClientIpList = DescribeDomainTopClientIpVisitResponseBodyClientIpList;\nclass DescribeDomainTopReferVisitResponseBodyTopReferListReferList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            referDetail: 'ReferDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            referDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopReferVisitResponseBodyTopReferListReferList = DescribeDomainTopReferVisitResponseBodyTopReferListReferList;\nclass DescribeDomainTopReferVisitResponseBodyTopReferList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            referList: 'ReferList',\n        };\n    }\n    static types() {\n        return {\n            referList: { 'type': 'array', 'itemType': DescribeDomainTopReferVisitResponseBodyTopReferListReferList },\n        };\n    }\n}\nexports.DescribeDomainTopReferVisitResponseBodyTopReferList = DescribeDomainTopReferVisitResponseBodyTopReferList;\nclass DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList = DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList;\nclass DescribeDomainTopUrlVisitResponseBodyAllUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList },\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyAllUrlList = DescribeDomainTopUrlVisitResponseBodyAllUrlList;\nclass DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList = DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList;\nclass DescribeDomainTopUrlVisitResponseBodyUrl200List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl200List = DescribeDomainTopUrlVisitResponseBodyUrl200List;\nclass DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList = DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList;\nclass DescribeDomainTopUrlVisitResponseBodyUrl300List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl300List = DescribeDomainTopUrlVisitResponseBodyUrl300List;\nclass DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList = DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList;\nclass DescribeDomainTopUrlVisitResponseBodyUrl400List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl400List = DescribeDomainTopUrlVisitResponseBodyUrl400List;\nclass DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            flow: 'Flow',\n            flowProportion: 'FlowProportion',\n            urlDetail: 'UrlDetail',\n            visitData: 'VisitData',\n            visitProportion: 'VisitProportion',\n        };\n    }\n    static types() {\n        return {\n            flow: 'string',\n            flowProportion: 'number',\n            urlDetail: 'string',\n            visitData: 'string',\n            visitProportion: 'number',\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList = DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList;\nclass DescribeDomainTopUrlVisitResponseBodyUrl500List extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            urlList: 'UrlList',\n        };\n    }\n    static types() {\n        return {\n            urlList: { 'type': 'array', 'itemType': DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList },\n        };\n    }\n}\nexports.DescribeDomainTopUrlVisitResponseBodyUrl500List = DescribeDomainTopUrlVisitResponseBodyUrl500List;\nclass DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domesticValue: 'DomesticValue',\n            httpsDomesticValue: 'HttpsDomesticValue',\n            httpsOverseasValue: 'HttpsOverseasValue',\n            httpsValue: 'HttpsValue',\n            overseasValue: 'OverseasValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            domesticValue: 'string',\n            httpsDomesticValue: 'string',\n            httpsOverseasValue: 'string',\n            httpsValue: 'string',\n            overseasValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule = DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule;\nclass DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval = DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval;\nclass DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            peakTime: 'PeakTime',\n            specialValue: 'SpecialValue',\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            peakTime: 'string',\n            specialValue: 'string',\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule = DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule;\nclass DescribeDomainUsageDataResponseBodyUsageDataPerInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataModule: 'DataModule',\n        };\n    }\n    static types() {\n        return {\n            dataModule: { 'type': 'array', 'itemType': DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule },\n        };\n    }\n}\nexports.DescribeDomainUsageDataResponseBodyUsageDataPerInterval = DescribeDomainUsageDataResponseBodyUsageDataPerInterval;\nclass DescribeDomainUvDataResponseBodyUvDataIntervalUsageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            timeStamp: 'TimeStamp',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            timeStamp: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeDomainUvDataResponseBodyUvDataIntervalUsageData = DescribeDomainUvDataResponseBodyUvDataIntervalUsageData;\nclass DescribeDomainUvDataResponseBodyUvDataInterval extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageData: 'UsageData',\n        };\n    }\n    static types() {\n        return {\n            usageData: { 'type': 'array', 'itemType': DescribeDomainUvDataResponseBodyUvDataIntervalUsageData },\n        };\n    }\n}\nexports.DescribeDomainUvDataResponseBodyUvDataInterval = DescribeDomainUvDataResponseBodyUvDataInterval;\nclass DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            createTime: 'CreateTime',\n            domainCname: 'DomainCname',\n            domainName: 'DomainName',\n            status: 'Status',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            createTime: 'string',\n            domainCname: 'string',\n            domainName: 'string',\n            status: 'string',\n            updateTime: 'string',\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo = DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo;\nclass DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainInfo: 'domainInfo',\n        };\n    }\n    static types() {\n        return {\n            domainInfo: { 'type': 'array', 'itemType': DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo },\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos = DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos;\nclass DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainNames: 'domainNames',\n        };\n    }\n    static types() {\n        return {\n            domainNames: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains = DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains;\nclass DescribeDomainsBySourceResponseBodyDomainsListDomainsData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainInfos: 'DomainInfos',\n            domains: 'Domains',\n            source: 'Source',\n        };\n    }\n    static types() {\n        return {\n            domainInfos: DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos,\n            domains: DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains,\n            source: 'string',\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponseBodyDomainsListDomainsData = DescribeDomainsBySourceResponseBodyDomainsListDomainsData;\nclass DescribeDomainsBySourceResponseBodyDomainsList extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainsData: 'DomainsData',\n        };\n    }\n    static types() {\n        return {\n            domainsData: { 'type': 'array', 'itemType': DescribeDomainsBySourceResponseBodyDomainsListDomainsData },\n        };\n    }\n}\nexports.DescribeDomainsBySourceResponseBodyDomainsList = DescribeDomainsBySourceResponseBodyDomainsList;\nclass DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bytesHitRate: 'BytesHitRate',\n            maxBps: 'MaxBps',\n            maxBpsTime: 'MaxBpsTime',\n            maxSrcBps: 'MaxSrcBps',\n            maxSrcBpsTime: 'MaxSrcBpsTime',\n            qps: 'Qps',\n            requestHitRate: 'RequestHitRate',\n            timeStamp: 'TimeStamp',\n            totalAccess: 'TotalAccess',\n            totalTraffic: 'TotalTraffic',\n        };\n    }\n    static types() {\n        return {\n            bytesHitRate: 'string',\n            maxBps: 'string',\n            maxBpsTime: 'string',\n            maxSrcBps: 'string',\n            maxSrcBpsTime: 'string',\n            qps: 'string',\n            requestHitRate: 'string',\n            timeStamp: 'string',\n            totalAccess: 'string',\n            totalTraffic: 'string',\n        };\n    }\n}\nexports.DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay = DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay;\nclass DescribeDomainsUsageByDayResponseBodyUsageByDays extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            usageByDay: 'UsageByDay',\n        };\n    }\n    static types() {\n        return {\n            usageByDay: { 'type': 'array', 'itemType': DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay },\n        };\n    }\n}\nexports.DescribeDomainsUsageByDayResponseBodyUsageByDays = DescribeDomainsUsageByDayResponseBodyUsageByDays;\nclass DescribeDomainsUsageByDayResponseBodyUsageTotal extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bytesHitRate: 'BytesHitRate',\n            maxBps: 'MaxBps',\n            maxBpsTime: 'MaxBpsTime',\n            maxSrcBps: 'MaxSrcBps',\n            maxSrcBpsTime: 'MaxSrcBpsTime',\n            requestHitRate: 'RequestHitRate',\n            totalAccess: 'TotalAccess',\n            totalTraffic: 'TotalTraffic',\n        };\n    }\n    static types() {\n        return {\n            bytesHitRate: 'string',\n            maxBps: 'string',\n            maxBpsTime: 'string',\n            maxSrcBps: 'string',\n            maxSrcBpsTime: 'string',\n            requestHitRate: 'string',\n            totalAccess: 'string',\n            totalTraffic: 'string',\n        };\n    }\n}\nexports.DescribeDomainsUsageByDayResponseBodyUsageTotal = DescribeDomainsUsageByDayResponseBodyUsageTotal;\nclass DescribeEsExceptionDataResponseBodyContents extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            columns: 'Columns',\n            name: 'Name',\n            points: 'Points',\n        };\n    }\n    static types() {\n        return {\n            columns: { 'type': 'array', 'itemType': 'string' },\n            name: 'string',\n            points: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeEsExceptionDataResponseBodyContents = DescribeEsExceptionDataResponseBodyContents;\nclass DescribeEsExecuteDataResponseBodyContents extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            columns: 'Columns',\n            name: 'Name',\n            points: 'Points',\n        };\n    }\n    static types() {\n        return {\n            columns: { 'type': 'array', 'itemType': 'string' },\n            name: 'string',\n            points: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeEsExecuteDataResponseBodyContents = DescribeEsExecuteDataResponseBodyContents;\nclass DescribeFCTriggerResponseBodyFCTrigger extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            eventMetaName: 'EventMetaName',\n            eventMetaVersion: 'EventMetaVersion',\n            notes: 'Notes',\n            roleARN: 'RoleARN',\n            sourceArn: 'SourceArn',\n            triggerARN: 'TriggerARN',\n        };\n    }\n    static types() {\n        return {\n            eventMetaName: 'string',\n            eventMetaVersion: 'string',\n            notes: 'string',\n            roleARN: 'string',\n            sourceArn: 'string',\n            triggerARN: 'string',\n        };\n    }\n}\nexports.DescribeFCTriggerResponseBodyFCTrigger = DescribeFCTriggerResponseBodyFCTrigger;\nclass DescribeIpStatusResponseBodyIpStatus extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ip: 'ip',\n            status: 'status',\n        };\n    }\n    static types() {\n        return {\n            ip: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.DescribeIpStatusResponseBodyIpStatus = DescribeIpStatusResponseBodyIpStatus;\nclass DescribeL2VipsByDomainResponseBodyVips extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            vip: 'Vip',\n        };\n    }\n    static types() {\n        return {\n            vip: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeL2VipsByDomainResponseBodyVips = DescribeL2VipsByDomainResponseBodyVips;\nclass DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            failedNum: 'FailedNum',\n            successNum: 'SuccessNum',\n            timeStamp: 'TimeStamp',\n        };\n    }\n    static types() {\n        return {\n            failedNum: 'number',\n            successNum: 'number',\n            timeStamp: 'string',\n        };\n    }\n}\nexports.DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData = DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData;\nclass DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            accData: 'AccData',\n        };\n    }\n    static types() {\n        return {\n            accData: { 'type': 'array', 'itemType': DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData },\n        };\n    }\n}\nexports.DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData = DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData;\nclass DescribeRefreshTaskByIdResponseBodyTasks extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            creationTime: 'CreationTime',\n            description: 'Description',\n            objectPath: 'ObjectPath',\n            objectType: 'ObjectType',\n            process: 'Process',\n            status: 'Status',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            creationTime: 'string',\n            description: 'string',\n            objectPath: 'string',\n            objectType: 'string',\n            process: 'string',\n            status: 'string',\n            taskId: 'string',\n        };\n    }\n}\nexports.DescribeRefreshTaskByIdResponseBodyTasks = DescribeRefreshTaskByIdResponseBodyTasks;\nclass DescribeRefreshTasksResponseBodyTasksCDNTask extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            creationTime: 'CreationTime',\n            description: 'Description',\n            objectPath: 'ObjectPath',\n            objectType: 'ObjectType',\n            process: 'Process',\n            status: 'Status',\n            taskId: 'TaskId',\n        };\n    }\n    static types() {\n        return {\n            creationTime: 'string',\n            description: 'string',\n            objectPath: 'string',\n            objectType: 'string',\n            process: 'string',\n            status: 'string',\n            taskId: 'string',\n        };\n    }\n}\nexports.DescribeRefreshTasksResponseBodyTasksCDNTask = DescribeRefreshTasksResponseBodyTasksCDNTask;\nclass DescribeRefreshTasksResponseBodyTasks extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            CDNTask: 'CDNTask',\n        };\n    }\n    static types() {\n        return {\n            CDNTask: { 'type': 'array', 'itemType': DescribeRefreshTasksResponseBodyTasksCDNTask },\n        };\n    }\n}\nexports.DescribeRefreshTasksResponseBodyTasks = DescribeRefreshTasksResponseBodyTasks;\nclass DescribeStagingIpResponseBodyIPV4s extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            IPV4: 'IPV4',\n        };\n    }\n    static types() {\n        return {\n            IPV4: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeStagingIpResponseBodyIPV4s = DescribeStagingIpResponseBodyIPV4s;\nclass DescribeTagResourcesRequestTag extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeTagResourcesRequestTag = DescribeTagResourcesRequestTag;\nclass DescribeTagResourcesResponseBodyTagResourcesTag extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeTagResourcesResponseBodyTagResourcesTag = DescribeTagResourcesResponseBodyTagResourcesTag;\nclass DescribeTagResourcesResponseBodyTagResources extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            resourceId: 'ResourceId',\n            tag: 'Tag',\n        };\n    }\n    static types() {\n        return {\n            resourceId: 'string',\n            tag: { 'type': 'array', 'itemType': DescribeTagResourcesResponseBodyTagResourcesTag },\n        };\n    }\n}\nexports.DescribeTagResourcesResponseBodyTagResources = DescribeTagResourcesResponseBodyTagResources;\nclass DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            maxBps: 'MaxBps',\n            maxBpsTime: 'MaxBpsTime',\n            rank: 'Rank',\n            totalAccess: 'TotalAccess',\n            totalTraffic: 'TotalTraffic',\n            trafficPercent: 'TrafficPercent',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            maxBps: 'number',\n            maxBpsTime: 'string',\n            rank: 'number',\n            totalAccess: 'number',\n            totalTraffic: 'string',\n            trafficPercent: 'string',\n        };\n    }\n}\nexports.DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain = DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain;\nclass DescribeTopDomainsByFlowResponseBodyTopDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            topDomain: 'TopDomain',\n        };\n    }\n    static types() {\n        return {\n            topDomain: { 'type': 'array', 'itemType': DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain },\n        };\n    }\n}\nexports.DescribeTopDomainsByFlowResponseBodyTopDomains = DescribeTopDomainsByFlowResponseBodyTopDomains;\nclass DescribeUserConfigsResponseBodyConfigsOssLogConfig extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            bucket: 'Bucket',\n            enable: 'Enable',\n            prefix: 'Prefix',\n        };\n    }\n    static types() {\n        return {\n            bucket: 'string',\n            enable: 'string',\n            prefix: 'string',\n        };\n    }\n}\nexports.DescribeUserConfigsResponseBodyConfigsOssLogConfig = DescribeUserConfigsResponseBodyConfigsOssLogConfig;\nclass DescribeUserConfigsResponseBodyConfigsWafConfig extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            enable: 'Enable',\n        };\n    }\n    static types() {\n        return {\n            enable: 'string',\n        };\n    }\n}\nexports.DescribeUserConfigsResponseBodyConfigsWafConfig = DescribeUserConfigsResponseBodyConfigsWafConfig;\nclass DescribeUserConfigsResponseBodyConfigs extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            ossLogConfig: 'OssLogConfig',\n            wafConfig: 'WafConfig',\n        };\n    }\n    static types() {\n        return {\n            ossLogConfig: DescribeUserConfigsResponseBodyConfigsOssLogConfig,\n            wafConfig: DescribeUserConfigsResponseBodyConfigsWafConfig,\n        };\n    }\n}\nexports.DescribeUserConfigsResponseBodyConfigs = DescribeUserConfigsResponseBodyConfigs;\nclass DescribeUserDomainsRequestTag extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.DescribeUserDomainsRequestTag = DescribeUserDomainsRequestTag;\nclass DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            content: 'Content',\n            port: 'Port',\n            priority: 'Priority',\n            type: 'Type',\n            weight: 'Weight',\n        };\n    }\n    static types() {\n        return {\n            content: 'string',\n            port: 'number',\n            priority: 'string',\n            type: 'string',\n            weight: 'string',\n        };\n    }\n}\nexports.DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource = DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource;\nclass DescribeUserDomainsResponseBodyDomainsPageDataSources extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            source: 'Source',\n        };\n    }\n    static types() {\n        return {\n            source: { 'type': 'array', 'itemType': DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource },\n        };\n    }\n}\nexports.DescribeUserDomainsResponseBodyDomainsPageDataSources = DescribeUserDomainsResponseBodyDomainsPageDataSources;\nclass DescribeUserDomainsResponseBodyDomainsPageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            cdnType: 'CdnType',\n            cname: 'Cname',\n            coverage: 'Coverage',\n            description: 'Description',\n            domainName: 'DomainName',\n            domainStatus: 'DomainStatus',\n            gmtCreated: 'GmtCreated',\n            gmtModified: 'GmtModified',\n            resourceGroupId: 'ResourceGroupId',\n            sandbox: 'Sandbox',\n            sources: 'Sources',\n            sslProtocol: 'SslProtocol',\n        };\n    }\n    static types() {\n        return {\n            cdnType: 'string',\n            cname: 'string',\n            coverage: 'string',\n            description: 'string',\n            domainName: 'string',\n            domainStatus: 'string',\n            gmtCreated: 'string',\n            gmtModified: 'string',\n            resourceGroupId: 'string',\n            sandbox: 'string',\n            sources: DescribeUserDomainsResponseBodyDomainsPageDataSources,\n            sslProtocol: 'string',\n        };\n    }\n}\nexports.DescribeUserDomainsResponseBodyDomainsPageData = DescribeUserDomainsResponseBodyDomainsPageData;\nclass DescribeUserDomainsResponseBodyDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            pageData: 'PageData',\n        };\n    }\n    static types() {\n        return {\n            pageData: { 'type': 'array', 'itemType': DescribeUserDomainsResponseBodyDomainsPageData },\n        };\n    }\n}\nexports.DescribeUserDomainsResponseBodyDomains = DescribeUserDomainsResponseBodyDomains;\nclass DescribeUserTagsResponseBodyTags extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeUserTagsResponseBodyTags = DescribeUserTagsResponseBodyTags;\nclass DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig = DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig;\nclass DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            downloadUrl: 'DownloadUrl',\n            status: 'Status',\n            taskConfig: 'TaskConfig',\n            taskId: 'TaskId',\n            taskName: 'TaskName',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'string',\n            downloadUrl: 'string',\n            status: 'string',\n            taskConfig: DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig,\n            taskId: 'string',\n            taskName: 'string',\n            updateTime: 'string',\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem = DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem;\nclass DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataItem: 'DataItem',\n        };\n    }\n    static types() {\n        return {\n            dataItem: { 'type': 'array', 'itemType': DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem },\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData = DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData;\nclass DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData,\n            pageNumber: 'number',\n            pageSize: 'number',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage = DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage;\nclass DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            endTime: 'EndTime',\n            startTime: 'StartTime',\n        };\n    }\n    static types() {\n        return {\n            endTime: 'string',\n            startTime: 'string',\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig = DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig;\nclass DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            createTime: 'CreateTime',\n            downloadUrl: 'DownloadUrl',\n            status: 'Status',\n            taskConfig: 'TaskConfig',\n            taskId: 'TaskId',\n            taskName: 'TaskName',\n            updateTime: 'UpdateTime',\n        };\n    }\n    static types() {\n        return {\n            createTime: 'string',\n            downloadUrl: 'string',\n            status: 'string',\n            taskConfig: DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig,\n            taskId: 'string',\n            taskName: 'string',\n            updateTime: 'string',\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem = DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem;\nclass DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            dataItem: 'DataItem',\n        };\n    }\n    static types() {\n        return {\n            dataItem: { 'type': 'array', 'itemType': DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem },\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData = DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData;\nclass DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            data: 'Data',\n            pageNumber: 'PageNumber',\n            pageSize: 'PageSize',\n            totalCount: 'TotalCount',\n        };\n    }\n    static types() {\n        return {\n            data: DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData,\n            pageNumber: 'number',\n            pageSize: 'number',\n            totalCount: 'number',\n        };\n    }\n}\nexports.DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage = DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage;\nclass DescribeUserVipsByDomainResponseBodyVips extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            vip: 'Vip',\n        };\n    }\n    static types() {\n        return {\n            vip: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.DescribeUserVipsByDomainResponseBodyVips = DescribeUserVipsByDomainResponseBodyVips;\nclass ListDomainsByLogConfigIdResponseBodyDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domain: 'Domain',\n        };\n    }\n    static types() {\n        return {\n            domain: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.ListDomainsByLogConfigIdResponseBodyDomains = ListDomainsByLogConfigIdResponseBodyDomains;\nclass ListFCTriggerResponseBodyFCTriggers extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            eventMetaName: 'EventMetaName',\n            eventMetaVersion: 'EventMetaVersion',\n            notes: 'Notes',\n            roleARN: 'RoleARN',\n            sourceArn: 'SourceArn',\n            triggerARN: 'TriggerARN',\n        };\n    }\n    static types() {\n        return {\n            eventMetaName: 'string',\n            eventMetaVersion: 'string',\n            notes: 'string',\n            roleARN: 'string',\n            sourceArn: 'string',\n            triggerARN: 'string',\n        };\n    }\n}\nexports.ListFCTriggerResponseBodyFCTriggers = ListFCTriggerResponseBodyFCTriggers;\nclass ListRealtimeLogDeliveryDomainsResponseBodyContentDomains extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domainName: 'DomainName',\n            status: 'Status',\n        };\n    }\n    static types() {\n        return {\n            domainName: 'string',\n            status: 'string',\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryDomainsResponseBodyContentDomains = ListRealtimeLogDeliveryDomainsResponseBodyContentDomains;\nclass ListRealtimeLogDeliveryDomainsResponseBodyContent extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            domains: 'Domains',\n        };\n    }\n    static types() {\n        return {\n            domains: { 'type': 'array', 'itemType': ListRealtimeLogDeliveryDomainsResponseBodyContentDomains },\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryDomainsResponseBodyContent = ListRealtimeLogDeliveryDomainsResponseBodyContent;\nclass ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            logstore: 'Logstore',\n            project: 'Project',\n            region: 'Region',\n        };\n    }\n    static types() {\n        return {\n            logstore: 'string',\n            project: 'string',\n            region: 'string',\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos = ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos;\nclass ListRealtimeLogDeliveryInfosResponseBodyContent extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            realtimeLogDeliveryInfos: 'RealtimeLogDeliveryInfos',\n        };\n    }\n    static types() {\n        return {\n            realtimeLogDeliveryInfos: { 'type': 'array', 'itemType': ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos },\n        };\n    }\n}\nexports.ListRealtimeLogDeliveryInfosResponseBodyContent = ListRealtimeLogDeliveryInfosResponseBodyContent;\nclass ListUserCustomLogConfigResponseBodyConfigIds extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            configId: 'ConfigId',\n        };\n    }\n    static types() {\n        return {\n            configId: { 'type': 'array', 'itemType': 'string' },\n        };\n    }\n}\nexports.ListUserCustomLogConfigResponseBodyConfigIds = ListUserCustomLogConfigResponseBodyConfigIds;\nclass TagResourcesRequestTag extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            key: 'Key',\n            value: 'Value',\n        };\n    }\n    static types() {\n        return {\n            key: 'string',\n            value: 'string',\n        };\n    }\n}\nexports.TagResourcesRequestTag = TagResourcesRequestTag;\nclass Client extends openapi_client_1.default {\n    constructor(config) {\n        super(config);\n        this._endpointRule = \"central\";\n        this._endpointMap = {\n            'ap-northeast-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'ap-south-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'ap-southeast-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'ap-southeast-2': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'ap-southeast-3': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'ap-southeast-5': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'eu-central-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'eu-west-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'me-east-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'us-east-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n            'us-west-1': \"cdn.ap-southeast-1.aliyuncs.com\",\n        };\n        this.checkConfig(config);\n        this._endpoint = this.getEndpoint(\"cdn\", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);\n    }\n    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {\n        if (!tea_util_1.default.empty(endpoint)) {\n            return endpoint;\n        }\n        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {\n            return endpointMap[regionId];\n        }\n        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);\n    }\n    async addCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.cdnType)) {\n            query[\"CdnType\"] = request.cdnType;\n        }\n        if (!tea_util_1.default.isUnset(request.checkUrl)) {\n            query[\"CheckUrl\"] = request.checkUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerAccount)) {\n            query[\"OwnerAccount\"] = request.ownerAccount;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.scope)) {\n            query[\"Scope\"] = request.scope;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.sources)) {\n            query[\"Sources\"] = request.sources;\n        }\n        if (!tea_util_1.default.isUnset(request.topLevelDomain)) {\n            query[\"TopLevelDomain\"] = request.topLevelDomain;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"AddCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new AddCdnDomainResponse({}));\n    }\n    async addCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.addCdnDomainWithOptions(request, runtime);\n    }\n    async addFCTriggerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.triggerARN)) {\n            query[\"TriggerARN\"] = request.triggerARN;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.eventMetaName)) {\n            body[\"EventMetaName\"] = request.eventMetaName;\n        }\n        if (!tea_util_1.default.isUnset(request.eventMetaVersion)) {\n            body[\"EventMetaVersion\"] = request.eventMetaVersion;\n        }\n        if (!tea_util_1.default.isUnset(request.functionARN)) {\n            body[\"FunctionARN\"] = request.functionARN;\n        }\n        if (!tea_util_1.default.isUnset(request.notes)) {\n            body[\"Notes\"] = request.notes;\n        }\n        if (!tea_util_1.default.isUnset(request.roleARN)) {\n            body[\"RoleARN\"] = request.roleARN;\n        }\n        if (!tea_util_1.default.isUnset(request.sourceARN)) {\n            body[\"SourceARN\"] = request.sourceARN;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"AddFCTrigger\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new AddFCTriggerResponse({}));\n    }\n    async addFCTrigger(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.addFCTriggerWithOptions(request, runtime);\n    }\n    async batchAddCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.cdnType)) {\n            query[\"CdnType\"] = request.cdnType;\n        }\n        if (!tea_util_1.default.isUnset(request.checkUrl)) {\n            query[\"CheckUrl\"] = request.checkUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerAccount)) {\n            query[\"OwnerAccount\"] = request.ownerAccount;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.scope)) {\n            query[\"Scope\"] = request.scope;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.sources)) {\n            query[\"Sources\"] = request.sources;\n        }\n        if (!tea_util_1.default.isUnset(request.topLevelDomain)) {\n            query[\"TopLevelDomain\"] = request.topLevelDomain;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchAddCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchAddCdnDomainResponse({}));\n    }\n    async batchAddCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchAddCdnDomainWithOptions(request, runtime);\n    }\n    async batchDeleteCdnDomainConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainNames)) {\n            query[\"DomainNames\"] = request.domainNames;\n        }\n        if (!tea_util_1.default.isUnset(request.functionNames)) {\n            query[\"FunctionNames\"] = request.functionNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerAccount)) {\n            query[\"OwnerAccount\"] = request.ownerAccount;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchDeleteCdnDomainConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchDeleteCdnDomainConfigResponse({}));\n    }\n    async batchDeleteCdnDomainConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchDeleteCdnDomainConfigWithOptions(request, runtime);\n    }\n    async batchSetCdnDomainConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainNames)) {\n            query[\"DomainNames\"] = request.domainNames;\n        }\n        if (!tea_util_1.default.isUnset(request.functions)) {\n            query[\"Functions\"] = request.functions;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerAccount)) {\n            query[\"OwnerAccount\"] = request.ownerAccount;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchSetCdnDomainConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchSetCdnDomainConfigResponse({}));\n    }\n    async batchSetCdnDomainConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchSetCdnDomainConfigWithOptions(request, runtime);\n    }\n    async batchSetCdnDomainServerCertificateWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certName)) {\n            query[\"CertName\"] = request.certName;\n        }\n        if (!tea_util_1.default.isUnset(request.certType)) {\n            query[\"CertType\"] = request.certType;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.forceSet)) {\n            query[\"ForceSet\"] = request.forceSet;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.region)) {\n            query[\"Region\"] = request.region;\n        }\n        if (!tea_util_1.default.isUnset(request.SSLPri)) {\n            query[\"SSLPri\"] = request.SSLPri;\n        }\n        if (!tea_util_1.default.isUnset(request.SSLProtocol)) {\n            query[\"SSLProtocol\"] = request.SSLProtocol;\n        }\n        if (!tea_util_1.default.isUnset(request.SSLPub)) {\n            query[\"SSLPub\"] = request.SSLPub;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchSetCdnDomainServerCertificate\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchSetCdnDomainServerCertificateResponse({}));\n    }\n    async batchSetCdnDomainServerCertificate(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchSetCdnDomainServerCertificateWithOptions(request, runtime);\n    }\n    async batchStartCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainNames)) {\n            query[\"DomainNames\"] = request.domainNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchStartCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchStartCdnDomainResponse({}));\n    }\n    async batchStartCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchStartCdnDomainWithOptions(request, runtime);\n    }\n    async batchStopCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainNames)) {\n            query[\"DomainNames\"] = request.domainNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchStopCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchStopCdnDomainResponse({}));\n    }\n    async batchStopCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchStopCdnDomainWithOptions(request, runtime);\n    }\n    async batchUpdateCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.sources)) {\n            query[\"Sources\"] = request.sources;\n        }\n        if (!tea_util_1.default.isUnset(request.topLevelDomain)) {\n            query[\"TopLevelDomain\"] = request.topLevelDomain;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"BatchUpdateCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new BatchUpdateCdnDomainResponse({}));\n    }\n    async batchUpdateCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.batchUpdateCdnDomainWithOptions(request, runtime);\n    }\n    async createCdnCertificateSigningRequestWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.city)) {\n            query[\"City\"] = request.city;\n        }\n        if (!tea_util_1.default.isUnset(request.commonName)) {\n            query[\"CommonName\"] = request.commonName;\n        }\n        if (!tea_util_1.default.isUnset(request.country)) {\n            query[\"Country\"] = request.country;\n        }\n        if (!tea_util_1.default.isUnset(request.email)) {\n            query[\"Email\"] = request.email;\n        }\n        if (!tea_util_1.default.isUnset(request.organization)) {\n            query[\"Organization\"] = request.organization;\n        }\n        if (!tea_util_1.default.isUnset(request.organizationUnit)) {\n            query[\"OrganizationUnit\"] = request.organizationUnit;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.SANs)) {\n            query[\"SANs\"] = request.SANs;\n        }\n        if (!tea_util_1.default.isUnset(request.state)) {\n            query[\"State\"] = request.state;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateCdnCertificateSigningRequest\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateCdnCertificateSigningRequestResponse({}));\n    }\n    async createCdnCertificateSigningRequest(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createCdnCertificateSigningRequestWithOptions(request, runtime);\n    }\n    async createCdnDeliverTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.deliver)) {\n            body[\"Deliver\"] = request.deliver;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            body[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.name)) {\n            body[\"Name\"] = request.name;\n        }\n        if (!tea_util_1.default.isUnset(request.reports)) {\n            body[\"Reports\"] = request.reports;\n        }\n        if (!tea_util_1.default.isUnset(request.schedule)) {\n            body[\"Schedule\"] = request.schedule;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateCdnDeliverTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateCdnDeliverTaskResponse({}));\n    }\n    async createCdnDeliverTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createCdnDeliverTaskWithOptions(request, runtime);\n    }\n    async createCdnSubTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            body[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.reportIds)) {\n            body[\"ReportIds\"] = request.reportIds;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateCdnSubTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateCdnSubTaskResponse({}));\n    }\n    async createCdnSubTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createCdnSubTaskWithOptions(request, runtime);\n    }\n    async createIllegalUrlExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.taskName)) {\n            query[\"TaskName\"] = request.taskName;\n        }\n        if (!tea_util_1.default.isUnset(request.timePoint)) {\n            query[\"TimePoint\"] = request.timePoint;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateIllegalUrlExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateIllegalUrlExportTaskResponse({}));\n    }\n    async createIllegalUrlExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createIllegalUrlExportTaskWithOptions(request, runtime);\n    }\n    async createRealTimeLogDeliveryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateRealTimeLogDelivery\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateRealTimeLogDeliveryResponse({}));\n    }\n    async createRealTimeLogDelivery(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createRealTimeLogDeliveryWithOptions(request, runtime);\n    }\n    async createUsageDetailDataExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainNames)) {\n            query[\"DomainNames\"] = request.domainNames;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.group)) {\n            query[\"Group\"] = request.group;\n        }\n        if (!tea_util_1.default.isUnset(request.language)) {\n            query[\"Language\"] = request.language;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.taskName)) {\n            query[\"TaskName\"] = request.taskName;\n        }\n        if (!tea_util_1.default.isUnset(request.type)) {\n            query[\"Type\"] = request.type;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateUsageDetailDataExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateUsageDetailDataExportTaskResponse({}));\n    }\n    async createUsageDetailDataExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createUsageDetailDataExportTaskWithOptions(request, runtime);\n    }\n    async createUserUsageDataExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.language)) {\n            query[\"Language\"] = request.language;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.taskName)) {\n            query[\"TaskName\"] = request.taskName;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"CreateUserUsageDataExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new CreateUserUsageDataExportTaskResponse({}));\n    }\n    async createUserUsageDataExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.createUserUsageDataExportTaskWithOptions(request, runtime);\n    }\n    async deleteCdnDeliverTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.deliverId)) {\n            query[\"DeliverId\"] = request.deliverId;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteCdnDeliverTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteCdnDeliverTaskResponse({}));\n    }\n    async deleteCdnDeliverTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteCdnDeliverTaskWithOptions(request, runtime);\n    }\n    async deleteCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerAccount)) {\n            query[\"OwnerAccount\"] = request.ownerAccount;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteCdnDomainResponse({}));\n    }\n    async deleteCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteCdnDomainWithOptions(request, runtime);\n    }\n    async deleteCdnSubTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteCdnSubTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteCdnSubTaskResponse({}));\n    }\n    async deleteCdnSubTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteCdnSubTaskWithOptions(request, runtime);\n    }\n    async deleteFCTriggerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.triggerARN)) {\n            query[\"TriggerARN\"] = request.triggerARN;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteFCTrigger\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteFCTriggerResponse({}));\n    }\n    async deleteFCTrigger(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteFCTriggerWithOptions(request, runtime);\n    }\n    async deleteRealtimeLogDeliveryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteRealtimeLogDelivery\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteRealtimeLogDeliveryResponse({}));\n    }\n    async deleteRealtimeLogDelivery(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteRealtimeLogDeliveryWithOptions(request, runtime);\n    }\n    async deleteSpecificConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configId)) {\n            query[\"ConfigId\"] = request.configId;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteSpecificConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSpecificConfigResponse({}));\n    }\n    async deleteSpecificConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteSpecificConfigWithOptions(request, runtime);\n    }\n    async deleteSpecificStagingConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configId)) {\n            query[\"ConfigId\"] = request.configId;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteSpecificStagingConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSpecificStagingConfigResponse({}));\n    }\n    async deleteSpecificStagingConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteSpecificStagingConfigWithOptions(request, runtime);\n    }\n    async deleteUsageDetailDataExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.taskId)) {\n            query[\"TaskId\"] = request.taskId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteUsageDetailDataExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteUsageDetailDataExportTaskResponse({}));\n    }\n    async deleteUsageDetailDataExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteUsageDetailDataExportTaskWithOptions(request, runtime);\n    }\n    async deleteUserUsageDataExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.taskId)) {\n            query[\"TaskId\"] = request.taskId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DeleteUserUsageDataExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DeleteUserUsageDataExportTaskResponse({}));\n    }\n    async deleteUserUsageDataExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.deleteUserUsageDataExportTaskWithOptions(request, runtime);\n    }\n    async describeActiveVersionOfConfigGroupWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configGroupId)) {\n            query[\"ConfigGroupId\"] = request.configGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.env)) {\n            query[\"Env\"] = request.env;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeActiveVersionOfConfigGroup\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeActiveVersionOfConfigGroupResponse({}));\n    }\n    async describeActiveVersionOfConfigGroup(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeActiveVersionOfConfigGroupWithOptions(request, runtime);\n    }\n    async describeBlockedRegionsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeBlockedRegions\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeBlockedRegionsResponse({}));\n    }\n    async describeBlockedRegions(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeBlockedRegionsWithOptions(request, runtime);\n    }\n    async describeCdnCertificateDetailWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certName)) {\n            query[\"CertName\"] = request.certName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnCertificateDetail\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnCertificateDetailResponse({}));\n    }\n    async describeCdnCertificateDetail(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnCertificateDetailWithOptions(request, runtime);\n    }\n    async describeCdnCertificateListWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnCertificateList\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnCertificateListResponse({}));\n    }\n    async describeCdnCertificateList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnCertificateListWithOptions(request, runtime);\n    }\n    async describeCdnDeletedDomainsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDeletedDomains\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDeletedDomainsResponse({}));\n    }\n    async describeCdnDeletedDomains(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDeletedDomainsWithOptions(request, runtime);\n    }\n    async describeCdnDeliverListWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.deliverId)) {\n            query[\"DeliverId\"] = request.deliverId;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDeliverList\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDeliverListResponse({}));\n    }\n    async describeCdnDeliverList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDeliverListWithOptions(request, runtime);\n    }\n    async describeCdnDomainByCertificateWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.SSLPub)) {\n            query[\"SSLPub\"] = request.SSLPub;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDomainByCertificate\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDomainByCertificateResponse({}));\n    }\n    async describeCdnDomainByCertificate(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDomainByCertificateWithOptions(request, runtime);\n    }\n    async describeCdnDomainConfigsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configId)) {\n            query[\"ConfigId\"] = request.configId;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.functionNames)) {\n            query[\"FunctionNames\"] = request.functionNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDomainConfigs\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDomainConfigsResponse({}));\n    }\n    async describeCdnDomainConfigs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDomainConfigsWithOptions(request, runtime);\n    }\n    async describeCdnDomainDetailWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDomainDetail\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDomainDetailResponse({}));\n    }\n    async describeCdnDomainDetail(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDomainDetailWithOptions(request, runtime);\n    }\n    async describeCdnDomainLogsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDomainLogs\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDomainLogsResponse({}));\n    }\n    async describeCdnDomainLogs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDomainLogsWithOptions(request, runtime);\n    }\n    async describeCdnDomainStagingConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.functionNames)) {\n            query[\"FunctionNames\"] = request.functionNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnDomainStagingConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnDomainStagingConfigResponse({}));\n    }\n    async describeCdnDomainStagingConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnDomainStagingConfigWithOptions(request, runtime);\n    }\n    async describeCdnHttpsDomainListWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.keyword)) {\n            query[\"Keyword\"] = request.keyword;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnHttpsDomainList\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnHttpsDomainListResponse({}));\n    }\n    async describeCdnHttpsDomainList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnHttpsDomainListWithOptions(request, runtime);\n    }\n    async describeCdnOrderCommodityCodeWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.commodityCode)) {\n            query[\"CommodityCode\"] = request.commodityCode;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnOrderCommodityCode\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnOrderCommodityCodeResponse({}));\n    }\n    async describeCdnOrderCommodityCode(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnOrderCommodityCodeWithOptions(request, runtime);\n    }\n    async describeCdnRegionAndIspWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnRegionAndIsp\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnRegionAndIspResponse({}));\n    }\n    async describeCdnRegionAndIsp(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnRegionAndIspWithOptions(request, runtime);\n    }\n    async describeCdnReportWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.area)) {\n            query[\"Area\"] = request.area;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.httpCode)) {\n            query[\"HttpCode\"] = request.httpCode;\n        }\n        if (!tea_util_1.default.isUnset(request.isOverseas)) {\n            query[\"IsOverseas\"] = request.isOverseas;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.reportId)) {\n            query[\"ReportId\"] = request.reportId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnReport\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnReportResponse({}));\n    }\n    async describeCdnReport(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnReportWithOptions(request, runtime);\n    }\n    async describeCdnReportListWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.reportId)) {\n            query[\"ReportId\"] = request.reportId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnReportList\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnReportListResponse({}));\n    }\n    async describeCdnReportList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnReportListWithOptions(request, runtime);\n    }\n    async describeCdnSMCertificateDetailWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certIdentifier)) {\n            query[\"CertIdentifier\"] = request.certIdentifier;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnSMCertificateDetail\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnSMCertificateDetailResponse({}));\n    }\n    async describeCdnSMCertificateDetail(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnSMCertificateDetailWithOptions(request, runtime);\n    }\n    async describeCdnSMCertificateListWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnSMCertificateList\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnSMCertificateListResponse({}));\n    }\n    async describeCdnSMCertificateList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnSMCertificateListWithOptions(request, runtime);\n    }\n    async describeCdnServiceWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnService\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnServiceResponse({}));\n    }\n    async describeCdnService(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnServiceWithOptions(request, runtime);\n    }\n    async describeCdnSubListWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnSubList\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnSubListResponse({}));\n    }\n    async describeCdnSubList(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnSubListWithOptions(request, runtime);\n    }\n    async describeCdnUserBillHistoryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserBillHistory\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserBillHistoryResponse({}));\n    }\n    async describeCdnUserBillHistory(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserBillHistoryWithOptions(request, runtime);\n    }\n    async describeCdnUserBillPredictionWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.area)) {\n            query[\"Area\"] = request.area;\n        }\n        if (!tea_util_1.default.isUnset(request.dimension)) {\n            query[\"Dimension\"] = request.dimension;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserBillPrediction\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserBillPredictionResponse({}));\n    }\n    async describeCdnUserBillPrediction(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserBillPredictionWithOptions(request, runtime);\n    }\n    async describeCdnUserBillTypeWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserBillType\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserBillTypeResponse({}));\n    }\n    async describeCdnUserBillType(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserBillTypeWithOptions(request, runtime);\n    }\n    async describeCdnUserConfigsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.functionName)) {\n            query[\"FunctionName\"] = request.functionName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserConfigs\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserConfigsResponse({}));\n    }\n    async describeCdnUserConfigs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserConfigsWithOptions(request, runtime);\n    }\n    async describeCdnUserDomainsByFuncWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.funcId)) {\n            query[\"FuncId\"] = request.funcId;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserDomainsByFunc\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserDomainsByFuncResponse({}));\n    }\n    async describeCdnUserDomainsByFunc(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserDomainsByFuncWithOptions(request, runtime);\n    }\n    async describeCdnUserQuotaWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserQuota\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserQuotaResponse({}));\n    }\n    async describeCdnUserQuota(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserQuotaWithOptions(request, runtime);\n    }\n    async describeCdnUserResourcePackageWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.status)) {\n            query[\"Status\"] = request.status;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnUserResourcePackage\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnUserResourcePackageResponse({}));\n    }\n    async describeCdnUserResourcePackage(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnUserResourcePackageWithOptions(request, runtime);\n    }\n    async describeCdnWafDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.regionId)) {\n            query[\"RegionId\"] = request.regionId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCdnWafDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCdnWafDomainResponse({}));\n    }\n    async describeCdnWafDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCdnWafDomainWithOptions(request, runtime);\n    }\n    async describeCertificateInfoByIDWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCertificateInfoByID\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCertificateInfoByIDResponse({}));\n    }\n    async describeCertificateInfoByID(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCertificateInfoByIDWithOptions(request, runtime);\n    }\n    async describeConfigGroupDetailWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configGroupId)) {\n            query[\"ConfigGroupId\"] = request.configGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.configGroupName)) {\n            query[\"ConfigGroupName\"] = request.configGroupName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeConfigGroupDetail\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeConfigGroupDetailResponse({}));\n    }\n    async describeConfigGroupDetail(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeConfigGroupDetailWithOptions(request, runtime);\n    }\n    async describeConfigOfVersionWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.functionId)) {\n            query[\"FunctionId\"] = request.functionId;\n        }\n        if (!tea_util_1.default.isUnset(request.functionName)) {\n            query[\"FunctionName\"] = request.functionName;\n        }\n        if (!tea_util_1.default.isUnset(request.groupId)) {\n            query[\"GroupId\"] = request.groupId;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.versionId)) {\n            query[\"VersionId\"] = request.versionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeConfigOfVersion\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeConfigOfVersionResponse({}));\n    }\n    async describeConfigOfVersion(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeConfigOfVersionWithOptions(request, runtime);\n    }\n    async describeCustomLogConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeCustomLogConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCustomLogConfigResponse({}));\n    }\n    async describeCustomLogConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeCustomLogConfigWithOptions(request, runtime);\n    }\n    async describeDomainAverageResponseTimeWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.domainType)) {\n            query[\"DomainType\"] = request.domainType;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.timeMerge)) {\n            query[\"TimeMerge\"] = request.timeMerge;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainAverageResponseTime\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainAverageResponseTimeResponse({}));\n    }\n    async describeDomainAverageResponseTime(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainAverageResponseTimeWithOptions(request, runtime);\n    }\n    async describeDomainBpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainBpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainBpsDataResponse({}));\n    }\n    async describeDomainBpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainBpsDataWithOptions(request, runtime);\n    }\n    async describeDomainBpsDataByLayerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.layer)) {\n            query[\"Layer\"] = request.layer;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainBpsDataByLayer\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainBpsDataByLayerResponse({}));\n    }\n    async describeDomainBpsDataByLayer(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainBpsDataByLayerWithOptions(request, runtime);\n    }\n    async describeDomainBpsDataByTimeStampWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNames)) {\n            query[\"IspNames\"] = request.ispNames;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNames)) {\n            query[\"LocationNames\"] = request.locationNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.timePoint)) {\n            query[\"TimePoint\"] = request.timePoint;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainBpsDataByTimeStamp\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainBpsDataByTimeStampResponse({}));\n    }\n    async describeDomainBpsDataByTimeStamp(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainBpsDataByTimeStampWithOptions(request, runtime);\n    }\n    async describeDomainCcActivityLogWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.ruleName)) {\n            query[\"RuleName\"] = request.ruleName;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.triggerObject)) {\n            query[\"TriggerObject\"] = request.triggerObject;\n        }\n        if (!tea_util_1.default.isUnset(request.value)) {\n            query[\"Value\"] = request.value;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainCcActivityLog\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainCcActivityLogResponse({}));\n    }\n    async describeDomainCcActivityLog(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainCcActivityLogWithOptions(request, runtime);\n    }\n    async describeDomainCertificateInfoWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainCertificateInfo\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainCertificateInfoResponse({}));\n    }\n    async describeDomainCertificateInfo(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainCertificateInfoWithOptions(request, runtime);\n    }\n    async describeDomainCustomLogConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainCustomLogConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainCustomLogConfigResponse({}));\n    }\n    async describeDomainCustomLogConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainCustomLogConfigWithOptions(request, runtime);\n    }\n    async describeDomainDetailDataByLayerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainDetailDataByLayer\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainDetailDataByLayerResponse({}));\n    }\n    async describeDomainDetailDataByLayer(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainDetailDataByLayerWithOptions(request, runtime);\n    }\n    async describeDomainFileSizeProportionDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainFileSizeProportionData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainFileSizeProportionDataResponse({}));\n    }\n    async describeDomainFileSizeProportionData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainFileSizeProportionDataWithOptions(request, runtime);\n    }\n    async describeDomainHitRateDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainHitRateData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainHitRateDataResponse({}));\n    }\n    async describeDomainHitRateData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainHitRateDataWithOptions(request, runtime);\n    }\n    async describeDomainHttpCodeDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainHttpCodeData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainHttpCodeDataResponse({}));\n    }\n    async describeDomainHttpCodeData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainHttpCodeDataWithOptions(request, runtime);\n    }\n    async describeDomainHttpCodeDataByLayerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.layer)) {\n            query[\"Layer\"] = request.layer;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainHttpCodeDataByLayer\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainHttpCodeDataByLayerResponse({}));\n    }\n    async describeDomainHttpCodeDataByLayer(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainHttpCodeDataByLayerWithOptions(request, runtime);\n    }\n    async describeDomainISPDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainISPData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainISPDataResponse({}));\n    }\n    async describeDomainISPData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainISPDataWithOptions(request, runtime);\n    }\n    async describeDomainMax95BpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.cycle)) {\n            query[\"Cycle\"] = request.cycle;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.timePoint)) {\n            query[\"TimePoint\"] = request.timePoint;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainMax95BpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainMax95BpsDataResponse({}));\n    }\n    async describeDomainMax95BpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainMax95BpsDataWithOptions(request, runtime);\n    }\n    async describeDomainMultiUsageDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainMultiUsageData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainMultiUsageDataResponse({}));\n    }\n    async describeDomainMultiUsageData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainMultiUsageDataWithOptions(request, runtime);\n    }\n    async describeDomainNamesOfVersionWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageIndex)) {\n            query[\"PageIndex\"] = request.pageIndex;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.versionId)) {\n            query[\"VersionId\"] = request.versionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainNamesOfVersion\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainNamesOfVersionResponse({}));\n    }\n    async describeDomainNamesOfVersion(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainNamesOfVersionWithOptions(request, runtime);\n    }\n    async describeDomainPathDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainPathData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainPathDataResponse({}));\n    }\n    async describeDomainPathData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainPathDataWithOptions(request, runtime);\n    }\n    async describeDomainPvDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainPvData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainPvDataResponse({}));\n    }\n    async describeDomainPvData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainPvDataWithOptions(request, runtime);\n    }\n    async describeDomainQpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainQpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainQpsDataResponse({}));\n    }\n    async describeDomainQpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainQpsDataWithOptions(request, runtime);\n    }\n    async describeDomainQpsDataByLayerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.layer)) {\n            query[\"Layer\"] = request.layer;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainQpsDataByLayer\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainQpsDataByLayerResponse({}));\n    }\n    async describeDomainQpsDataByLayer(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainQpsDataByLayerWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeBpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeBpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeBpsDataResponse({}));\n    }\n    async describeDomainRealTimeBpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeBpsDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeByteHitRateDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeByteHitRateData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeByteHitRateDataResponse({}));\n    }\n    async describeDomainRealTimeByteHitRateData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeByteHitRateDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeDetailDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeDetailData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeDetailDataResponse({}));\n    }\n    async describeDomainRealTimeDetailData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeDetailDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeHttpCodeDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeHttpCodeData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeHttpCodeDataResponse({}));\n    }\n    async describeDomainRealTimeHttpCodeData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeHttpCodeDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeQpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeQpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeQpsDataResponse({}));\n    }\n    async describeDomainRealTimeQpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeQpsDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeReqHitRateDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeReqHitRateData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeReqHitRateDataResponse({}));\n    }\n    async describeDomainRealTimeReqHitRateData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeReqHitRateDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeSrcBpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeSrcBpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeSrcBpsDataResponse({}));\n    }\n    async describeDomainRealTimeSrcBpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeSrcBpsDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeSrcHttpCodeDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeSrcHttpCodeData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeSrcHttpCodeDataResponse({}));\n    }\n    async describeDomainRealTimeSrcHttpCodeData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeSrcHttpCodeDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeSrcTrafficDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeSrcTrafficData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeSrcTrafficDataResponse({}));\n    }\n    async describeDomainRealTimeSrcTrafficData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeSrcTrafficDataWithOptions(request, runtime);\n    }\n    async describeDomainRealTimeTrafficDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealTimeTrafficData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealTimeTrafficDataResponse({}));\n    }\n    async describeDomainRealTimeTrafficData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealTimeTrafficDataWithOptions(request, runtime);\n    }\n    async describeDomainRealtimeLogDeliveryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRealtimeLogDelivery\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRealtimeLogDeliveryResponse({}));\n    }\n    async describeDomainRealtimeLogDelivery(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRealtimeLogDeliveryWithOptions(request, runtime);\n    }\n    async describeDomainRegionDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainRegionData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainRegionDataResponse({}));\n    }\n    async describeDomainRegionData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainRegionDataWithOptions(request, runtime);\n    }\n    async describeDomainReqHitRateDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainReqHitRateData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainReqHitRateDataResponse({}));\n    }\n    async describeDomainReqHitRateData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainReqHitRateDataWithOptions(request, runtime);\n    }\n    async describeDomainSrcBpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainSrcBpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainSrcBpsDataResponse({}));\n    }\n    async describeDomainSrcBpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainSrcBpsDataWithOptions(request, runtime);\n    }\n    async describeDomainSrcHttpCodeDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainSrcHttpCodeData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainSrcHttpCodeDataResponse({}));\n    }\n    async describeDomainSrcHttpCodeData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainSrcHttpCodeDataWithOptions(request, runtime);\n    }\n    async describeDomainSrcQpsDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainSrcQpsData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainSrcQpsDataResponse({}));\n    }\n    async describeDomainSrcQpsData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainSrcQpsDataWithOptions(request, runtime);\n    }\n    async describeDomainSrcTopUrlVisitWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.sortBy)) {\n            query[\"SortBy\"] = request.sortBy;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainSrcTopUrlVisit\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainSrcTopUrlVisitResponse({}));\n    }\n    async describeDomainSrcTopUrlVisit(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainSrcTopUrlVisitWithOptions(request, runtime);\n    }\n    async describeDomainSrcTrafficDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainSrcTrafficData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainSrcTrafficDataResponse({}));\n    }\n    async describeDomainSrcTrafficData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainSrcTrafficDataWithOptions(request, runtime);\n    }\n    async describeDomainTopClientIpVisitWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.sortBy)) {\n            query[\"SortBy\"] = request.sortBy;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainTopClientIpVisit\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainTopClientIpVisitResponse({}));\n    }\n    async describeDomainTopClientIpVisit(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainTopClientIpVisitWithOptions(request, runtime);\n    }\n    async describeDomainTopReferVisitWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.percent)) {\n            query[\"Percent\"] = request.percent;\n        }\n        if (!tea_util_1.default.isUnset(request.sortBy)) {\n            query[\"SortBy\"] = request.sortBy;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainTopReferVisit\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainTopReferVisitResponse({}));\n    }\n    async describeDomainTopReferVisit(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainTopReferVisitWithOptions(request, runtime);\n    }\n    async describeDomainTopUrlVisitWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.sortBy)) {\n            query[\"SortBy\"] = request.sortBy;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainTopUrlVisit\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainTopUrlVisitResponse({}));\n    }\n    async describeDomainTopUrlVisit(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainTopUrlVisitWithOptions(request, runtime);\n    }\n    async describeDomainTrafficDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNameEn)) {\n            query[\"IspNameEn\"] = request.ispNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNameEn)) {\n            query[\"LocationNameEn\"] = request.locationNameEn;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainTrafficData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainTrafficDataResponse({}));\n    }\n    async describeDomainTrafficData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainTrafficDataWithOptions(request, runtime);\n    }\n    async describeDomainUsageDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.area)) {\n            query[\"Area\"] = request.area;\n        }\n        if (!tea_util_1.default.isUnset(request.dataProtocol)) {\n            query[\"DataProtocol\"] = request.dataProtocol;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.field)) {\n            query[\"Field\"] = request.field;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.type)) {\n            query[\"Type\"] = request.type;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainUsageData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainUsageDataResponse({}));\n    }\n    async describeDomainUsageData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainUsageDataWithOptions(request, runtime);\n    }\n    async describeDomainUvDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainUvData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainUvDataResponse({}));\n    }\n    async describeDomainUvData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainUvDataWithOptions(request, runtime);\n    }\n    async describeDomainsBySourceWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.sources)) {\n            query[\"Sources\"] = request.sources;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainsBySource\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainsBySourceResponse({}));\n    }\n    async describeDomainsBySource(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainsBySourceWithOptions(request, runtime);\n    }\n    async describeDomainsUsageByDayWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeDomainsUsageByDay\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDomainsUsageByDayResponse({}));\n    }\n    async describeDomainsUsageByDay(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeDomainsUsageByDayWithOptions(request, runtime);\n    }\n    async describeEsExceptionDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.ruleId)) {\n            query[\"RuleId\"] = request.ruleId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeEsExceptionData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEsExceptionDataResponse({}));\n    }\n    async describeEsExceptionData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeEsExceptionDataWithOptions(request, runtime);\n    }\n    async describeEsExecuteDataWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.ruleId)) {\n            query[\"RuleId\"] = request.ruleId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeEsExecuteData\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEsExecuteDataResponse({}));\n    }\n    async describeEsExecuteData(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeEsExecuteDataWithOptions(request, runtime);\n    }\n    async describeFCTriggerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeFCTrigger\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeFCTriggerResponse({}));\n    }\n    async describeFCTrigger(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeFCTriggerWithOptions(request, runtime);\n    }\n    async describeIllegalUrlExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.taskId)) {\n            query[\"TaskId\"] = request.taskId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeIllegalUrlExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeIllegalUrlExportTaskResponse({}));\n    }\n    async describeIllegalUrlExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeIllegalUrlExportTaskWithOptions(request, runtime);\n    }\n    async describeIpInfoWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.IP)) {\n            query[\"IP\"] = request.IP;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeIpInfo\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeIpInfoResponse({}));\n    }\n    async describeIpInfo(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeIpInfoWithOptions(request, runtime);\n    }\n    async describeIpStatusWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeIpStatus\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeIpStatusResponse({}));\n    }\n    async describeIpStatus(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeIpStatusWithOptions(request, runtime);\n    }\n    async describeL2VipsByDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeL2VipsByDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeL2VipsByDomainResponse({}));\n    }\n    async describeL2VipsByDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeL2VipsByDomainWithOptions(request, runtime);\n    }\n    async describeRangeDataByLocateAndIspServiceWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainNames)) {\n            query[\"DomainNames\"] = request.domainNames;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.ispNames)) {\n            query[\"IspNames\"] = request.ispNames;\n        }\n        if (!tea_util_1.default.isUnset(request.locationNames)) {\n            query[\"LocationNames\"] = request.locationNames;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeRangeDataByLocateAndIspService\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRangeDataByLocateAndIspServiceResponse({}));\n    }\n    async describeRangeDataByLocateAndIspService(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeRangeDataByLocateAndIspServiceWithOptions(request, runtime);\n    }\n    async describeRealtimeDeliveryAccWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.interval)) {\n            query[\"Interval\"] = request.interval;\n        }\n        if (!tea_util_1.default.isUnset(request.logStore)) {\n            query[\"LogStore\"] = request.logStore;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.project)) {\n            query[\"Project\"] = request.project;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeRealtimeDeliveryAcc\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRealtimeDeliveryAccResponse({}));\n    }\n    async describeRealtimeDeliveryAcc(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeRealtimeDeliveryAccWithOptions(request, runtime);\n    }\n    async describeRefreshQuotaWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeRefreshQuota\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRefreshQuotaResponse({}));\n    }\n    async describeRefreshQuota(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeRefreshQuotaWithOptions(request, runtime);\n    }\n    async describeRefreshTaskByIdWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.taskId)) {\n            query[\"TaskId\"] = request.taskId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeRefreshTaskById\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRefreshTaskByIdResponse({}));\n    }\n    async describeRefreshTaskById(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeRefreshTaskByIdWithOptions(request, runtime);\n    }\n    async describeRefreshTasksWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.objectPath)) {\n            query[\"ObjectPath\"] = request.objectPath;\n        }\n        if (!tea_util_1.default.isUnset(request.objectType)) {\n            query[\"ObjectType\"] = request.objectType;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        if (!tea_util_1.default.isUnset(request.status)) {\n            query[\"Status\"] = request.status;\n        }\n        if (!tea_util_1.default.isUnset(request.taskId)) {\n            query[\"TaskId\"] = request.taskId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeRefreshTasks\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRefreshTasksResponse({}));\n    }\n    async describeRefreshTasks(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeRefreshTasksWithOptions(request, runtime);\n    }\n    async describeStagingIpWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeStagingIp\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeStagingIpResponse({}));\n    }\n    async describeStagingIp(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeStagingIpWithOptions(request, runtime);\n    }\n    async describeTagResourcesWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceId)) {\n            query[\"ResourceId\"] = request.resourceId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceType)) {\n            query[\"ResourceType\"] = request.resourceType;\n        }\n        if (!tea_util_1.default.isUnset(request.tag)) {\n            query[\"Tag\"] = request.tag;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeTagResources\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTagResourcesResponse({}));\n    }\n    async describeTagResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeTagResourcesWithOptions(request, runtime);\n    }\n    async describeTopDomainsByFlowWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            query[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.limit)) {\n            query[\"Limit\"] = request.limit;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            query[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeTopDomainsByFlow\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTopDomainsByFlowResponse({}));\n    }\n    async describeTopDomainsByFlow(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeTopDomainsByFlowWithOptions(request, runtime);\n    }\n    async describeUserCertificateExpireCountWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserCertificateExpireCount\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserCertificateExpireCountResponse({}));\n    }\n    async describeUserCertificateExpireCount(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserCertificateExpireCountWithOptions(request, runtime);\n    }\n    async describeUserConfigsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.config)) {\n            query[\"Config\"] = request.config;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserConfigs\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserConfigsResponse({}));\n    }\n    async describeUserConfigs(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserConfigsWithOptions(request, runtime);\n    }\n    async describeUserDomainsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.cdnType)) {\n            query[\"CdnType\"] = request.cdnType;\n        }\n        if (!tea_util_1.default.isUnset(request.changeEndTime)) {\n            query[\"ChangeEndTime\"] = request.changeEndTime;\n        }\n        if (!tea_util_1.default.isUnset(request.changeStartTime)) {\n            query[\"ChangeStartTime\"] = request.changeStartTime;\n        }\n        if (!tea_util_1.default.isUnset(request.checkDomainShow)) {\n            query[\"CheckDomainShow\"] = request.checkDomainShow;\n        }\n        if (!tea_util_1.default.isUnset(request.coverage)) {\n            query[\"Coverage\"] = request.coverage;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.domainSearchType)) {\n            query[\"DomainSearchType\"] = request.domainSearchType;\n        }\n        if (!tea_util_1.default.isUnset(request.domainStatus)) {\n            query[\"DomainStatus\"] = request.domainStatus;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.source)) {\n            query[\"Source\"] = request.source;\n        }\n        if (!tea_util_1.default.isUnset(request.tag)) {\n            query[\"Tag\"] = request.tag;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserDomains\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserDomainsResponse({}));\n    }\n    async describeUserDomains(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserDomainsWithOptions(request, runtime);\n    }\n    async describeUserTagsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserTags\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserTagsResponse({}));\n    }\n    async describeUserTags(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserTagsWithOptions(request, runtime);\n    }\n    async describeUserUsageDataExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserUsageDataExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserUsageDataExportTaskResponse({}));\n    }\n    async describeUserUsageDataExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserUsageDataExportTaskWithOptions(request, runtime);\n    }\n    async describeUserUsageDetailDataExportTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageNumber)) {\n            query[\"PageNumber\"] = request.pageNumber;\n        }\n        if (!tea_util_1.default.isUnset(request.pageSize)) {\n            query[\"PageSize\"] = request.pageSize;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserUsageDetailDataExportTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserUsageDetailDataExportTaskResponse({}));\n    }\n    async describeUserUsageDetailDataExportTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserUsageDetailDataExportTaskWithOptions(request, runtime);\n    }\n    async describeUserVipsByDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeUserVipsByDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserVipsByDomainResponse({}));\n    }\n    async describeUserVipsByDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeUserVipsByDomainWithOptions(request, runtime);\n    }\n    async describeVerifyContentWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DescribeVerifyContent\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DescribeVerifyContentResponse({}));\n    }\n    async describeVerifyContent(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.describeVerifyContentWithOptions(request, runtime);\n    }\n    async disableRealtimeLogDeliveryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"DisableRealtimeLogDelivery\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new DisableRealtimeLogDeliveryResponse({}));\n    }\n    async disableRealtimeLogDelivery(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.disableRealtimeLogDeliveryWithOptions(request, runtime);\n    }\n    async enableRealtimeLogDeliveryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"EnableRealtimeLogDelivery\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new EnableRealtimeLogDeliveryResponse({}));\n    }\n    async enableRealtimeLogDelivery(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.enableRealtimeLogDeliveryWithOptions(request, runtime);\n    }\n    async listDomainsByLogConfigIdWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListDomainsByLogConfigId\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListDomainsByLogConfigIdResponse({}));\n    }\n    async listDomainsByLogConfigId(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.listDomainsByLogConfigIdWithOptions(request, runtime);\n    }\n    async listFCTriggerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListFCTrigger\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListFCTriggerResponse({}));\n    }\n    async listFCTrigger(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.listFCTriggerWithOptions(request, runtime);\n    }\n    async listRealtimeLogDeliveryDomainsWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListRealtimeLogDeliveryDomains\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListRealtimeLogDeliveryDomainsResponse({}));\n    }\n    async listRealtimeLogDeliveryDomains(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.listRealtimeLogDeliveryDomainsWithOptions(request, runtime);\n    }\n    async listRealtimeLogDeliveryInfosWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListRealtimeLogDeliveryInfos\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListRealtimeLogDeliveryInfosResponse({}));\n    }\n    async listRealtimeLogDeliveryInfos(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.listRealtimeLogDeliveryInfosWithOptions(request, runtime);\n    }\n    async listUserCustomLogConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ListUserCustomLogConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ListUserCustomLogConfigResponse({}));\n    }\n    async listUserCustomLogConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.listUserCustomLogConfigWithOptions(request, runtime);\n    }\n    async modifyCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {\n            query[\"ResourceGroupId\"] = request.resourceGroupId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.sources)) {\n            query[\"Sources\"] = request.sources;\n        }\n        if (!tea_util_1.default.isUnset(request.topLevelDomain)) {\n            query[\"TopLevelDomain\"] = request.topLevelDomain;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ModifyCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ModifyCdnDomainResponse({}));\n    }\n    async modifyCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.modifyCdnDomainWithOptions(request, runtime);\n    }\n    async modifyCdnDomainSchdmByPropertyWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.property)) {\n            query[\"Property\"] = request.property;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ModifyCdnDomainSchdmByProperty\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ModifyCdnDomainSchdmByPropertyResponse({}));\n    }\n    async modifyCdnDomainSchdmByProperty(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.modifyCdnDomainSchdmByPropertyWithOptions(request, runtime);\n    }\n    async modifyRealtimeLogDeliveryWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ModifyRealtimeLogDelivery\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ModifyRealtimeLogDeliveryResponse({}));\n    }\n    async modifyRealtimeLogDelivery(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.modifyRealtimeLogDeliveryWithOptions(request, runtime);\n    }\n    async modifyUserCustomLogConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"ModifyUserCustomLogConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"GET\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new ModifyUserCustomLogConfigResponse({}));\n    }\n    async modifyUserCustomLogConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.modifyUserCustomLogConfigWithOptions(request, runtime);\n    }\n    async openCdnServiceWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.internetChargeType)) {\n            query[\"InternetChargeType\"] = request.internetChargeType;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"OpenCdnService\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new OpenCdnServiceResponse({}));\n    }\n    async openCdnService(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.openCdnServiceWithOptions(request, runtime);\n    }\n    async publishStagingConfigToProductionWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"PublishStagingConfigToProduction\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new PublishStagingConfigToProductionResponse({}));\n    }\n    async publishStagingConfigToProduction(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.publishStagingConfigToProductionWithOptions(request, runtime);\n    }\n    async pushObjectCacheWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.area)) {\n            query[\"Area\"] = request.area;\n        }\n        if (!tea_util_1.default.isUnset(request.l2Preload)) {\n            query[\"L2Preload\"] = request.l2Preload;\n        }\n        if (!tea_util_1.default.isUnset(request.objectPath)) {\n            query[\"ObjectPath\"] = request.objectPath;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"PushObjectCache\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new PushObjectCacheResponse({}));\n    }\n    async pushObjectCache(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.pushObjectCacheWithOptions(request, runtime);\n    }\n    async refreshObjectCachesWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.objectPath)) {\n            query[\"ObjectPath\"] = request.objectPath;\n        }\n        if (!tea_util_1.default.isUnset(request.objectType)) {\n            query[\"ObjectType\"] = request.objectType;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RefreshObjectCaches\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RefreshObjectCachesResponse({}));\n    }\n    async refreshObjectCaches(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.refreshObjectCachesWithOptions(request, runtime);\n    }\n    async rollbackStagingConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"RollbackStagingConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new RollbackStagingConfigResponse({}));\n    }\n    async rollbackStagingConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.rollbackStagingConfigWithOptions(request, runtime);\n    }\n    async setCdnDomainCSRCertificateWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.serverCertificate)) {\n            query[\"ServerCertificate\"] = request.serverCertificate;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetCdnDomainCSRCertificate\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetCdnDomainCSRCertificateResponse({}));\n    }\n    async setCdnDomainCSRCertificate(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setCdnDomainCSRCertificateWithOptions(request, runtime);\n    }\n    async setCdnDomainSMCertificateWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certIdentifier)) {\n            query[\"CertIdentifier\"] = request.certIdentifier;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.SSLProtocol)) {\n            query[\"SSLProtocol\"] = request.SSLProtocol;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetCdnDomainSMCertificate\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetCdnDomainSMCertificateResponse({}));\n    }\n    async setCdnDomainSMCertificate(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setCdnDomainSMCertificateWithOptions(request, runtime);\n    }\n    async setCdnDomainStagingConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.functions)) {\n            query[\"Functions\"] = request.functions;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetCdnDomainStagingConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetCdnDomainStagingConfigResponse({}));\n    }\n    async setCdnDomainStagingConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setCdnDomainStagingConfigWithOptions(request, runtime);\n    }\n    async setConfigOfVersionWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configId)) {\n            query[\"ConfigId\"] = request.configId;\n        }\n        if (!tea_util_1.default.isUnset(request.functionArgs)) {\n            query[\"FunctionArgs\"] = request.functionArgs;\n        }\n        if (!tea_util_1.default.isUnset(request.functionId)) {\n            query[\"FunctionId\"] = request.functionId;\n        }\n        if (!tea_util_1.default.isUnset(request.functionMatches)) {\n            query[\"FunctionMatches\"] = request.functionMatches;\n        }\n        if (!tea_util_1.default.isUnset(request.functionName)) {\n            query[\"FunctionName\"] = request.functionName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerAccount)) {\n            query[\"OwnerAccount\"] = request.ownerAccount;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.versionId)) {\n            query[\"VersionId\"] = request.versionId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetConfigOfVersion\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetConfigOfVersionResponse({}));\n    }\n    async setConfigOfVersion(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setConfigOfVersionWithOptions(request, runtime);\n    }\n    async setDomainGreenManagerConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.enable)) {\n            query[\"Enable\"] = request.enable;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetDomainGreenManagerConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetDomainGreenManagerConfigResponse({}));\n    }\n    async setDomainGreenManagerConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setDomainGreenManagerConfigWithOptions(request, runtime);\n    }\n    async setDomainServerCertificateWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.certName)) {\n            query[\"CertName\"] = request.certName;\n        }\n        if (!tea_util_1.default.isUnset(request.certType)) {\n            query[\"CertType\"] = request.certType;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.forceSet)) {\n            query[\"ForceSet\"] = request.forceSet;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.privateKey)) {\n            query[\"PrivateKey\"] = request.privateKey;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.serverCertificate)) {\n            query[\"ServerCertificate\"] = request.serverCertificate;\n        }\n        if (!tea_util_1.default.isUnset(request.serverCertificateStatus)) {\n            query[\"ServerCertificateStatus\"] = request.serverCertificateStatus;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetDomainServerCertificate\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetDomainServerCertificateResponse({}));\n    }\n    async setDomainServerCertificate(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setDomainServerCertificateWithOptions(request, runtime);\n    }\n    async setErrorPageConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.customPageUrl)) {\n            query[\"CustomPageUrl\"] = request.customPageUrl;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageType)) {\n            query[\"PageType\"] = request.pageType;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetErrorPageConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetErrorPageConfigResponse({}));\n    }\n    async setErrorPageConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setErrorPageConfigWithOptions(request, runtime);\n    }\n    async setHttpErrorPageConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configId)) {\n            query[\"ConfigId\"] = request.configId;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.errorCode)) {\n            query[\"ErrorCode\"] = request.errorCode;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.pageUrl)) {\n            query[\"PageUrl\"] = request.pageUrl;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetHttpErrorPageConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetHttpErrorPageConfigResponse({}));\n    }\n    async setHttpErrorPageConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setHttpErrorPageConfigWithOptions(request, runtime);\n    }\n    async setReqHeaderConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.configId)) {\n            query[\"ConfigId\"] = request.configId;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.key)) {\n            query[\"Key\"] = request.key;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        if (!tea_util_1.default.isUnset(request.value)) {\n            query[\"Value\"] = request.value;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetReqHeaderConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetReqHeaderConfigResponse({}));\n    }\n    async setReqHeaderConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setReqHeaderConfigWithOptions(request, runtime);\n    }\n    async setUserGreenManagerConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.quota)) {\n            query[\"Quota\"] = request.quota;\n        }\n        if (!tea_util_1.default.isUnset(request.ratio)) {\n            query[\"Ratio\"] = request.ratio;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetUserGreenManagerConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetUserGreenManagerConfigResponse({}));\n    }\n    async setUserGreenManagerConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setUserGreenManagerConfigWithOptions(request, runtime);\n    }\n    async setWaitingRoomConfigWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.allowPct)) {\n            query[\"AllowPct\"] = request.allowPct;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.gapTime)) {\n            query[\"GapTime\"] = request.gapTime;\n        }\n        if (!tea_util_1.default.isUnset(request.maxTimeWait)) {\n            query[\"MaxTimeWait\"] = request.maxTimeWait;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.waitUri)) {\n            query[\"WaitUri\"] = request.waitUri;\n        }\n        if (!tea_util_1.default.isUnset(request.waitUrl)) {\n            query[\"WaitUrl\"] = request.waitUrl;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"SetWaitingRoomConfig\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new SetWaitingRoomConfigResponse({}));\n    }\n    async setWaitingRoomConfig(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.setWaitingRoomConfigWithOptions(request, runtime);\n    }\n    async startCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"StartCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new StartCdnDomainResponse({}));\n    }\n    async startCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.startCdnDomainWithOptions(request, runtime);\n    }\n    async stopCdnDomainWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.securityToken)) {\n            query[\"SecurityToken\"] = request.securityToken;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"StopCdnDomain\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new StopCdnDomainResponse({}));\n    }\n    async stopCdnDomain(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.stopCdnDomainWithOptions(request, runtime);\n    }\n    async tagResourcesWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceId)) {\n            query[\"ResourceId\"] = request.resourceId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceType)) {\n            query[\"ResourceType\"] = request.resourceType;\n        }\n        if (!tea_util_1.default.isUnset(request.tag)) {\n            query[\"Tag\"] = request.tag;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"TagResources\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new TagResourcesResponse({}));\n    }\n    async tagResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.tagResourcesWithOptions(request, runtime);\n    }\n    async untagResourcesWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.all)) {\n            query[\"All\"] = request.all;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceId)) {\n            query[\"ResourceId\"] = request.resourceId;\n        }\n        if (!tea_util_1.default.isUnset(request.resourceType)) {\n            query[\"ResourceType\"] = request.resourceType;\n        }\n        if (!tea_util_1.default.isUnset(request.tagKey)) {\n            query[\"TagKey\"] = request.tagKey;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UntagResources\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));\n    }\n    async untagResources(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.untagResourcesWithOptions(request, runtime);\n    }\n    async updateCdnDeliverTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.deliver)) {\n            body[\"Deliver\"] = request.deliver;\n        }\n        if (!tea_util_1.default.isUnset(request.deliverId)) {\n            body[\"DeliverId\"] = request.deliverId;\n        }\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            body[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.name)) {\n            body[\"Name\"] = request.name;\n        }\n        if (!tea_util_1.default.isUnset(request.reports)) {\n            body[\"Reports\"] = request.reports;\n        }\n        if (!tea_util_1.default.isUnset(request.schedule)) {\n            body[\"Schedule\"] = request.schedule;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateCdnDeliverTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateCdnDeliverTaskResponse({}));\n    }\n    async updateCdnDeliverTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.updateCdnDeliverTaskWithOptions(request, runtime);\n    }\n    async updateCdnSubTaskWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            body[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.endTime)) {\n            body[\"EndTime\"] = request.endTime;\n        }\n        if (!tea_util_1.default.isUnset(request.reportIds)) {\n            body[\"ReportIds\"] = request.reportIds;\n        }\n        if (!tea_util_1.default.isUnset(request.startTime)) {\n            body[\"StartTime\"] = request.startTime;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateCdnSubTask\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateCdnSubTaskResponse({}));\n    }\n    async updateCdnSubTask(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.updateCdnSubTaskWithOptions(request, runtime);\n    }\n    async updateFCTriggerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.triggerARN)) {\n            query[\"TriggerARN\"] = request.triggerARN;\n        }\n        let body = {};\n        if (!tea_util_1.default.isUnset(request.functionARN)) {\n            body[\"FunctionARN\"] = request.functionARN;\n        }\n        if (!tea_util_1.default.isUnset(request.notes)) {\n            body[\"Notes\"] = request.notes;\n        }\n        if (!tea_util_1.default.isUnset(request.roleARN)) {\n            body[\"RoleARN\"] = request.roleARN;\n        }\n        if (!tea_util_1.default.isUnset(request.sourceARN)) {\n            body[\"SourceARN\"] = request.sourceARN;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n            body: openapi_util_1.default.parseToMap(body),\n        });\n        let params = new $OpenApi.Params({\n            action: \"UpdateFCTrigger\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new UpdateFCTriggerResponse({}));\n    }\n    async updateFCTrigger(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.updateFCTriggerWithOptions(request, runtime);\n    }\n    async verifyDomainOwnerWithOptions(request, runtime) {\n        tea_util_1.default.validateModel(request);\n        let query = {};\n        if (!tea_util_1.default.isUnset(request.domainName)) {\n            query[\"DomainName\"] = request.domainName;\n        }\n        if (!tea_util_1.default.isUnset(request.ownerId)) {\n            query[\"OwnerId\"] = request.ownerId;\n        }\n        if (!tea_util_1.default.isUnset(request.verifyType)) {\n            query[\"VerifyType\"] = request.verifyType;\n        }\n        let req = new $OpenApi.OpenApiRequest({\n            query: openapi_util_1.default.query(query),\n        });\n        let params = new $OpenApi.Params({\n            action: \"VerifyDomainOwner\",\n            version: \"2018-05-10\",\n            protocol: \"HTTPS\",\n            pathname: \"/\",\n            method: \"POST\",\n            authType: \"AK\",\n            style: \"RPC\",\n            reqBodyType: \"formData\",\n            bodyType: \"json\",\n        });\n        return $tea.cast(await this.callApi(params, req, runtime), new VerifyDomainOwnerResponse({}));\n    }\n    async verifyDomainOwner(request) {\n        let runtime = new $Util.RuntimeOptions({});\n        return await this.verifyDomainOwnerWithOptions(request, runtime);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass AccessKeyCredential extends default_credential_1.default {\n    constructor(accessKeyId, accessKeySecret) {\n        if (!accessKeyId) {\n            throw new Error('Missing required accessKeyId option in config for access_key');\n        }\n        if (!accessKeySecret) {\n            throw new Error('Missing required accessKeySecret option in config for access_key');\n        }\n        const conf = new config_1.default({\n            type: 'access_key',\n            accessKeyId,\n            accessKeySecret\n        });\n        super(conf);\n    }\n}\nexports.default = AccessKeyCredential;\n//# sourceMappingURL=access_key_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass BearerTokenCredential extends default_credential_1.default {\n    constructor(bearerToken) {\n        if (!bearerToken) {\n            throw new Error('Missing required bearerToken option in config for bearer');\n        }\n        const conf = new config_1.default({\n            type: 'bearer'\n        });\n        super(conf);\n        this.bearerToken = bearerToken;\n    }\n}\nexports.default = BearerTokenCredential;\n//# sourceMappingURL=bearer_token_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Config = void 0;\nconst access_key_credential_1 = __importDefault(require(\"./access_key_credential\"));\nconst sts_token_credential_1 = __importDefault(require(\"./sts_token_credential\"));\nconst ecs_ram_role_credential_1 = __importDefault(require(\"./ecs_ram_role_credential\"));\nconst ram_role_arn_credential_1 = __importDefault(require(\"./ram_role_arn_credential\"));\nconst oidc_role_arn_credential_1 = __importDefault(require(\"./oidc_role_arn_credential\"));\nconst rsa_key_pair_credential_1 = __importDefault(require(\"./rsa_key_pair_credential\"));\nconst bearer_token_credential_1 = __importDefault(require(\"./bearer_token_credential\"));\nconst DefaultProvider = __importStar(require(\"./provider/provider_chain\"));\nconst config_1 = __importDefault(require(\"./config\"));\nexports.Config = config_1.default;\nconst uri_credential_1 = __importDefault(require(\"./uri_credential\"));\nclass Credential {\n    constructor(config = null, runtime = {}) {\n        this.load(config, runtime);\n    }\n    getAccessKeyId() {\n        return this.credential.getAccessKeyId();\n    }\n    getAccessKeySecret() {\n        return this.credential.getAccessKeySecret();\n    }\n    getSecurityToken() {\n        return this.credential.getSecurityToken();\n    }\n    getBearerToken() {\n        return this.credential.getBearerToken();\n    }\n    getType() {\n        return this.credential.getType();\n    }\n    load(config, runtime) {\n        if (!config) {\n            this.credential = DefaultProvider.getCredentials();\n            return;\n        }\n        if (!config.type) {\n            throw new Error('Missing required type option');\n        }\n        switch (config.type) {\n            case 'access_key':\n                this.credential = new access_key_credential_1.default(config.accessKeyId, config.accessKeySecret);\n                break;\n            case 'sts':\n                this.credential = new sts_token_credential_1.default(config.accessKeyId, config.accessKeySecret, config.securityToken);\n                break;\n            case 'ecs_ram_role':\n                this.credential = new ecs_ram_role_credential_1.default(config.roleName);\n                break;\n            case 'ram_role_arn':\n                this.credential = new ram_role_arn_credential_1.default(config, runtime);\n                break;\n            case 'oidc_role_arn':\n                this.credential = new oidc_role_arn_credential_1.default(config, runtime);\n                break;\n            case 'rsa_key_pair':\n                this.credential = new rsa_key_pair_credential_1.default(config.publicKeyId, config.privateKeyFile);\n                break;\n            case 'bearer':\n                this.credential = new bearer_token_credential_1.default(config.bearerToken);\n                break;\n            case 'credentials_uri':\n                this.credential = new uri_credential_1.default(config.credentialsURI);\n                break;\n            default:\n                throw new Error('Invalid type option, support: access_key, sts, ecs_ram_role, ram_role_arn, rsa_key_pair, credentials_uri');\n        }\n    }\n}\nexports.default = Credential;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass Config extends $tea.Model {\n    constructor(config) {\n        super(config);\n    }\n    static names() {\n        return {\n            accessKeyId: 'accessKeyId',\n            accessKeySecret: 'accessKeySecret',\n            securityToken: 'securityToken',\n            bearerToken: 'bearerToken',\n            durationSeconds: 'durationSeconds',\n            roleArn: 'roleArn',\n            policy: 'policy',\n            roleSessionExpiration: 'roleSessionExpiration',\n            roleSessionName: 'roleSessionName',\n            publicKeyId: 'publicKeyId',\n            privateKeyFile: 'privateKeyFile',\n            roleName: 'roleName',\n            credentialsURI: 'credentialsURI',\n            oidcProviderArn: 'oidcProviderArn',\n            oidcTokenFilePath: 'oidcTokenFilePath',\n            type: 'type',\n        };\n    }\n    static types() {\n        return {\n            accessKeyId: 'string',\n            accessKeySecret: 'string',\n            securityToken: 'string',\n            bearerToken: 'string',\n            durationSeconds: 'number',\n            roleArn: 'string',\n            policy: 'string',\n            roleSessionExpiration: 'number',\n            roleSessionName: 'string',\n            publicKeyId: 'string',\n            privateKeyFile: 'string',\n            roleName: 'string',\n            credentialsURI: 'string',\n            oidcProviderArn: 'string',\n            oidcTokenFilePath: 'string',\n            type: 'string',\n        };\n    }\n}\nexports.default = Config;\n//# sourceMappingURL=config.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DefaultCredential {\n    constructor(config) {\n        this.accessKeyId = config.accessKeyId || '';\n        this.accessKeySecret = config.accessKeySecret || '';\n        this.securityToken = config.securityToken || '';\n        this.bearerToken = config.bearerToken || '';\n        this.type = config.type || '';\n    }\n    async getAccessKeyId() {\n        return this.accessKeyId;\n    }\n    async getAccessKeySecret() {\n        return this.accessKeySecret;\n    }\n    async getSecurityToken() {\n        return this.securityToken;\n    }\n    getBearerToken() {\n        return this.bearerToken;\n    }\n    getType() {\n        return this.type;\n    }\n}\nexports.default = DefaultCredential;\n//# sourceMappingURL=default_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst httpx_1 = __importDefault(require(\"httpx\"));\nconst config_1 = __importDefault(require(\"./config\"));\nconst SECURITY_CRED_URL = 'http://100.100.100.200/latest/meta-data/ram/security-credentials/';\nclass EcsRamRoleCredential extends session_credential_1.default {\n    constructor(roleName = '', runtime = {}) {\n        const conf = new config_1.default({\n            type: 'ecs_ram_role',\n        });\n        super(conf);\n        this.roleName = roleName;\n        this.runtime = runtime;\n        this.sessionCredential = null;\n    }\n    async getBody(url) {\n        const response = await httpx_1.default.request(url, {});\n        return (await httpx_1.default.read(response, 'utf8'));\n    }\n    async updateCredential() {\n        const roleName = await this.getRoleName();\n        const url = SECURITY_CRED_URL + roleName;\n        const body = await this.getBody(url);\n        const json = JSON.parse(body);\n        this.sessionCredential = {\n            AccessKeyId: json.AccessKeyId,\n            AccessKeySecret: json.AccessKeySecret,\n            Expiration: json.Expiration,\n            SecurityToken: json.SecurityToken,\n        };\n    }\n    async getRoleName() {\n        if (this.roleName && this.roleName.length) {\n            return this.roleName;\n        }\n        return await this.getBody(SECURITY_CRED_URL);\n    }\n}\nexports.default = EcsRamRoleCredential;\n//# sourceMappingURL=ecs_ram_role_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst http_1 = require(\"./util/http\");\nconst config_1 = __importDefault(require(\"./config\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nclass OidcRoleArnCredential extends session_credential_1.default {\n    constructor(config, runtime = {}) {\n        if (!config.roleArn) {\n            throw new Error('Missing required roleArn option in config for oidc_role_arn');\n        }\n        if (!config.oidcProviderArn) {\n            throw new Error('Missing required oidcProviderArn option in config for oidc_role_arn');\n        }\n        if (!config.oidcTokenFilePath) {\n            config.oidcTokenFilePath = process.env['ALIBABA_CLOUD_OIDC_TOKEN_FILE'];\n            if (!config.oidcTokenFilePath) {\n                throw new Error('oidcTokenFilePath is not exists and env ALIBABA_CLOUD_OIDC_TOKEN_FILE is null.');\n            }\n        }\n        const conf = new config_1.default({\n            type: 'oidc_role_arn',\n            accessKeyId: config.accessKeyId,\n            accessKeySecret: config.accessKeySecret\n        });\n        super(conf);\n        this.oidcTokenFilePath = config.oidcTokenFilePath;\n        this.roleArn = config.roleArn;\n        this.policy = config.policy;\n        this.oidcProviderArn = config.oidcProviderArn;\n        this.durationSeconds = config.roleSessionExpiration || 3600;\n        this.roleSessionName = config.roleSessionName || 'role_session_name';\n        runtime.method = 'POST';\n        this.runtime = runtime;\n        this.host = 'https://sts.aliyuncs.com';\n    }\n    getOdicToken(oidcTokenFilePath) {\n        if (!fs_1.default.existsSync(oidcTokenFilePath)) {\n            throw new Error(`oidcTokenFilePath ${oidcTokenFilePath}  is not exists.`);\n        }\n        let oidcToken = null;\n        try {\n            oidcToken = fs_1.default.readFileSync(oidcTokenFilePath, 'utf-8');\n        }\n        catch (err) {\n            throw new Error(`oidcTokenFilePath ${oidcTokenFilePath} cannot be read.`);\n        }\n        return oidcToken;\n    }\n    async updateCredential() {\n        const oidcToken = this.getOdicToken(this.oidcTokenFilePath);\n        const params = {\n            Action: 'AssumeRoleWithOIDC',\n            RoleArn: this.roleArn,\n            OIDCProviderArn: this.oidcProviderArn,\n            OIDCToken: oidcToken,\n            DurationSeconds: this.durationSeconds,\n            RoleSessionName: this.roleSessionName\n        };\n        if (this.policy) {\n            params.policy = this.policy;\n        }\n        const json = await http_1.request(this.host, params, this.runtime, this.accessKeySecret);\n        this.sessionCredential = json.Credentials;\n    }\n}\nexports.default = OidcRoleArnCredential;\n//# sourceMappingURL=oidc_role_arn_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri_credential_1 = __importDefault(require(\"../uri_credential\"));\nexports.default = {\n    getCredential() {\n        const credentialsURI = process.env.ALIBABA_CLOUD_CREDENTIALS_URI;\n        if (credentialsURI) {\n            return new uri_credential_1.default(credentialsURI);\n        }\n        return null;\n    }\n};\n//# sourceMappingURL=credentials_uri_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst access_key_credential_1 = __importDefault(require(\"../access_key_credential\"));\nexports.default = {\n    getCredential() {\n        const accessKeyId = process.env.ALIBABA_CLOUD_ACCESS_KEY_ID;\n        const accessKeySecret = process.env.ALIBABA_CLOUD_ACCESS_KEY_SECRET;\n        if (accessKeyId === undefined || accessKeySecret === undefined) {\n            return null;\n        }\n        if (accessKeyId === null || accessKeyId === '') {\n            throw new Error('Environment variable ALIBABA_CLOUD_ACCESS_KEY_ID cannot be empty');\n        }\n        if (accessKeySecret === null || accessKeySecret === '') {\n            throw new Error('Environment variable ALIBABA_CLOUD_ACCESS_KEY_SECRET cannot be empty');\n        }\n        return new access_key_credential_1.default(accessKeyId, accessKeySecret);\n    }\n};\n//# sourceMappingURL=environment_variable_credentials_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ecs_ram_role_credential_1 = __importDefault(require(\"../ecs_ram_role_credential\"));\nexports.default = {\n    getCredential() {\n        const roleName = process.env.ALIBABA_CLOUD_ECS_METADATA;\n        if (roleName && roleName.length) {\n            return new ecs_ram_role_credential_1.default(roleName);\n        }\n        return null;\n    }\n};\n//# sourceMappingURL=instance_ram_role_credentials_provider.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst access_key_credential_1 = __importDefault(require(\"../access_key_credential\"));\nconst sts_token_credential_1 = __importDefault(require(\"../sts_token_credential\"));\nconst ecs_ram_role_credential_1 = __importDefault(require(\"../ecs_ram_role_credential\"));\nconst ram_role_arn_credential_1 = __importDefault(require(\"../ram_role_arn_credential\"));\nconst rsa_key_pair_credential_1 = __importDefault(require(\"../rsa_key_pair_credential\"));\nconst bearer_token_credential_1 = __importDefault(require(\"../bearer_token_credential\"));\nconst utils = __importStar(require(\"../util/utils\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst config_1 = __importDefault(require(\"../config\"));\nconst DEFAULT_PATH = process.env.HOME + '/.alibabacloud/credentials';\nexports.default = {\n    getCredential(credentialName = 'default') {\n        let fileContent = null;\n        const credentialFile = process.env.ALIBABA_CLOUD_CREDENTIALS_FILE;\n        if (credentialFile === undefined) {\n            if (fs_1.default.existsSync(DEFAULT_PATH)) {\n                const content = utils.parseFile(DEFAULT_PATH, true);\n                if (content) {\n                    fileContent = content;\n                }\n            }\n        }\n        else {\n            if (credentialFile === null || credentialFile === '') {\n                throw new Error('Environment variable credentialFile cannot be empty');\n            }\n            if (!fs_1.default.existsSync(credentialFile)) {\n                throw new Error(`credentialFile ${credentialFile} cannot be empty`);\n            }\n            fileContent = utils.parseFile(credentialFile);\n        }\n        if (!fileContent) {\n            return null;\n        }\n        const config = fileContent[credentialName] || {};\n        if (!config.type) {\n            throw new Error('Missing required type option in credentialFile');\n        }\n        switch (config.type) {\n            case 'access_key':\n                return new access_key_credential_1.default(config.access_key_id, config.access_key_secret);\n            case 'sts':\n                return new sts_token_credential_1.default(config.access_key_id, config.access_key_secret, config.security_token);\n            case 'ecs_ram_role':\n                return new ecs_ram_role_credential_1.default(config.role_name);\n            case 'ram_role_arn': {\n                const conf = new config_1.default({\n                    roleArn: config.role_arn,\n                    accessKeyId: config.access_key_id,\n                    accessKeySecret: config.access_key_secret\n                });\n                return new ram_role_arn_credential_1.default(conf);\n            }\n            case 'rsa_key_pair':\n                return new rsa_key_pair_credential_1.default(config.public_key_id, config.private_key_file);\n            case 'bearer':\n                return new bearer_token_credential_1.default(config.bearer_token);\n            default:\n                throw new Error('Invalid type option, support: access_key, sts, ecs_ram_role, ram_role_arn, rsa_key_pair');\n        }\n    }\n};\n//# sourceMappingURL=profile_credentials_provider.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCredentials = void 0;\nconst environment_variable_credentials_provider_1 = __importDefault(require(\"./environment_variable_credentials_provider\"));\nconst profile_credentials_provider_1 = __importDefault(require(\"./profile_credentials_provider\"));\nconst instance_ram_role_credentials_provider_1 = __importDefault(require(\"./instance_ram_role_credentials_provider\"));\nconst credentials_uri_provider_1 = __importDefault(require(\"./credentials_uri_provider\"));\nconst defaultProviders = [\n    environment_variable_credentials_provider_1.default,\n    profile_credentials_provider_1.default,\n    instance_ram_role_credentials_provider_1.default,\n    credentials_uri_provider_1.default\n];\nfunction getCredentials(providers = null) {\n    const providerChain = providers || defaultProviders;\n    for (const provider of providerChain) {\n        const credential = provider.getCredential();\n        if (credential) {\n            return credential;\n        }\n    }\n    return null;\n}\nexports.getCredentials = getCredentials;\n//# sourceMappingURL=provider_chain.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst http_1 = require(\"./util/http\");\nconst config_1 = __importDefault(require(\"./config\"));\nclass RamRoleArnCredential extends session_credential_1.default {\n    constructor(config, runtime = {}) {\n        if (!config.accessKeyId) {\n            throw new Error('Missing required accessKeyId option in config for ram_role_arn');\n        }\n        if (!config.accessKeySecret) {\n            throw new Error('Missing required accessKeySecret option in config for ram_role_arn');\n        }\n        if (!config.roleArn) {\n            throw new Error('Missing required roleArn option in config for ram_role_arn');\n        }\n        const conf = new config_1.default({\n            type: 'ram_role_arn',\n            accessKeyId: config.accessKeyId,\n            accessKeySecret: config.accessKeySecret,\n        });\n        super(conf);\n        this.roleArn = config.roleArn;\n        this.policy = config.policy;\n        this.durationSeconds = config.roleSessionExpiration || 3600;\n        this.roleSessionName = config.roleSessionName || 'role_session_name';\n        this.runtime = runtime;\n        this.host = 'https://sts.aliyuncs.com';\n    }\n    async updateCredential() {\n        const params = {\n            accessKeyId: this.accessKeyId,\n            roleArn: this.roleArn,\n            action: 'AssumeRole',\n            durationSeconds: this.durationSeconds,\n            roleSessionName: this.roleSessionName\n        };\n        if (this.policy) {\n            params.policy = this.policy;\n        }\n        const json = await http_1.request(this.host, params, this.runtime, this.accessKeySecret);\n        this.sessionCredential = json.Credentials;\n    }\n}\nexports.default = RamRoleArnCredential;\n//# sourceMappingURL=ram_role_arn_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\"));\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nconst utils = __importStar(require(\"./util/utils\"));\nconst http_1 = require(\"./util/http\");\nconst config_1 = __importDefault(require(\"./config\"));\nconst SECURITY_CRED_URL = 'http://100.100.100.200/latest/meta-data/ram/security-credentials/';\nclass RsaKeyPairCredential extends session_credential_1.default {\n    constructor(publicKeyId, privateKeyFile) {\n        if (!publicKeyId) {\n            throw new Error('Missing required publicKeyId option in config for rsa_key_pair');\n        }\n        if (!privateKeyFile) {\n            throw new Error('Missing required privateKeyFile option in config for rsa_key_pair');\n        }\n        if (!fs_1.default.existsSync(privateKeyFile)) {\n            throw new Error(`privateKeyFile ${privateKeyFile} cannot be empty`);\n        }\n        const conf = new config_1.default({\n            type: 'rsa_key_pair'\n        });\n        super(conf);\n        this.privateKey = utils.parseFile(privateKeyFile);\n        this.publicKeyId = publicKeyId;\n    }\n    async updateCredential() {\n        const url = SECURITY_CRED_URL + this.roleName;\n        const json = await http_1.request(url, {\n            accessKeyId: this.publicKeyId,\n            action: 'GenerateSessionAccessKey',\n            durationSeconds: 3600,\n            signatureMethod: 'SHA256withRSA',\n            signatureType: 'PRIVATEKEY',\n        }, {}, this.privateKey);\n        this.sessionCredential = json.Credentials;\n    }\n}\nexports.default = RsaKeyPairCredential;\n//# sourceMappingURL=rsa_key_pair_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst utils = __importStar(require(\"./util/utils\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass SessionCredential extends default_credential_1.default {\n    constructor(config) {\n        const conf = new config_1.default({\n            type: config.type,\n            accessKeyId: config.accessKeyId,\n            accessKeySecret: config.accessKeySecret,\n        });\n        super(conf);\n        this.sessionCredential = null;\n        this.durationSeconds = config.durationSeconds || 3600;\n    }\n    async updateCredential() {\n        throw new Error('need implemented in sub-class');\n    }\n    async ensureCredential() {\n        const needUpdate = this.needUpdateCredential();\n        if (needUpdate) {\n            await this.updateCredential();\n        }\n    }\n    async getAccessKeyId() {\n        await this.ensureCredential();\n        return this.sessionCredential.AccessKeyId;\n    }\n    async getAccessKeySecret() {\n        await this.ensureCredential();\n        return this.sessionCredential.AccessKeySecret;\n    }\n    async getSecurityToken() {\n        await this.ensureCredential();\n        return this.sessionCredential.SecurityToken;\n    }\n    needUpdateCredential() {\n        if (!this.sessionCredential || !this.sessionCredential.Expiration || !this.sessionCredential.AccessKeyId || !this.sessionCredential.AccessKeySecret || !this.sessionCredential.SecurityToken) {\n            return true;\n        }\n        const expireTime = utils.timestamp(new Date(), this.durationSeconds * 0.05 * 1000);\n        if (this.sessionCredential.Expiration < expireTime) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.default = SessionCredential;\n//# sourceMappingURL=session_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst default_credential_1 = __importDefault(require(\"./default_credential\"));\nconst config_1 = __importDefault(require(\"./config\"));\nclass StsTokenCredential extends default_credential_1.default {\n    constructor(accessKeyId, accessKeySecret, securityToken) {\n        if (!accessKeyId) {\n            throw new Error('Missing required accessKeyId option in config for sts');\n        }\n        if (!accessKeySecret) {\n            throw new Error('Missing required accessKeySecret option in config for sts');\n        }\n        if (!securityToken) {\n            throw new Error('Missing required securityToken option in config for sts');\n        }\n        const conf = new config_1.default({\n            type: 'sts',\n            accessKeyId,\n            accessKeySecret,\n            securityToken\n        });\n        super(conf);\n    }\n}\nexports.default = StsTokenCredential;\n//# sourceMappingURL=sts_token_credential.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst httpx_1 = __importDefault(require(\"httpx\"));\nconst config_1 = __importDefault(require(\"./config\"));\nconst session_credential_1 = __importDefault(require(\"./session_credential\"));\nclass URICredential extends session_credential_1.default {\n    constructor(uri) {\n        if (!uri) {\n            throw new Error('Missing required credentialsURI option in config for credentials_uri');\n        }\n        const conf = new config_1.default({\n            type: 'credentials_uri',\n            credentialsURI: uri\n        });\n        super(conf);\n        this.credentialsURI = uri;\n    }\n    async updateCredential() {\n        const url = this.credentialsURI;\n        const response = await httpx_1.default.request(url, {});\n        if (response.statusCode !== 200) {\n            throw new Error(`Get credentials from ${url} failed, status code is ${response.statusCode}`);\n        }\n        const body = (await httpx_1.default.read(response, 'utf8'));\n        let json;\n        try {\n            json = JSON.parse(body);\n        }\n        catch (ex) {\n            throw new Error(`Get credentials from ${url} failed, unmarshal response failed, JSON is: ${body}`);\n        }\n        if (json.Code !== 'Success') {\n            throw new Error(`Get credentials from ${url} failed, Code is ${json.Code}`);\n        }\n        this.sessionCredential = {\n            AccessKeyId: json.AccessKeyId,\n            AccessKeySecret: json.AccessKeySecret,\n            Expiration: json.Expiration,\n            SecurityToken: json.SecurityToken,\n        };\n    }\n}\nexports.default = URICredential;\n//# sourceMappingURL=uri_credential.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_CLIENT = exports.DEFAULT_UA = void 0;\nconst os = __importStar(require(\"os\"));\nconst package_json_1 = __importDefault(require(\"../../package.json\"));\nexports.DEFAULT_UA = `AlibabaCloud (${os.platform()}; ${os.arch()}) ` +\n    `Node.js/${process.version} Core/${package_json_1.default.version}`;\nexports.DEFAULT_CLIENT = `Node.js(${process.version}), ${package_json_1.default.name}: ${package_json_1.default.version}`;\n//# sourceMappingURL=helper.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.request = void 0;\nconst httpx_1 = __importDefault(require(\"httpx\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst helper = __importStar(require(\"./helper\"));\nconst utils = __importStar(require(\"./utils\"));\nconst STATUS_CODE = new Set([200, '200', 'OK', 'Success']);\nfunction firstLetterUpper(str) {\n    return str.slice(0, 1).toUpperCase() + str.slice(1);\n}\nfunction formatParams(params) {\n    const keys = Object.keys(params);\n    const newParams = {};\n    for (const key of keys) {\n        newParams[firstLetterUpper(key)] = params[key];\n    }\n    return newParams;\n}\nfunction encode(str) {\n    const result = encodeURIComponent(str);\n    return result.replace(/!/g, '%21')\n        .replace(/'/g, '%27')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n        .replace(/\\*/g, '%2A');\n}\nfunction replaceRepeatList(target, key, repeat) {\n    for (let i = 0; i < repeat.length; i++) {\n        const item = repeat[i];\n        if (item && typeof item === 'object') {\n            const keys = Object.keys(item);\n            for (const itemKey of keys) {\n                target[`${key}.${i + 1}.${itemKey}`] = item[itemKey];\n            }\n        }\n        else {\n            target[`${key}.${i + 1}`] = item;\n        }\n    }\n}\nfunction flatParams(params) {\n    const target = {};\n    const keys = Object.keys(params);\n    for (const key of keys) {\n        const value = params[key];\n        if (Array.isArray(value)) {\n            replaceRepeatList(target, key, value);\n        }\n        else {\n            target[key] = value;\n        }\n    }\n    return target;\n}\nfunction normalize(params) {\n    const list = [];\n    const flated = flatParams(params);\n    const keys = Object.keys(flated).sort();\n    for (const key of keys) {\n        const value = flated[key];\n        list.push([encode(key), encode(value)]); // push []\n    }\n    return list;\n}\nfunction canonicalize(normalized) {\n    const fields = [];\n    for (const [key, value] of normalized) {\n        fields.push(key + '=' + value);\n    }\n    return fields.join('&');\n}\nfunction _buildParams() {\n    const defaultParams = {\n        Format: 'JSON',\n        SignatureMethod: 'HMAC-SHA1',\n        SignatureNonce: kitx.makeNonce(),\n        SignatureVersion: '1.0',\n        Timestamp: utils.timestamp(),\n        Version: '2015-04-01',\n        RegionId: 'cn-hangzhou'\n    };\n    return defaultParams;\n}\nasync function request(host, params = {}, opts = {}, accessKeySecret) {\n    // 1. compose params and opts\n    let options = Object.assign({ headers: {\n            'x-sdk-client': helper.DEFAULT_CLIENT,\n            'user-agent': helper.DEFAULT_UA\n        } }, opts);\n    // format params until formatParams is false\n    if (options.formatParams !== false) {\n        params = formatParams(params);\n    }\n    params = Object.assign(Object.assign({}, _buildParams()), params);\n    // 2. calculate signature\n    const method = (opts.method || 'GET').toUpperCase();\n    const normalized = normalize(params);\n    const canonicalized = canonicalize(normalized);\n    // 2.1 get string to sign\n    const stringToSign = `${method}&${encode('/')}&${encode(canonicalized)}`;\n    // 2.2 get signature\n    const key = accessKeySecret + '&';\n    const signature = kitx.sha1(stringToSign, key, 'base64');\n    // add signature\n    normalized.push(['Signature', encode(signature)]);\n    // 3. generate final url\n    const url = opts.method === 'POST' ? `${host}/` : `${host}/?${canonicalize(normalized)}`;\n    // 4. send request\n    if (opts.method === 'POST') {\n        opts.headers = opts.headers || {};\n        opts.headers['content-type'] = 'application/x-www-form-urlencoded';\n        opts.data = canonicalize(normalized);\n    }\n    const response = await httpx_1.default.request(url, opts);\n    const buffer = await httpx_1.default.read(response, 'utf8');\n    const json = JSON.parse(buffer);\n    if (json.Code && !STATUS_CODE.has(json.Code)) {\n        const err = new Error(`${json.Message}`);\n        err.name = json.Code + 'Error';\n        err.data = json;\n        err.code = json.Code;\n        err.url = url;\n        throw err;\n    }\n    return json;\n}\nexports.request = request;\n//# sourceMappingURL=http.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseFile = exports.timestamp = void 0;\nconst ini = __importStar(require(\"ini\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nfunction timestamp(dateStr, timeChange) {\n    let date = new Date(dateStr);\n    if (!dateStr || isNaN(date.getTime())) {\n        date = new Date();\n    }\n    if (timeChange) {\n        date.setTime(date.getTime() + timeChange);\n    }\n    const YYYY = date.getUTCFullYear();\n    const MM = kitx.pad2(date.getUTCMonth() + 1);\n    const DD = kitx.pad2(date.getUTCDate());\n    const HH = kitx.pad2(date.getUTCHours());\n    const mm = kitx.pad2(date.getUTCMinutes());\n    const ss = kitx.pad2(date.getUTCSeconds());\n    // 删除掉毫秒部分\n    return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}Z`;\n}\nexports.timestamp = timestamp;\nfunction parseFile(file, ignoreErr = false) {\n    // check read permission\n    try {\n        fs_1.default.accessSync(file, fs_1.default.constants.R_OK);\n    }\n    catch (e) {\n        if (ignoreErr) {\n            return null;\n        }\n        throw new Error('Has no read permission to credentials file');\n    }\n    return ini.parse(fs_1.default.readFileSync(file, 'utf-8'));\n}\nexports.parseFile = parseFile;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Client = /** @class */ (function () {\n    function Client() {\n    }\n    Client.getEndpointRules = function (product, regionId, endpointType, network, suffix) {\n        var result;\n        if (network && network.length && network != \"public\") {\n            network = \"-\" + network;\n        }\n        else {\n            network = \"\";\n        }\n        suffix = suffix || \"\";\n        if (suffix.length) {\n            suffix = \"-\" + suffix;\n        }\n        if (endpointType == \"regional\") {\n            if (!regionId || !regionId.length) {\n                throw new Error(\"RegionId is empty, please set a valid RegionId\");\n            }\n            result = \"\" + product + suffix + network + \".\" + regionId + \".aliyuncs.com\";\n        }\n        else {\n            result = \"\" + product + suffix + network + \".aliyuncs.com\";\n        }\n        return result;\n    };\n    return Client;\n}());\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InterceptorContextResponse = exports.InterceptorContextConfiguration = exports.InterceptorContextRequest = exports.AttributeMap = exports.InterceptorContext = void 0;\n// This file is auto-generated, don't edit it\nconst credentials_1 = __importDefault(require(\"@alicloud/credentials\"));\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nclass InterceptorContext extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            request: 'request',\n            configuration: 'configuration',\n            response: 'response',\n        };\n    }\n    static types() {\n        return {\n            request: InterceptorContextRequest,\n            configuration: InterceptorContextConfiguration,\n            response: InterceptorContextResponse,\n        };\n    }\n}\nexports.InterceptorContext = InterceptorContext;\nclass AttributeMap extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            attributes: 'attributes',\n            key: 'key',\n        };\n    }\n    static types() {\n        return {\n            attributes: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },\n            key: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n        };\n    }\n}\nexports.AttributeMap = AttributeMap;\nclass InterceptorContextRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            query: 'query',\n            body: 'body',\n            stream: 'stream',\n            hostMap: 'hostMap',\n            pathname: 'pathname',\n            productId: 'productId',\n            action: 'action',\n            version: 'version',\n            protocol: 'protocol',\n            method: 'method',\n            authType: 'authType',\n            bodyType: 'bodyType',\n            reqBodyType: 'reqBodyType',\n            style: 'style',\n            credential: 'credential',\n            signatureVersion: 'signatureVersion',\n            signatureAlgorithm: 'signatureAlgorithm',\n            userAgent: 'userAgent',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            query: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            body: 'any',\n            stream: 'Readable',\n            hostMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            pathname: 'string',\n            productId: 'string',\n            action: 'string',\n            version: 'string',\n            protocol: 'string',\n            method: 'string',\n            authType: 'string',\n            bodyType: 'string',\n            reqBodyType: 'string',\n            style: 'string',\n            credential: credentials_1.default,\n            signatureVersion: 'string',\n            signatureAlgorithm: 'string',\n            userAgent: 'string',\n        };\n    }\n}\nexports.InterceptorContextRequest = InterceptorContextRequest;\nclass InterceptorContextConfiguration extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            regionId: 'regionId',\n            endpoint: 'endpoint',\n            endpointRule: 'endpointRule',\n            endpointMap: 'endpointMap',\n            endpointType: 'endpointType',\n            network: 'network',\n            suffix: 'suffix',\n        };\n    }\n    static types() {\n        return {\n            regionId: 'string',\n            endpoint: 'string',\n            endpointRule: 'string',\n            endpointMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            endpointType: 'string',\n            network: 'string',\n            suffix: 'string',\n        };\n    }\n}\nexports.InterceptorContextConfiguration = InterceptorContextConfiguration;\nclass InterceptorContextResponse extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            statusCode: 'statusCode',\n            headers: 'headers',\n            body: 'body',\n            deserializedBody: 'deserializedBody',\n        };\n    }\n    static types() {\n        return {\n            statusCode: 'number',\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            body: 'Readable',\n            deserializedBody: 'any',\n        };\n    }\n}\nexports.InterceptorContextResponse = InterceptorContextResponse;\nclass Client {\n    constructor() {\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Params = exports.OpenApiRequest = exports.Config = void 0;\n// This file is auto-generated, don't edit it\n/**\n * This is for OpenApi SDK\n */\nconst tea_util_1 = __importDefault(require(\"@alicloud/tea-util\"));\nconst credentials_1 = __importStar(require(\"@alicloud/credentials\")), $Credential = credentials_1;\nconst openapi_util_1 = __importDefault(require(\"@alicloud/openapi-util\"));\nconst $SPI = __importStar(require(\"@alicloud/gateway-spi\"));\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\n/**\n * Model for initing client\n */\nclass Config extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            accessKeyId: 'accessKeyId',\n            accessKeySecret: 'accessKeySecret',\n            securityToken: 'securityToken',\n            protocol: 'protocol',\n            method: 'method',\n            regionId: 'regionId',\n            readTimeout: 'readTimeout',\n            connectTimeout: 'connectTimeout',\n            httpProxy: 'httpProxy',\n            httpsProxy: 'httpsProxy',\n            credential: 'credential',\n            endpoint: 'endpoint',\n            noProxy: 'noProxy',\n            maxIdleConns: 'maxIdleConns',\n            network: 'network',\n            userAgent: 'userAgent',\n            suffix: 'suffix',\n            socks5Proxy: 'socks5Proxy',\n            socks5NetWork: 'socks5NetWork',\n            endpointType: 'endpointType',\n            openPlatformEndpoint: 'openPlatformEndpoint',\n            type: 'type',\n            signatureVersion: 'signatureVersion',\n            signatureAlgorithm: 'signatureAlgorithm',\n        };\n    }\n    static types() {\n        return {\n            accessKeyId: 'string',\n            accessKeySecret: 'string',\n            securityToken: 'string',\n            protocol: 'string',\n            method: 'string',\n            regionId: 'string',\n            readTimeout: 'number',\n            connectTimeout: 'number',\n            httpProxy: 'string',\n            httpsProxy: 'string',\n            credential: credentials_1.default,\n            endpoint: 'string',\n            noProxy: 'string',\n            maxIdleConns: 'number',\n            network: 'string',\n            userAgent: 'string',\n            suffix: 'string',\n            socks5Proxy: 'string',\n            socks5NetWork: 'string',\n            endpointType: 'string',\n            openPlatformEndpoint: 'string',\n            type: 'string',\n            signatureVersion: 'string',\n            signatureAlgorithm: 'string',\n        };\n    }\n}\nexports.Config = Config;\nclass OpenApiRequest extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            headers: 'headers',\n            query: 'query',\n            body: 'body',\n            stream: 'stream',\n            hostMap: 'hostMap',\n        };\n    }\n    static types() {\n        return {\n            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            query: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n            body: 'any',\n            stream: 'Readable',\n            hostMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },\n        };\n    }\n}\nexports.OpenApiRequest = OpenApiRequest;\nclass Params extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            action: 'action',\n            version: 'version',\n            protocol: 'protocol',\n            pathname: 'pathname',\n            method: 'method',\n            authType: 'authType',\n            bodyType: 'bodyType',\n            reqBodyType: 'reqBodyType',\n            style: 'style',\n        };\n    }\n    static types() {\n        return {\n            action: 'string',\n            version: 'string',\n            protocol: 'string',\n            pathname: 'string',\n            method: 'string',\n            authType: 'string',\n            bodyType: 'string',\n            reqBodyType: 'string',\n            style: 'string',\n        };\n    }\n}\nexports.Params = Params;\nclass Client {\n    /**\n     * Init client with Config\n     * @param config config contains the necessary information to create a client\n     */\n    constructor(config) {\n        if (tea_util_1.default.isUnset($tea.toMap(config))) {\n            throw $tea.newError({\n                code: \"ParameterMissing\",\n                message: \"'config' can not be unset\",\n            });\n        }\n        if (!tea_util_1.default.empty(config.accessKeyId) && !tea_util_1.default.empty(config.accessKeySecret)) {\n            if (!tea_util_1.default.empty(config.securityToken)) {\n                config.type = \"sts\";\n            }\n            else {\n                config.type = \"access_key\";\n            }\n            let credentialConfig = new $Credential.Config({\n                accessKeyId: config.accessKeyId,\n                type: config.type,\n                accessKeySecret: config.accessKeySecret,\n                securityToken: config.securityToken,\n            });\n            this._credential = new credentials_1.default(credentialConfig);\n        }\n        else if (!tea_util_1.default.isUnset(config.credential)) {\n            this._credential = config.credential;\n        }\n        this._endpoint = config.endpoint;\n        this._endpointType = config.endpointType;\n        this._network = config.network;\n        this._suffix = config.suffix;\n        this._protocol = config.protocol;\n        this._method = config.method;\n        this._regionId = config.regionId;\n        this._userAgent = config.userAgent;\n        this._readTimeout = config.readTimeout;\n        this._connectTimeout = config.connectTimeout;\n        this._httpProxy = config.httpProxy;\n        this._httpsProxy = config.httpsProxy;\n        this._noProxy = config.noProxy;\n        this._socks5Proxy = config.socks5Proxy;\n        this._socks5NetWork = config.socks5NetWork;\n        this._maxIdleConns = config.maxIdleConns;\n        this._signatureVersion = config.signatureVersion;\n        this._signatureAlgorithm = config.signatureAlgorithm;\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doRPCRequest(action, version, protocol, method, authType, bodyType, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);\n                request_.method = method;\n                request_.pathname = \"/\";\n                request_.query = Object.assign({ Action: action, Format: \"json\", Version: version, Timestamp: openapi_util_1.default.getTimestamp(), SignatureNonce: tea_util_1.default.getNonce() }, request.query);\n                let headers = this.getRpcHeaders();\n                if (tea_util_1.default.isUnset(headers)) {\n                    // endpoint is setted in product client\n                    request_.headers = {\n                        host: this._endpoint,\n                        'x-acs-version': version,\n                        'x-acs-action': action,\n                        'user-agent': this.getUserAgent(),\n                    };\n                }\n                else {\n                    request_.headers = Object.assign({ host: this._endpoint, 'x-acs-version': version, 'x-acs-action': action, 'user-agent': this.getUserAgent() }, headers);\n                }\n                if (!tea_util_1.default.isUnset(request.body)) {\n                    let m = tea_util_1.default.assertAsMap(request.body);\n                    let tmp = tea_util_1.default.anyifyMapValue(openapi_util_1.default.query(m));\n                    request_.body = new $tea.BytesReadable(tea_util_1.default.toFormString(tmp));\n                    request_.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n                }\n                if (!tea_util_1.default.equalString(authType, \"Anonymous\")) {\n                    let accessKeyId = await this.getAccessKeyId();\n                    let accessKeySecret = await this.getAccessKeySecret();\n                    let securityToken = await this.getSecurityToken();\n                    if (!tea_util_1.default.empty(securityToken)) {\n                        request_.query[\"SecurityToken\"] = securityToken;\n                    }\n                    request_.query[\"SignatureMethod\"] = \"HMAC-SHA1\";\n                    request_.query[\"SignatureVersion\"] = \"1.0\";\n                    request_.query[\"AccessKeyId\"] = accessKeyId;\n                    let t = null;\n                    if (!tea_util_1.default.isUnset(request.body)) {\n                        t = tea_util_1.default.assertAsMap(request.body);\n                    }\n                    let signedParam = Object.assign(Object.assign({}, request_.query), openapi_util_1.default.query(t));\n                    request_.query[\"Signature\"] = openapi_util_1.default.getRPCSignature(signedParam, request_.method, accessKeySecret);\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    let requestId = Client.defaultAny(err[\"RequestId\"], err[\"requestId\"]);\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${requestId}`,\n                        data: err,\n                    });\n                }\n                if (tea_util_1.default.equalString(bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param pathname pathname of every api\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doROARequest(action, version, protocol, method, authType, pathname, bodyType, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);\n                request_.method = method;\n                request_.pathname = pathname;\n                request_.headers = Object.assign({ date: tea_util_1.default.getDateUTCString(), host: this._endpoint, accept: \"application/json\", 'x-acs-signature-nonce': tea_util_1.default.getNonce(), 'x-acs-signature-method': \"HMAC-SHA1\", 'x-acs-signature-version': \"1.0\", 'x-acs-version': version, 'x-acs-action': action, 'user-agent': tea_util_1.default.getUserAgent(this._userAgent) }, request.headers);\n                if (!tea_util_1.default.isUnset(request.body)) {\n                    request_.body = new $tea.BytesReadable(tea_util_1.default.toJSONString(request.body));\n                    request_.headers[\"content-type\"] = \"application/json; charset=utf-8\";\n                }\n                if (!tea_util_1.default.isUnset(request.query)) {\n                    request_.query = request.query;\n                }\n                if (!tea_util_1.default.equalString(authType, \"Anonymous\")) {\n                    let accessKeyId = await this.getAccessKeyId();\n                    let accessKeySecret = await this.getAccessKeySecret();\n                    let securityToken = await this.getSecurityToken();\n                    if (!tea_util_1.default.empty(securityToken)) {\n                        request_.headers[\"x-acs-accesskey-id\"] = accessKeyId;\n                        request_.headers[\"x-acs-security-token\"] = securityToken;\n                    }\n                    let stringToSign = openapi_util_1.default.getStringToSign(request_);\n                    request_.headers[\"authorization\"] = `acs ${accessKeyId}:${openapi_util_1.default.getROASignature(stringToSign, accessKeySecret)}`;\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.equalNumber(response_.statusCode, 204)) {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    let requestId = Client.defaultAny(err[\"RequestId\"], err[\"requestId\"]);\n                    requestId = Client.defaultAny(requestId, err[\"requestid\"]);\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${requestId}`,\n                        data: err,\n                    });\n                }\n                if (tea_util_1.default.equalString(bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network with form body\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param pathname pathname of every api\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doROARequestWithForm(action, version, protocol, method, authType, pathname, bodyType, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, protocol);\n                request_.method = method;\n                request_.pathname = pathname;\n                request_.headers = Object.assign({ date: tea_util_1.default.getDateUTCString(), host: this._endpoint, accept: \"application/json\", 'x-acs-signature-nonce': tea_util_1.default.getNonce(), 'x-acs-signature-method': \"HMAC-SHA1\", 'x-acs-signature-version': \"1.0\", 'x-acs-version': version, 'x-acs-action': action, 'user-agent': tea_util_1.default.getUserAgent(this._userAgent) }, request.headers);\n                if (!tea_util_1.default.isUnset(request.body)) {\n                    let m = tea_util_1.default.assertAsMap(request.body);\n                    request_.body = new $tea.BytesReadable(openapi_util_1.default.toForm(m));\n                    request_.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n                }\n                if (!tea_util_1.default.isUnset(request.query)) {\n                    request_.query = request.query;\n                }\n                if (!tea_util_1.default.equalString(authType, \"Anonymous\")) {\n                    let accessKeyId = await this.getAccessKeyId();\n                    let accessKeySecret = await this.getAccessKeySecret();\n                    let securityToken = await this.getSecurityToken();\n                    if (!tea_util_1.default.empty(securityToken)) {\n                        request_.headers[\"x-acs-accesskey-id\"] = accessKeyId;\n                        request_.headers[\"x-acs-security-token\"] = securityToken;\n                    }\n                    let stringToSign = openapi_util_1.default.getStringToSign(request_);\n                    request_.headers[\"authorization\"] = `acs ${accessKeyId}:${openapi_util_1.default.getROASignature(stringToSign, accessKeySecret)}`;\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.equalNumber(response_.statusCode, 204)) {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${Client.defaultAny(err[\"RequestId\"], err[\"requestId\"])}`,\n                        data: err,\n                    });\n                }\n                if (tea_util_1.default.equalString(bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async doRequest(params, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                request_.protocol = tea_util_1.default.defaultString(this._protocol, params.protocol);\n                request_.method = params.method;\n                request_.pathname = params.pathname;\n                request_.query = request.query;\n                // endpoint is setted in product client\n                request_.headers = Object.assign({ host: this._endpoint, 'x-acs-version': params.version, 'x-acs-action': params.action, 'user-agent': this.getUserAgent(), 'x-acs-date': openapi_util_1.default.getTimestamp(), 'x-acs-signature-nonce': tea_util_1.default.getNonce(), accept: \"application/json\" }, request.headers);\n                if (tea_util_1.default.equalString(params.style, \"RPC\")) {\n                    let headers = this.getRpcHeaders();\n                    if (!tea_util_1.default.isUnset(headers)) {\n                        request_.headers = Object.assign(Object.assign({}, request_.headers), headers);\n                    }\n                }\n                let signatureAlgorithm = tea_util_1.default.defaultString(this._signatureAlgorithm, \"ACS3-HMAC-SHA256\");\n                let hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tea_util_1.default.toBytes(\"\"), signatureAlgorithm));\n                if (!tea_util_1.default.isUnset(request.stream)) {\n                    let tmp = await tea_util_1.default.readAsBytes(request.stream);\n                    hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tmp, signatureAlgorithm));\n                    request_.body = new $tea.BytesReadable(tmp);\n                    request_.headers[\"content-type\"] = \"application/octet-stream\";\n                }\n                else {\n                    if (!tea_util_1.default.isUnset(request.body)) {\n                        if (tea_util_1.default.equalString(params.reqBodyType, \"json\")) {\n                            let jsonObj = tea_util_1.default.toJSONString(request.body);\n                            hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tea_util_1.default.toBytes(jsonObj), signatureAlgorithm));\n                            request_.body = new $tea.BytesReadable(jsonObj);\n                            request_.headers[\"content-type\"] = \"application/json; charset=utf-8\";\n                        }\n                        else {\n                            let m = tea_util_1.default.assertAsMap(request.body);\n                            let formObj = openapi_util_1.default.toForm(m);\n                            hashedRequestPayload = openapi_util_1.default.hexEncode(openapi_util_1.default.hash(tea_util_1.default.toBytes(formObj), signatureAlgorithm));\n                            request_.body = new $tea.BytesReadable(formObj);\n                            request_.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n                        }\n                    }\n                }\n                request_.headers[\"x-acs-content-sha256\"] = hashedRequestPayload;\n                if (!tea_util_1.default.equalString(params.authType, \"Anonymous\")) {\n                    let accessKeyId = await this.getAccessKeyId();\n                    let accessKeySecret = await this.getAccessKeySecret();\n                    let securityToken = await this.getSecurityToken();\n                    if (!tea_util_1.default.empty(securityToken)) {\n                        request_.headers[\"x-acs-accesskey-id\"] = accessKeyId;\n                        request_.headers[\"x-acs-security-token\"] = securityToken;\n                    }\n                    request_.headers[\"Authorization\"] = openapi_util_1.default.getAuthorization(request_, signatureAlgorithm, hashedRequestPayload, accessKeyId, accessKeySecret);\n                }\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {\n                    let _res = await tea_util_1.default.readAsJSON(response_.body);\n                    let err = tea_util_1.default.assertAsMap(_res);\n                    throw $tea.newError({\n                        code: `${Client.defaultAny(err[\"Code\"], err[\"code\"])}`,\n                        message: `code: ${response_.statusCode}, ${Client.defaultAny(err[\"Message\"], err[\"message\"])} request id: ${Client.defaultAny(err[\"RequestId\"], err[\"requestId\"])}`,\n                        data: err,\n                    });\n                }\n                if (tea_util_1.default.equalString(params.bodyType, \"binary\")) {\n                    let resp = {\n                        body: response_.body,\n                        headers: response_.headers,\n                    };\n                    return resp;\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"byte\")) {\n                    let byt = await tea_util_1.default.readAsBytes(response_.body);\n                    return {\n                        body: byt,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"string\")) {\n                    let str = await tea_util_1.default.readAsString(response_.body);\n                    return {\n                        body: str,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"json\")) {\n                    let obj = await tea_util_1.default.readAsJSON(response_.body);\n                    let res = tea_util_1.default.assertAsMap(obj);\n                    return {\n                        body: res,\n                        headers: response_.headers,\n                    };\n                }\n                else if (tea_util_1.default.equalString(params.bodyType, \"array\")) {\n                    let arr = await tea_util_1.default.readAsJSON(response_.body);\n                    return {\n                        body: arr,\n                        headers: response_.headers,\n                    };\n                }\n                else {\n                    return {\n                        headers: response_.headers,\n                    };\n                }\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    /**\n     * Encapsulate the request and invoke the network\n     * @param action api name\n     * @param version product version\n     * @param protocol http or https\n     * @param method e.g. GET\n     * @param authType authorization type e.g. AK\n     * @param bodyType response body type e.g. String\n     * @param request object of OpenApiRequest\n     * @param runtime which controls some details of call api, such as retry times\n     * @return the response\n     */\n    async execute(params, request, runtime) {\n        let _runtime = {\n            timeouted: \"retry\",\n            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),\n            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),\n            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),\n            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),\n            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),\n            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),\n            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),\n            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),\n            retry: {\n                retryable: runtime.autoretry,\n                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),\n            },\n            backoff: {\n                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, \"no\"),\n                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),\n            },\n            ignoreSSL: runtime.ignoreSSL,\n        };\n        let _lastRequest = null;\n        let _now = Date.now();\n        let _retryTimes = 0;\n        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {\n            if (_retryTimes > 0) {\n                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);\n                if (_backoffTime > 0) {\n                    await $tea.sleep(_backoffTime);\n                }\n            }\n            _retryTimes = _retryTimes + 1;\n            try {\n                let request_ = new $tea.Request();\n                // spi = new Gateway();//Gateway implements SPI，这一步在产品 SDK 中实例化\n                let headers = this.getRpcHeaders();\n                let requestContext = new $SPI.InterceptorContextRequest({\n                    headers: Object.assign(Object.assign({}, request.headers), headers),\n                    query: request.query,\n                    body: request.body,\n                    stream: request.stream,\n                    hostMap: request.hostMap,\n                    pathname: params.pathname,\n                    productId: this._productId,\n                    action: params.action,\n                    version: params.version,\n                    protocol: tea_util_1.default.defaultString(this._protocol, params.protocol),\n                    method: tea_util_1.default.defaultString(this._method, params.method),\n                    authType: params.authType,\n                    bodyType: params.bodyType,\n                    reqBodyType: params.reqBodyType,\n                    style: params.style,\n                    credential: this._credential,\n                    signatureVersion: this._signatureVersion,\n                    signatureAlgorithm: this._signatureAlgorithm,\n                    userAgent: this.getUserAgent(),\n                });\n                let configurationContext = new $SPI.InterceptorContextConfiguration({\n                    regionId: this._regionId,\n                    endpoint: this._endpoint,\n                    endpointRule: this._endpointRule,\n                    endpointMap: this._endpointMap,\n                    endpointType: this._endpointType,\n                    network: this._network,\n                    suffix: this._suffix,\n                });\n                let interceptorContext = new $SPI.InterceptorContext({\n                    request: requestContext,\n                    configuration: configurationContext,\n                });\n                let attributeMap = new $SPI.AttributeMap({});\n                // 1. spi.modifyConfiguration(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);\n                await this._spi.modifyConfiguration(interceptorContext, attributeMap);\n                // 2. spi.modifyRequest(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);\n                await this._spi.modifyRequest(interceptorContext, attributeMap);\n                request_.protocol = interceptorContext.request.protocol;\n                request_.method = interceptorContext.request.method;\n                request_.pathname = interceptorContext.request.pathname;\n                request_.query = interceptorContext.request.query;\n                request_.body = interceptorContext.request.stream;\n                request_.headers = interceptorContext.request.headers;\n                _lastRequest = request_;\n                let response_ = await $tea.doAction(request_, _runtime);\n                let responseContext = new $SPI.InterceptorContextResponse({\n                    statusCode: response_.statusCode,\n                    headers: response_.headers,\n                    body: response_.body,\n                });\n                interceptorContext.response = responseContext;\n                // 3. spi.modifyResponse(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);\n                await this._spi.modifyResponse(interceptorContext, attributeMap);\n                return {\n                    headers: interceptorContext.response.headers,\n                    body: interceptorContext.response.deserializedBody,\n                };\n            }\n            catch (ex) {\n                if ($tea.isRetryable(ex)) {\n                    continue;\n                }\n                throw ex;\n            }\n        }\n        throw $tea.newUnretryableError(_lastRequest);\n    }\n    async callApi(params, request, runtime) {\n        if (tea_util_1.default.isUnset($tea.toMap(params))) {\n            throw $tea.newError({\n                code: \"ParameterMissing\",\n                message: \"'params' can not be unset\",\n            });\n        }\n        if (tea_util_1.default.isUnset(this._signatureAlgorithm) || !tea_util_1.default.equalString(this._signatureAlgorithm, \"v2\")) {\n            return await this.doRequest(params, request, runtime);\n        }\n        else if (tea_util_1.default.equalString(params.style, \"ROA\") && tea_util_1.default.equalString(params.reqBodyType, \"json\")) {\n            return await this.doROARequest(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);\n        }\n        else if (tea_util_1.default.equalString(params.style, \"ROA\")) {\n            return await this.doROARequestWithForm(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);\n        }\n        else {\n            return await this.doRPCRequest(params.action, params.version, params.protocol, params.method, params.authType, params.bodyType, request, runtime);\n        }\n    }\n    /**\n     * Get user agent\n     * @return user agent\n     */\n    getUserAgent() {\n        let userAgent = tea_util_1.default.getUserAgent(this._userAgent);\n        return userAgent;\n    }\n    /**\n     * Get accesskey id by using credential\n     * @return accesskey id\n     */\n    async getAccessKeyId() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let accessKeyId = await this._credential.getAccessKeyId();\n        return accessKeyId;\n    }\n    /**\n     * Get accesskey secret by using credential\n     * @return accesskey secret\n     */\n    async getAccessKeySecret() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let secret = await this._credential.getAccessKeySecret();\n        return secret;\n    }\n    /**\n     * Get security token by using credential\n     * @return security token\n     */\n    async getSecurityToken() {\n        if (tea_util_1.default.isUnset(this._credential)) {\n            return \"\";\n        }\n        let token = await this._credential.getSecurityToken();\n        return token;\n    }\n    /**\n     * If inputValue is not null, return it or return defaultValue\n     * @param inputValue  users input value\n     * @param defaultValue default value\n     * @return the final result\n     */\n    static defaultAny(inputValue, defaultValue) {\n        if (tea_util_1.default.isUnset(inputValue)) {\n            return defaultValue;\n        }\n        return inputValue;\n    }\n    /**\n     * If the endpointRule and config.endpoint are empty, throw error\n     * @param config config contains the necessary information to create a client\n     */\n    checkConfig(config) {\n        if (tea_util_1.default.empty(this._endpointRule) && tea_util_1.default.empty(config.endpoint)) {\n            throw $tea.newError({\n                code: \"ParameterMissing\",\n                message: \"'config.endpoint' can not be empty\",\n            });\n        }\n    }\n    /**\n     * set RPC header for debug\n     * @param headers headers for debug, this header can be used only once.\n     */\n    setRpcHeaders(headers) {\n        this._headers = headers;\n    }\n    /**\n     * get RPC header for debug\n     */\n    getRpcHeaders() {\n        let headers = this._headers;\n        this._headers = null;\n        return headers;\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This file is auto-generated, don't edit it\n/**\n * This is for OpenApi Util\n */\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nconst tea_util_1 = __importDefault(require(\"@alicloud/tea-util\"));\nconst kitx_1 = __importDefault(require(\"kitx\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst PEM_BEGIN = \"-----BEGIN PRIVATE KEY-----\\n\";\nconst PEM_END = \"\\n-----END PRIVATE KEY-----\";\nfunction replaceRepeatList(target, repeat, prefix) {\n    if (prefix) {\n        prefix = prefix + '.';\n    }\n    for (var i = 0; i < repeat.length; i++) {\n        var item = repeat[i];\n        let key = prefix + (i + 1);\n        if (typeof item === 'undefined' || item == null) {\n            continue;\n        }\n        if (Array.isArray(item)) {\n            replaceRepeatList(target, item, key);\n        }\n        else if (item instanceof Object) {\n            flatMap(target, item, key);\n        }\n        else {\n            target[key] = item.toString();\n        }\n    }\n}\nfunction flatMap(target, params, prefix = '') {\n    if (prefix) {\n        prefix = prefix + '.';\n    }\n    params = toMap(params);\n    let keys = Object.keys(params);\n    for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let value = params[key];\n        key = prefix + key;\n        if (typeof value === 'undefined' || value == null) {\n            continue;\n        }\n        if (Array.isArray(value)) {\n            replaceRepeatList(target, value, key);\n        }\n        else if (value instanceof Object) {\n            flatMap(target, value, key);\n        }\n        else {\n            target[key] = value.toString();\n        }\n    }\n    return target;\n}\nfunction filter(value) {\n    return value.replace(/[\\t\\n\\r\\f]/g, ' ');\n}\nfunction getCanonicalizedHeaders(headers) {\n    const prefix = 'x-acs-';\n    const keys = Object.keys(headers);\n    const canonicalizedKeys = [];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key.startsWith(prefix)) {\n            canonicalizedKeys.push(key);\n        }\n    }\n    canonicalizedKeys.sort();\n    var result = '';\n    for (let i = 0; i < canonicalizedKeys.length; i++) {\n        const key = canonicalizedKeys[i];\n        result += `${key}:${filter(headers[key]).trim()}\\n`;\n    }\n    return result;\n}\nfunction getCanonicalizedResource(uriPattern, query) {\n    const keys = !query ? [] : Object.keys(query).sort();\n    if (keys.length === 0) {\n        return uriPattern;\n    }\n    var result = [];\n    for (var i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        result.push(`${key}=${query[key]}`);\n    }\n    return `${uriPattern}?${result.join('&')}`;\n}\nfunction getAuthorizationQueryString(query) {\n    let canonicalQueryArray = [];\n    const keys = !query ? [] : Object.keys(query).sort();\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        let param = key + '=';\n        if (typeof query[key] !== 'undefined' && query[key] !== null) {\n            param = param + encode(query[key]);\n        }\n        canonicalQueryArray.push(param);\n    }\n    return canonicalQueryArray.join('&');\n}\nfunction getAuthorizationHeaders(header) {\n    let canonicalheaders = \"\";\n    let tmp = {};\n    const keys = !header ? [] : Object.keys(header);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const lowerKey = keys[i].toLowerCase();\n        if (lowerKey.startsWith(\"x-acs-\") || lowerKey === \"host\" || lowerKey === \"content-type\") {\n            if (tmp[lowerKey]) {\n                tmp[lowerKey].push((header[key] || \"\").trim());\n            }\n            else {\n                tmp[lowerKey] = [(header[key] || \"\").trim()];\n            }\n        }\n    }\n    var hsKeys = Object.keys(tmp).sort();\n    for (let i = 0; i < hsKeys.length; i++) {\n        const hsKey = hsKeys[i];\n        let listSort = tmp[hsKey].sort();\n        canonicalheaders += `${hsKey}:${listSort.join(\",\")}\\n`;\n    }\n    return { canonicalheaders, hsKeys };\n}\nfunction encode(str) {\n    var result = encodeURIComponent(str);\n    return result.replace(/!/g, '%21')\n        .replace(/'/g, '%27')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n        .replace(/\\*/g, '%2A');\n}\nfunction normalize(params) {\n    var list = [];\n    var flated = {};\n    flatMap(flated, params);\n    var keys = Object.keys(flated).sort();\n    for (let i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = flated[key];\n        list.push([encode(key), encode(value)]);\n    }\n    return list;\n}\nfunction canonicalize(normalized) {\n    var fields = [];\n    for (var i = 0; i < normalized.length; i++) {\n        var [key, value] = normalized[i];\n        fields.push(key + '=' + value);\n    }\n    return fields.join('&');\n}\nfunction isModelClass(t) {\n    if (!t) {\n        return false;\n    }\n    return typeof t.types === 'function' && typeof t.names === 'function';\n}\nfunction isObjectOrArray(t) {\n    return Array.isArray(t) || (t instanceof Object && typeof t !== 'function');\n}\nfunction toMap(input) {\n    if (!isObjectOrArray(input)) {\n        return null;\n    }\n    else if (input instanceof $tea.Model) {\n        return $tea.toMap(input);\n    }\n    else if (input && input.toMap && typeof input.toMap === 'function') {\n        // 解决跨版本 Model 不互认的问题\n        return input.toMap();\n    }\n    else if (Array.isArray(input)) {\n        const result = [];\n        input.forEach((value) => {\n            if (isObjectOrArray(value)) {\n                result.push(toMap(value));\n            }\n            else {\n                result.push(value);\n            }\n        });\n        return result;\n    }\n    else if (input instanceof Object) {\n        const result = {};\n        Object.entries(input).forEach(([key, value]) => {\n            if (isObjectOrArray(value)) {\n                result[key] = toMap(value);\n            }\n            else {\n                result[key] = value;\n            }\n        });\n        return result;\n    }\n}\nclass Client {\n    /**\n     * Convert all params of body other than type of readable into content\n     * @param input source Model\n     * @param output target Model\n     * @return void\n     */\n    static convert(input, output) {\n        if (!output) {\n            return;\n        }\n        let inputModel = Object.assign({}, input);\n        let constructor = output.constructor;\n        let types = constructor.types();\n        // let constructor = <any>output.constructor;\n        for (let key of Object.keys(constructor.names())) {\n            if (inputModel[key]) {\n                if (isModelClass(types[key])) {\n                    output[key] = new types[key](output[key]);\n                    Client.convert(inputModel[key], output[key]);\n                    continue;\n                }\n                output[key] = inputModel[key];\n            }\n        }\n    }\n    /**\n     * Get the string to be signed according to request\n     * @param request  which contains signed messages\n     * @return the signed string\n     */\n    static getStringToSign(request) {\n        const method = request.method;\n        const accept = request.headers['accept'];\n        const contentMD5 = request.headers['content-md5'] || '';\n        const contentType = request.headers['content-type'] || '';\n        const date = request.headers['date'] || '';\n        const header = `${method}\\n${accept}\\n${contentMD5}\\n${contentType}\\n${date}\\n`;\n        const canonicalizedHeaders = getCanonicalizedHeaders(request.headers);\n        const canonicalizedResource = getCanonicalizedResource(request.pathname, request.query);\n        return `${header}${canonicalizedHeaders}${canonicalizedResource}`;\n    }\n    /**\n     * Get signature according to stringToSign, secret\n     * @param stringToSign  the signed string\n     * @param secret accesskey secret\n     * @return the signature\n     */\n    static getROASignature(stringToSign, secret) {\n        const utf8Buff = Buffer.from(stringToSign, 'utf8');\n        return kitx_1.default.sha1(utf8Buff, secret, 'base64');\n    }\n    /**\n     * Parse filter into a form string\n     * @param filter object\n     * @return the string\n     */\n    static toForm(filter) {\n        if (!filter) {\n            return '';\n        }\n        let target = {};\n        flatMap(target, filter);\n        return tea_util_1.default.toFormString(target);\n    }\n    /**\n     * Get timestamp\n     * @return the timestamp string\n     */\n    static getTimestamp() {\n        let date = new Date();\n        let YYYY = date.getUTCFullYear();\n        let MM = kitx_1.default.pad2(date.getUTCMonth() + 1);\n        let DD = kitx_1.default.pad2(date.getUTCDate());\n        let HH = kitx_1.default.pad2(date.getUTCHours());\n        let mm = kitx_1.default.pad2(date.getUTCMinutes());\n        let ss = kitx_1.default.pad2(date.getUTCSeconds());\n        return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}Z`;\n    }\n    /**\n     * Parse filter into a object which's type is map[string]string\n     * @param filter query param\n     * @return the object\n     */\n    static query(filter) {\n        if (!filter) {\n            return {};\n        }\n        let ret = {};\n        flatMap(ret, filter);\n        return ret;\n    }\n    /**\n     * Get signature according to signedParams, method and secret\n     * @param signedParams params which need to be signed\n     * @param method http method e.g. GET\n     * @param secret AccessKeySecret\n     * @return the signature\n     */\n    static getRPCSignature(signedParams, method, secret) {\n        var normalized = normalize(signedParams);\n        var canonicalized = canonicalize(normalized);\n        var stringToSign = `${method}&${encode('/')}&${encode(canonicalized)}`;\n        const key = secret + '&';\n        return kitx_1.default.sha1(stringToSign, key, 'base64');\n    }\n    /**\n     * Parse array into a string with specified style\n     * @param array the array\n     * @param prefix the prefix string\n     * @style specified style e.g. repeatList\n     * @return the string\n     */\n    static arrayToStringWithSpecifiedStyle(array, prefix, style) {\n        if (!array) {\n            return '';\n        }\n        if (style === 'repeatList') {\n            let target = {};\n            replaceRepeatList(target, array, prefix);\n            return querystring_1.default.stringify(target, '&&');\n        }\n        else if (style === 'json') {\n            return JSON.stringify(array);\n        }\n        else if (style === 'simple') {\n            return array.join(',');\n        }\n        else if (style === 'spaceDelimited') {\n            return array.join(' ');\n        }\n        else if (style === 'pipeDelimited') {\n            return array.join('|');\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Transform input as map.\n     */\n    static parseToMap(input) {\n        return toMap(input);\n    }\n    static getEndpoint(endpoint, serverUse, endpointType) {\n        if (endpointType == \"internal\") {\n            let strs = endpoint.split(\".\");\n            strs[0] += \"-internal\";\n            endpoint = strs.join(\".\");\n        }\n        if (serverUse && endpointType == \"accelerate\") {\n            return \"oss-accelerate.aliyuncs.com\";\n        }\n        return endpoint;\n    }\n    /**\n    * Encode raw with base16\n    * @param raw encoding data\n    * @return encoded string\n    */\n    static hexEncode(raw) {\n        return raw.toString(\"hex\");\n    }\n    /**\n     * Hash the raw data with signatureAlgorithm\n     * @param raw hashing data\n     * @param signatureAlgorithm the autograph method\n     * @return hashed bytes\n    */\n    static hash(raw, signatureAlgorithm) {\n        if (signatureAlgorithm === \"ACS3-HMAC-SHA256\" || signatureAlgorithm === \"ACS3-RSA-SHA256\") {\n            const obj = crypto_1.default.createHash('sha256');\n            obj.update(raw);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm == \"ACS3-HMAC-SM3\") {\n            const obj = crypto_1.default.createHash('sm3');\n            obj.update(raw);\n            return obj.digest();\n        }\n    }\n    static signatureMethod(secret, source, signatureAlgorithm) {\n        if (signatureAlgorithm === \"ACS3-HMAC-SHA256\") {\n            const obj = crypto_1.default.createHmac('sha256', secret);\n            obj.update(source);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm === \"ACS3-HMAC-SM3\") {\n            const obj = crypto_1.default.createHmac('sm3', secret);\n            obj.update(source);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm === \"ACS3-RSA-SHA256\") {\n            if (!secret.startsWith(PEM_BEGIN)) {\n                secret = PEM_BEGIN + secret;\n            }\n            if (!secret.endsWith(PEM_END)) {\n                secret = secret + PEM_END;\n            }\n            var signerObject = crypto_1.default.createSign(\"RSA-SHA256\");\n            signerObject.update(source);\n            var signature = signerObject.sign({ key: secret, padding: crypto_1.default.constants.RSA_PKCS1_PADDING });\n            return signature;\n        }\n    }\n    /**\n     * Get the authorization\n     * @param request request params\n     * @param signatureAlgorithm the autograph method\n     * @param payload the hashed request\n     * @param acesskey the acesskey string\n     * @param accessKeySecret the accessKeySecret string\n     * @return authorization string\n     */\n    static getAuthorization(request, signatureAlgorithm, payload, acesskey, accessKeySecret) {\n        const canonicalURI = (request.pathname || \"\").replace(\"+\", \"%20\").replace(\"*\", \"%2A\").replace(\"%7E\", \"~\");\n        const method = request.method;\n        const canonicalQueryString = getAuthorizationQueryString(request.query);\n        const tuple = getAuthorizationHeaders(request.headers);\n        const canonicalheaders = tuple[\"canonicalheaders\"];\n        const signedHeaders = tuple[\"hsKeys\"];\n        const canonicalRequest = method + \"\\n\" + canonicalURI + \"\\n\" + canonicalQueryString + \"\\n\" + canonicalheaders + \"\\n\" +\n            signedHeaders.join(\";\") + \"\\n\" + payload;\n        let raw = Buffer.from(canonicalRequest);\n        const stringToSign = signatureAlgorithm + \"\\n\" + Client.hexEncode(Client.hash(raw, signatureAlgorithm));\n        const signature = Client.hexEncode(Client.signatureMethod(accessKeySecret, stringToSign, signatureAlgorithm));\n        const auth = `${signatureAlgorithm} Credential=${acesskey},SignedHeaders=${signedHeaders.join(';')},Signature=${signature}`;\n        return auth;\n    }\n    static getEncodePath(path) {\n        if (typeof path === 'undefined' || path === null) {\n            return '';\n        }\n        let strs = path.split('/');\n        for (let i = 0; i < strs.length; i++) {\n            strs[i] = encode(strs[i]);\n        }\n        return strs.join('/');\n    }\n    static getEncodeParam(param) {\n        if (typeof param === 'undefined' || param === null) {\n            return '';\n        }\n        return encode(param);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Client {\n    /**\n     * Console val with log level\n     * @param val the printing string\n     * @return void\n     * @example [LOG] tea console example\n     */\n    static log(val) {\n        console.log('[LOG] ' + val);\n    }\n    /**\n     * Console val with info level\n     * @param val the printing string\n     * @return void\n     * @example [INFO] tea console example\n     */\n    static info(val) {\n        console.log('[INFO] ' + val);\n    }\n    /**\n     * Console val with warning level\n     * @param val the printing string\n     * @return void\n     * @example [WARNING] tea console example\n     */\n    static warning(val) {\n        console.log('[WARNING] ' + val);\n    }\n    /**\n     * Console val with debug level\n     * @param val the printing string\n     * @return void\n     * @example [DEBUG] tea console example\n     */\n    static debug(val) {\n        console.log('[DEBUG] ' + val);\n    }\n    /**\n     * Console val with error level\n     * @param val the printing string\n     * @return void\n     * @example [ERROR] tea console example\n     */\n    static error(val) {\n        console.log('[ERROR] ' + val);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar querystring = __importStar(require(\"querystring\"));\nvar stream_1 = require(\"stream\");\nvar httpx = __importStar(require(\"httpx\"));\nvar url_1 = require(\"url\");\nvar BytesReadable = /** @class */ (function (_super) {\n    __extends(BytesReadable, _super);\n    function BytesReadable(value) {\n        var _this = _super.call(this) || this;\n        if (typeof value === 'string') {\n            _this.value = Buffer.from(value);\n        }\n        else if (Buffer.isBuffer(value)) {\n            _this.value = value;\n        }\n        return _this;\n    }\n    BytesReadable.prototype._read = function () {\n        this.push(this.value);\n        this.push(null);\n    };\n    return BytesReadable;\n}(stream_1.Readable));\nexports.BytesReadable = BytesReadable;\nvar Request = /** @class */ (function () {\n    function Request() {\n        this.headers = {};\n        this.query = {};\n    }\n    return Request;\n}());\nexports.Request = Request;\nvar Response = /** @class */ (function () {\n    function Response(httpResponse) {\n        this.statusCode = httpResponse.statusCode;\n        this.statusMessage = httpResponse.statusMessage;\n        this.headers = this.convertHeaders(httpResponse.headers);\n        this.body = httpResponse;\n    }\n    Response.prototype.convertHeaders = function (headers) {\n        var results = {};\n        var keys = Object.keys(headers);\n        for (var index = 0; index < keys.length; index++) {\n            var key = keys[index];\n            results[key] = headers[key];\n        }\n        return results;\n    };\n    Response.prototype.readBytes = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var buff;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, httpx.read(this.body, '')];\n                    case 1:\n                        buff = _a.sent();\n                        return [2 /*return*/, buff];\n                }\n            });\n        });\n    };\n    return Response;\n}());\nexports.Response = Response;\nfunction buildURL(request) {\n    var url = request.protocol + \"://\" + request.headers['host'];\n    if (request.port) {\n        url += \":\" + request.port;\n    }\n    url += \"\" + request.pathname;\n    var urlInfo = url_1.parse(url);\n    if (request.query && Object.keys(request.query).length > 0) {\n        if (urlInfo.query) {\n            url += \"&\" + querystring.stringify(request.query);\n        }\n        else {\n            url += \"?\" + querystring.stringify(request.query);\n        }\n    }\n    return url;\n}\nfunction isModelClass(t) {\n    if (!t) {\n        return false;\n    }\n    return typeof t.types === 'function' && typeof t.names === 'function';\n}\nfunction doAction(request, runtime) {\n    if (runtime === void 0) { runtime = null; }\n    return __awaiter(this, void 0, void 0, function () {\n        var url, method, options, response;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    url = buildURL(request);\n                    method = (request.method || 'GET').toUpperCase();\n                    options = {\n                        method: method,\n                        headers: request.headers\n                    };\n                    if (method !== 'GET' && method !== 'HEAD') {\n                        options.data = request.body;\n                    }\n                    if (runtime) {\n                        if (typeof runtime.timeout !== 'undefined') {\n                            options.timeout = Number(runtime.timeout);\n                        }\n                        if (typeof runtime.readTimeout !== 'undefined') {\n                            options.readTimeout = Number(runtime.readTimeout);\n                        }\n                        if (typeof runtime.connectTimeout !== 'undefined') {\n                            options.connectTimeout = Number(runtime.connectTimeout);\n                        }\n                        if (typeof runtime.ignoreSSL !== 'undefined') {\n                            options.rejectUnauthorized = !runtime.ignoreSSL;\n                        }\n                        if (typeof runtime.key !== 'undefined') {\n                            options.key = String(runtime.key);\n                        }\n                        if (typeof runtime.cert !== 'undefined') {\n                            options.cert = String(runtime.cert);\n                        }\n                        if (typeof runtime.ca !== 'undefined') {\n                            options.ca = String(runtime.ca);\n                        }\n                    }\n                    return [4 /*yield*/, httpx.request(url, options)];\n                case 1:\n                    response = _a.sent();\n                    return [2 /*return*/, new Response(response)];\n            }\n        });\n    });\n}\nexports.doAction = doAction;\nfunction newError(data) {\n    var message = data.code + \": \" + data.message;\n    return new Error(message);\n}\nexports.newError = newError;\nfunction getValue(type, value) {\n    if (typeof type === 'string') {\n        // basic type\n        return value;\n    }\n    if (type.type === 'array') {\n        if (!Array.isArray(value)) {\n            throw new Error(\"expect: array, actual: \" + typeof value);\n        }\n        return value.map(function (item) {\n            return getValue(type.itemType, item);\n        });\n    }\n    if (typeof type === 'function') {\n        if (isModelClass(type)) {\n            return new type(value);\n        }\n        return value;\n    }\n    return value;\n}\nfunction toMap(value) {\n    if (value === void 0) { value = undefined; }\n    if (typeof value === 'undefined' || value == null) {\n        return null;\n    }\n    if (value instanceof Model) {\n        return value.toMap();\n    }\n    // 如果是另一个版本的 tea-typescript 创建的 model，instanceof 会判断不通过\n    // 这里做一下处理\n    if (typeof value.toMap === 'function') {\n        return value.toMap();\n    }\n    if (Array.isArray(value)) {\n        return value.map(function (item) {\n            return toMap(item);\n        });\n    }\n    return value;\n}\nexports.toMap = toMap;\nvar Model = /** @class */ (function () {\n    function Model(map) {\n        var _this = this;\n        if (map == null) {\n            return;\n        }\n        var clz = this.constructor;\n        var names = clz.names();\n        var types = clz.types();\n        Object.keys(names).forEach((function (name) {\n            var value = map[name];\n            if (value === undefined || value === null) {\n                return;\n            }\n            var type = types[name];\n            _this[name] = getValue(type, value);\n        }));\n    }\n    Model.prototype.toMap = function () {\n        var _this = this;\n        var map = {};\n        var clz = this.constructor;\n        var names = clz.names();\n        Object.keys(names).forEach((function (name) {\n            var originName = names[name];\n            var value = _this[name];\n            if (typeof value === 'undefined' || value == null) {\n                return;\n            }\n            map[originName] = toMap(value);\n        }));\n        return map;\n    };\n    return Model;\n}());\nexports.Model = Model;\nfunction cast(obj, t) {\n    if (!obj) {\n        throw new Error('can not cast to Map');\n    }\n    if (typeof obj !== 'object') {\n        throw new Error('can not cast to Map');\n    }\n    var map = obj;\n    var clz = t.constructor;\n    var names = clz.names();\n    var types = clz.types();\n    Object.keys(names).forEach(function (key) {\n        var originName = names[key];\n        var value = map[originName];\n        var type = types[key];\n        if (typeof value === 'undefined' || value == null) {\n            return;\n        }\n        if (typeof type === 'string') {\n            if (type === 'Readable' ||\n                type === 'map' ||\n                type === 'Buffer' ||\n                type === 'any' ||\n                typeof value === type) {\n                t[key] = value;\n                return;\n            }\n            if (type === 'string' &&\n                (typeof value === 'number' ||\n                    typeof value === 'boolean')) {\n                t[key] = value.toString();\n                return;\n            }\n            if (type === 'boolean') {\n                if (value === 1 || value === 0) {\n                    t[key] = !!value;\n                    return;\n                }\n                if (value === 'true' || value === 'false') {\n                    t[key] = value === 'true';\n                    return;\n                }\n            }\n            if (type === 'number' && typeof value === 'string') {\n                if (value.match(/^\\d*$/)) {\n                    t[key] = parseInt(value);\n                    return;\n                }\n                if (value.match(/^[\\.\\d]*$/)) {\n                    t[key] = parseFloat(value);\n                    return;\n                }\n            }\n            throw new Error(\"type of \" + key + \" is mismatch, expect \" + type + \", but \" + typeof value);\n        }\n        else if (type.type === 'map') {\n            if (!(value instanceof Object)) {\n                throw new Error(\"type of \" + key + \" is mismatch, expect object, but \" + typeof value);\n            }\n            t[key] = value;\n        }\n        else if (type.type === 'array') {\n            if (!Array.isArray(value)) {\n                throw new Error(\"type of \" + key + \" is mismatch, expect array, but \" + typeof value);\n            }\n            if (typeof type.itemType === 'function') {\n                t[key] = value.map(function (d) {\n                    if (isModelClass(type.itemType)) {\n                        return cast(d, new type.itemType({}));\n                    }\n                    return d;\n                });\n            }\n            else {\n                t[key] = value;\n            }\n        }\n        else if (typeof type === 'function') {\n            if (!(value instanceof Object)) {\n                throw new Error(\"type of \" + key + \" is mismatch, expect object, but \" + typeof value);\n            }\n            if (isModelClass(type)) {\n                t[key] = cast(value, new type({}));\n                return;\n            }\n            t[key] = value;\n        }\n        else {\n        }\n    });\n    return t;\n}\nexports.cast = cast;\nfunction sleep(ms) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, ms);\n    });\n}\nexports.sleep = sleep;\nfunction allowRetry(retry, retryTimes, startTime) {\n    // 还未重试\n    if (retryTimes === 0) {\n        return true;\n    }\n    if (retry.retryable !== true) {\n        return false;\n    }\n    if (retry.policy === 'never') {\n        return false;\n    }\n    if (retry.policy === 'always') {\n        return true;\n    }\n    if (retry.policy === 'simple') {\n        return (retryTimes < retry['maxAttempts']);\n    }\n    if (retry.policy === 'timeout') {\n        return Date.now() - startTime < retry.timeout;\n    }\n    // 默认不重试\n    return false;\n}\nexports.allowRetry = allowRetry;\nfunction getBackoffTime(backoff, retryTimes) {\n    if (retryTimes === 0) {\n        // 首次调用，不使用退避策略\n        return 0;\n    }\n    if (backoff.policy === 'no') {\n        // 不退避\n        return 0;\n    }\n    if (backoff.policy === 'fixed') {\n        // 固定退避\n        return backoff.period;\n    }\n    if (backoff.policy === 'random') {\n        // 随机退避\n        var min = backoff['minPeriod'];\n        var max = backoff['maxPeriod'];\n        return min + (max - min) * Math.random();\n    }\n    if (backoff.policy === 'exponential') {\n        // 指数退避\n        var init = backoff.initial;\n        var multiplier = backoff.multiplier;\n        var time = init * Math.pow(1 + multiplier, retryTimes - 1);\n        var max = backoff.max;\n        return Math.min(time, max);\n    }\n    if (backoff.policy === 'exponential_random') {\n        // 指数随机退避\n        var init = backoff.initial;\n        var multiplier = backoff.multiplier;\n        var time = init * Math.pow(1 + multiplier, retryTimes - 1);\n        var max = backoff.max;\n        return Math.min(time * (0.5 + Math.random()), max);\n    }\n    return 0;\n}\nexports.getBackoffTime = getBackoffTime;\nvar UnretryableError = /** @class */ (function (_super) {\n    __extends(UnretryableError, _super);\n    function UnretryableError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'UnretryableError';\n        return _this;\n    }\n    return UnretryableError;\n}(Error));\nfunction newUnretryableError(request) {\n    var e = new UnretryableError('');\n    e.data = {\n        lastRequest: request\n    };\n    return e;\n}\nexports.newUnretryableError = newUnretryableError;\nvar RetryError = /** @class */ (function (_super) {\n    __extends(RetryError, _super);\n    function RetryError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'RetryError';\n        return _this;\n    }\n    return RetryError;\n}(Error));\nfunction retryError(request, response) {\n    var e = new RetryError('');\n    e.data = {\n        request: request,\n        response: response\n    };\n    return e;\n}\nexports.retryError = retryError;\nfunction isRetryable(err) {\n    if (typeof err === 'undefined' || err === null) {\n        return false;\n    }\n    return err.name === 'RetryError';\n}\nexports.isRetryable = isRetryable;\n//# sourceMappingURL=tea.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RuntimeOptions = void 0;\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst os_1 = require(\"os\");\nconst DEFAULT_USER_AGENT = `AlibabaCloud (${os_1.platform()}; ${os_1.arch()}) Node.js/${process.version} Core/1.0.1 TeaDSL/1`;\nclass RuntimeOptions extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            autoretry: 'autoretry',\n            ignoreSSL: 'ignoreSSL',\n            maxAttempts: 'max_attempts',\n            backoffPolicy: 'backoff_policy',\n            backoffPeriod: 'backoff_period',\n            readTimeout: 'readTimeout',\n            connectTimeout: 'connectTimeout',\n            httpProxy: 'httpProxy',\n            httpsProxy: 'httpsProxy',\n            noProxy: 'noProxy',\n            maxIdleConns: 'maxIdleConns',\n        };\n    }\n    static types() {\n        return {\n            autoretry: 'boolean',\n            ignoreSSL: 'boolean',\n            maxAttempts: 'number',\n            backoffPolicy: 'string',\n            backoffPeriod: 'number',\n            readTimeout: 'number',\n            connectTimeout: 'number',\n            httpProxy: 'string',\n            httpsProxy: 'string',\n            noProxy: 'string',\n            maxIdleConns: 'number',\n        };\n    }\n}\nexports.RuntimeOptions = RuntimeOptions;\nfunction read(readable) {\n    return new Promise((resolve, reject) => {\n        let onData, onError, onEnd;\n        var cleanup = function () {\n            // cleanup\n            readable.removeListener('error', onError);\n            readable.removeListener('data', onData);\n            readable.removeListener('end', onEnd);\n        };\n        var bufs = [];\n        var size = 0;\n        onData = function (buf) {\n            bufs.push(buf);\n            size += buf.length;\n        };\n        onError = function (err) {\n            cleanup();\n            reject(err);\n        };\n        onEnd = function () {\n            cleanup();\n            resolve(Buffer.concat(bufs, size));\n        };\n        readable.on('error', onError);\n        readable.on('data', onData);\n        readable.on('end', onEnd);\n    });\n}\nclass Client {\n    static toString(buff) {\n        return buff.toString();\n    }\n    static parseJSON(text) {\n        return JSON.parse(text);\n    }\n    static async readAsBytes(stream) {\n        return await read(stream);\n    }\n    static async readAsString(stream) {\n        let buff = await Client.readAsBytes(stream);\n        return Client.toString(buff);\n    }\n    static async readAsJSON(stream) {\n        return Client.parseJSON(await Client.readAsString(stream));\n    }\n    static getNonce() {\n        return kitx.makeNonce();\n    }\n    static getDateUTCString() {\n        const now = new Date();\n        return now.toUTCString();\n    }\n    static defaultString(real, defaultValue) {\n        return real || defaultValue;\n    }\n    static defaultNumber(real, defaultValue) {\n        return real || defaultValue;\n    }\n    static toFormString(val) {\n        return querystring_1.default.stringify(val);\n    }\n    static toJSONString(val) {\n        if (typeof val === 'string') {\n            return val;\n        }\n        return JSON.stringify(val);\n    }\n    static toBytes(val) {\n        return Buffer.from(val);\n    }\n    static empty(val) {\n        return !val;\n    }\n    static equalString(val1, val2) {\n        return val1 === val2;\n    }\n    static equalNumber(val1, val2) {\n        return val1 === val2;\n    }\n    static isUnset(value) {\n        if (typeof value === 'undefined') {\n            return true;\n        }\n        if (value === null) {\n            return true;\n        }\n        return false;\n    }\n    static stringifyMapValue(m) {\n        if (!m) {\n            return m;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(m)) {\n            if (typeof value === 'undefined' || value === null) {\n                continue;\n            }\n            result[key] = String(value);\n        }\n        return result;\n    }\n    static anyifyMapValue(m) {\n        return m;\n    }\n    static assertAsBoolean(value) {\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        throw new Error(`The value is not a boolean`);\n    }\n    static assertAsString(value) {\n        if (typeof value === 'string') {\n            return value;\n        }\n        throw new Error(`The value is not a string`);\n    }\n    static assertAsNumber(value) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        throw new Error(`The value is not a number`);\n    }\n    static assertAsMap(value) {\n        if (value && typeof value === 'object' && !Array.isArray(value)) {\n            return value;\n        }\n        throw new Error(`The value is not a object`);\n    }\n    static assertAsArray(value) {\n        if (Array.isArray(value)) {\n            return value;\n        }\n        throw new Error(`The value is not array`);\n    }\n    static assertAsBytes(value) {\n        if (Buffer.isBuffer(value)) {\n            return value;\n        }\n        throw new Error(`The value is not bytes`);\n    }\n    static getUserAgent(userAgent) {\n        if (!userAgent || !userAgent.length) {\n            return DEFAULT_USER_AGENT;\n        }\n        return DEFAULT_USER_AGENT + \" \" + userAgent;\n    }\n    static is2xx(code) {\n        return code >= 200 && code < 300;\n    }\n    static is3xx(code) {\n        return code >= 300 && code < 400;\n    }\n    static is4xx(code) {\n        return code >= 400 && code < 500;\n    }\n    static is5xx(code) {\n        return code >= 500 && code < 600;\n    }\n    static validateModel(m) {\n    }\n    static toMap(inputModel) {\n        return $tea.toMap(inputModel);\n    }\n    static async sleep(millisecond) {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                resolve();\n            }, millisecond);\n        });\n    }\n    static toArray(input) {\n        if (!(input instanceof Array)) {\n            return null;\n        }\n        let ret = [];\n        input.forEach((model) => {\n            if (!model) {\n                return;\n            }\n            ret.push($tea.toMap(model));\n        });\n        return ret;\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","'use strict';\n\nconst zlib = require('zlib');\nconst http = require('http');\nconst https = require('https');\nconst parse = require('url').parse;\nconst format = require('url').format;\n\nconst debugBody = require('debug')('httpx:body');\nconst debugHeader = require('debug')('httpx:header');\n\nconst httpAgent = new http.Agent({ keepAlive: true });\nconst httpsAgent = new https.Agent({ keepAlive: true });\n\nconst TIMEOUT = 3000; // 3s\n\nconst READ_TIMER = Symbol('TIMER::READ_TIMER');\nconst READ_TIME_OUT = Symbol('TIMER::READ_TIME_OUT');\nconst READ_TIMER_START_AT = Symbol('TIMER::READ_TIMER_START_AT');\n\nvar append = function (err, name, message) {\n  err.name = name + err.name;\n  err.message = `${message}. ${err.message}`;\n  return err;\n};\n\nconst isNumber = function (num) {\n  return num !== null && !isNaN(num);\n};\n\nexports.request = function (url, opts) {\n  // request(url)\n  opts || (opts = {});\n\n  const parsed = typeof url === 'string' ? parse(url) : url;\n\n  let readTimeout, connectTimeout;\n  if (isNumber(opts.readTimeout) || isNumber(opts.connectTimeout)) {\n    readTimeout = isNumber(opts.readTimeout) ? Number(opts.readTimeout) : TIMEOUT;\n    connectTimeout = isNumber(opts.connectTimeout) ? Number(opts.connectTimeout) : TIMEOUT;\n  } else if (isNumber(opts.timeout)) {\n    readTimeout = connectTimeout = Number(opts.timeout);\n  } else {\n    readTimeout = connectTimeout = TIMEOUT;\n  }\n\n  const isHttps = parsed.protocol === 'https:';\n  const method = (opts.method || 'GET').toUpperCase();\n  const defaultAgent = isHttps ? httpsAgent : httpAgent;\n  const agent = opts.agent || defaultAgent;\n\n  var options = {\n    host: parsed.hostname || 'localhost',\n    path: parsed.path || '/',\n    method: method,\n    port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),\n    agent: agent,\n    headers: opts.headers || {},\n    // ssl config\n    key: opts.key || '',\n    cert: opts.cert || '',\n    ca: opts.ca || '',\n    // connect timerout\n    timeout: connectTimeout\n  };\n\n  if (isHttps && typeof opts.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = opts.rejectUnauthorized;\n  }\n\n  if (opts.compression) {\n    options.headers['accept-encoding'] = 'gzip,deflate';\n  }\n\n  const httplib = isHttps ? https : http;\n\n  if (typeof opts.beforeRequest === 'function') {\n    options = opts.beforeRequest(options);\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = httplib.request(options);\n    const body = opts.data;\n\n    var fulfilled = (response) => {\n      if (debugHeader.enabled) {\n        const requestHeaders = response.req._header;\n        requestHeaders.split('\\r\\n').forEach((line) => {\n          debugHeader('> %s', line);\n        });\n\n        debugHeader('< HTTP/%s %s %s', response.httpVersion, response.statusCode, response.statusMessage);\n        Object.keys(response.headers).forEach((key) => {\n          debugHeader('< %s: %s', key, response.headers[key]);\n        });\n      }\n      resolve(response);\n    };\n\n    var rejected = (err) => {\n      err.message += `${method} ${format(parsed)} failed.`;\n      // clear response timer when error\n      if (request.socket && request.socket[READ_TIMER]) {\n        clearTimeout(request.socket[READ_TIMER]);\n      }\n      reject(err);\n    };\n\n    var abort = (err) => {\n      request.abort();\n      rejected(err);\n    };\n\n    const startResponseTimer = function (socket) {\n      const timer = setTimeout(() => {\n        if (socket[READ_TIMER]) {\n          clearTimeout(socket[READ_TIMER]);\n          socket[READ_TIMER] = null;\n        }\n        var err = new Error();\n        var message = `ReadTimeout(${readTimeout})`;\n        abort(append(err, 'RequestTimeout', message));\n      }, readTimeout);\n      // start read-timer\n      socket[READ_TIME_OUT] = readTimeout;\n      socket[READ_TIMER] = timer;\n      socket[READ_TIMER_START_AT] = Date.now();\n    };\n\n    // string\n    if (!body || 'string' === typeof body || body instanceof Buffer) {\n      if (debugBody.enabled) {\n        if (!body) {\n          debugBody('<no request body>');\n        } else if ('string' === typeof body) {\n          debugBody(body);\n        } else {\n          debugBody(`Buffer <ignored>, Buffer length: ${body.length}`);\n        }\n      }\n      request.end(body);\n    } else if ('function' === typeof body.pipe) { // stream\n      body.pipe(request);\n      if (debugBody.enabled) {\n        debugBody('<request body is a stream>');\n      }\n      body.once('error', (err) => {\n        abort(append(err, 'HttpX', 'Stream occor error'));\n      });\n    }\n\n    request.on('response', fulfilled);\n    request.on('error', rejected);\n    request.once('socket', function (socket) {\n      // reuse socket\n      if (socket.readyState === 'opening') {\n        socket.once('connect', function () {\n          startResponseTimer(socket);\n        });\n      } else {\n        startResponseTimer(socket);\n      }\n    });\n  });\n};\n\nexports.read = function (response, encoding) {\n  var readable = response;\n  switch (response.headers['content-encoding']) {\n  // or, just use zlib.createUnzip() to handle both cases\n  case 'gzip':\n    readable = response.pipe(zlib.createGunzip());\n    break;\n  case 'deflate':\n    readable = response.pipe(zlib.createInflate());\n    break;\n  default:\n    break;\n  }\n\n  return new Promise((resolve, reject) => {\n    // node.js 14 use response.client\n    const socket = response.socket || response.client;\n\n    const makeReadTimeoutError = () => {\n      const req = response.req;\n      var err = new Error();\n      err.name = 'RequestTimeoutError';\n      err.message = `ReadTimeout: ${socket[READ_TIME_OUT]}. ${req.method} ${req.path} failed.`;\n      return err;\n    };\n    // check read-timer\n    let readTimer;\n    const oldReadTimer = socket[READ_TIMER];\n    if (!oldReadTimer) {\n      reject(makeReadTimeoutError());\n      return;\n    }\n    const remainTime = socket[READ_TIME_OUT] - (Date.now() - socket[READ_TIMER_START_AT]);\n    clearTimeout(oldReadTimer);\n    if (remainTime <= 0) {\n      reject(makeReadTimeoutError());\n      return;\n    }\n    readTimer = setTimeout(function () {\n      reject(makeReadTimeoutError());\n    }, remainTime);\n\n    // start reading data\n    var onError, onData, onEnd;\n    var cleanup = function () {\n      // cleanup\n      readable.removeListener('error', onError);\n      readable.removeListener('data', onData);\n      readable.removeListener('end', onEnd);\n      // clear read timer\n      if (readTimer) {\n        clearTimeout(readTimer);\n      }\n    };\n\n    const bufs = [];\n    var size = 0;\n\n    onData = function (buf) {\n      bufs.push(buf);\n      size += buf.length;\n    };\n\n    onError = function (err) {\n      cleanup();\n      reject(err);\n    };\n\n    onEnd = function () {\n      cleanup();\n      var buff = Buffer.concat(bufs, size);\n\n      debugBody('');\n      if (encoding) {\n        const result = buff.toString(encoding);\n        debugBody(result);\n        return resolve(result);\n      }\n\n      if (debugBody.enabled) {\n        debugBody(buff.toString());\n      }\n      resolve(buff);\n    };\n\n    readable.on('error', onError);\n    readable.on('data', onData);\n    readable.on('end', onEnd);\n  });\n};\n","exports.parse = exports.decode = decode\n\nexports.stringify = exports.encode = encode\n\nexports.safe = safe\nexports.unsafe = unsafe\n\nvar eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nfunction encode (obj, opt) {\n  var children = []\n  var out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false,\n    }\n  } else {\n    opt = opt || {}\n    opt.whitespace = opt.whitespace === true\n  }\n\n  var separator = opt.whitespace ? ' = ' : '='\n\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k]\n    if (val && Array.isArray(val)) {\n      val.forEach(function (item) {\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n      })\n    } else if (val && typeof val === 'object')\n      children.push(k)\n    else\n      out += safe(k) + separator + safe(val) + eol\n  })\n\n  if (opt.section && out.length)\n    out = '[' + safe(opt.section) + ']' + eol + out\n\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.')\n    var section = (opt.section ? opt.section + '.' : '') + nk\n    var child = encode(obj[k], {\n      section: section,\n      whitespace: opt.whitespace,\n    })\n    if (out.length && child.length)\n      out += eol\n\n    out += child\n  })\n\n  return out\n}\n\nfunction dotSplit (str) {\n  return str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./).map(function (part) {\n      return part.replace(/\\1/g, '\\\\.')\n        .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001')\n    })\n}\n\nfunction decode (str) {\n  var out = {}\n  var p = out\n  var section = null\n  //          section     |key      = value\n  var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  var lines = str.split(/[\\r\\n]+/g)\n\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/))\n      return\n    var match = line.match(re)\n    if (!match)\n      return\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = {}\n        return\n      }\n      p = out[section] = out[section] || {}\n      return\n    }\n    var key = unsafe(match[2])\n    if (key === '__proto__')\n      return\n    var value = match[3] ? unsafe(match[4]) : true\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null': value = JSON.parse(value)\n    }\n\n    // Convert keys with '[]' suffix to an array\n    if (key.length > 2 && key.slice(-2) === '[]') {\n      key = key.substring(0, key.length - 2)\n      if (key === '__proto__')\n        return\n      if (!p[key])\n        p[key] = []\n      else if (!Array.isArray(p[key]))\n        p[key] = [p[key]]\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key]))\n      p[key].push(value)\n    else\n      p[key] = value\n  })\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k]))\n      return false\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    var parts = dotSplit(k)\n    var p = out\n    var l = parts.pop()\n    var nl = l.replace(/\\\\\\./g, '.')\n    parts.forEach(function (part, _, __) {\n      if (part === '__proto__')\n        return\n      if (!p[part] || typeof p[part] !== 'object')\n        p[part] = {}\n      p = p[part]\n    })\n    if (p === out && nl === l)\n      return false\n\n    p[nl] = out[k]\n    return true\n  }).forEach(function (del, _, __) {\n    delete out[del]\n  })\n\n  return out\n}\n\nfunction isQuoted (val) {\n  return (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n}\n\nfunction safe (val) {\n  return (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n    ? JSON.stringify(val)\n    : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n}\n\nfunction unsafe (val, doUnesc) {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\")\n      val = val.substr(1, val.length - 2)\n\n    try {\n      val = JSON.parse(val)\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false\n    var unesc = ''\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1)\n          unesc += c\n        else\n          unesc += '\\\\' + c\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1)\n        break\n      else if (c === '\\\\')\n        esc = true\n      else\n        unesc += c\n    }\n    if (esc)\n      unesc += '\\\\'\n\n    return unesc.trim()\n  }\n  return val\n}\n","'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst crypto = require('crypto');\n\n/**\n * Load *.json file synchronous. Don't use require('*.json')\n * to load *.json files, it will cached in process.\n * @param {String} filename absolute file path\n * @return {Object} a parsed object\n */\nexports.loadJSONSync = function (filename) {\n  // strip BOM\n  var content = fs.readFileSync(filename, 'utf8');\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  try {\n    return JSON.parse(content);\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n/**\n * Encoding a string to Buffer safely\n * @param {String} str string.\n * @param {String} encoding. optional.\n * @return {Buffer} encoded buffer\n */\nexports.encode = function (str, encoding) {\n  if (typeof str !== 'string') {\n    str = '' + str;\n  }\n\n  return Buffer.from(str, encoding);\n};\n\n/**\n * Generate a haser with specfied algorithm\n * @param {String} algorithm can be md5, etc.\n * @return {Function} a haser with specfied algorithm\n */\nexports.makeHasher = function (algorithm) {\n  return function (data, encoding) {\n    var shasum = crypto.createHash(algorithm);\n    shasum.update(data);\n    return shasum.digest(encoding);\n  };\n};\n\nexports.createHash = exports.makeHasher;\n\n/**\n * Get md5 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} encoding optional. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.md5 = exports.makeHasher('md5');\n\n/**\n * Get sha1 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} key the key.\n * @param {String} encoding optionnal. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.createHmac = function (algorithm) {\n  return function (data, key, encoding) {\n    return crypto.createHmac(algorithm, key).update(data).digest(encoding);\n  };\n};\n\n/**\n * Get sha1 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} key the key.\n * @param {String} encoding optionnal. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.sha1 = exports.createHmac('sha1');\n\n/**\n * Get a random value in a range\n * @param {Number} min range start.\n * @param {Number} max range end.\n */\nexports.random = function (min, max) {\n  return Math.floor(min + Math.random() * (max - min));\n};\n\n/**\n * Generate a nonce string\n * @return {String} a nonce string.\n */\nexports.makeNonce = (function () {\n  var counter = 0;\n  var last;\n  const machine = os.hostname();\n  const pid = process.pid;\n\n  return function () {\n    var val = Math.floor(Math.random() * 1000000000000);\n    if (val === last) {\n      counter++;\n    } else {\n      counter = 0;\n    }\n\n    last = val;\n\n    var uid = `${machine}${pid}${val}${counter}`;\n    return exports.md5(uid, 'hex');\n  };\n}());\n\n/**\n * Pad a number as \\d\\d format\n * @param {Number} num a number that less than 100.\n * @return {String} if number less than 10, pad with 0,\n *  otherwise, returns string of number.\n */\nexports.pad2 = function (num) {\n  if (num < 10) {\n    return '0' + num;\n  }\n  return '' + num;\n};\n\n/**\n * Pad a number as \\d\\d\\d format\n * @param {Number} num a number that less than 1000.\n * @return {String} if number less than 100, pad with 0,\n *  otherwise, returns string of number.\n */\nexports.pad3 = function (num) {\n  if (num < 10) {\n    return '00' + num;\n  } else if (num < 100) {\n    return '0' + num;\n  }\n  return '' + num;\n};\n\n/**\n * Return the YYYYMMDD format of a date.\n * @param {Date} date a Date object.\n * @return {String} the YYYYMMDD format.\n */\nexports.getYYYYMMDD = function (date) {\n  var YYYY = date.getFullYear();\n  var MM = exports.pad2(date.getMonth() + 1);\n  var DD = exports.pad2(date.getDate());\n  return '' + YYYY + MM + DD;\n};\n\n/**\n * sleep a while.\n * @param {Number} in milliseconds\n * @return {Promise} a Promise\n */\nexports.sleep = function (ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\n/**\n * Get the IPv4 address\n * @return {String} the IPv4 address, or empty string\n */\nexports.getIPv4 = function () {\n  var interfaces = os.networkInterfaces();\n  var keys = Object.keys(interfaces);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var addresses = interfaces[key];\n    for (var j = 0; j < addresses.length; j++) {\n      var item = addresses[j];\n      if (!item.internal && item.family === 'IPv4') {\n        return item.address;\n      }\n    }\n  }\n\n  // without non-internal address\n  return '';\n};\n\n/**\n * Get the Mac address\n * @return {String} the Mac address\n */\nexports.getMac = function () {\n  var interfaces = os.networkInterfaces();\n  var keys = Object.keys(interfaces);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var addresses = interfaces[key];\n    for (var j = 0; j < addresses.length; j++) {\n      var item = addresses[j];\n      if (!item.internal && item.family === 'IPv4') {\n        return item.mac;\n      }\n    }\n  }\n\n  // without non-internal address\n  return '00:00:00:00:00:00';\n};\n\n/**\n * Read all bytes from a readable\n * @return {Readable} the readable stream\n * @return {Promise} a Promise with all bytes\n */\nexports.readAll = function (readable) {\n  return new Promise((resolve, reject) => {\n    var onError, onData, onEnd;\n    var cleanup = function (err) {\n      // cleanup\n      readable.removeListener('error', onError);\n      readable.removeListener('data', onData);\n      readable.removeListener('end', onEnd);\n    };\n\n    var bufs = [];\n    var size = 0;\n\n    onData = function (buf) {\n      bufs.push(buf);\n      size += buf.length;\n    };\n\n    onError = function (err) {\n      cleanup();\n      reject(err);\n    };\n\n    onEnd = function () {\n      cleanup();\n      resolve(Buffer.concat(bufs, size));\n    };\n\n    readable.on('error', onError);\n    readable.on('data', onData);\n    readable.on('end', onEnd);\n  });\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","module.exports = require(\"assert\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"querystring\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3109);\n"],"mappings":";;;;;;;A;;A;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/hnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AClIA;;;A;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACvQA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;;;;A","sourceRoot":""}